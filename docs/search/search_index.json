{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#observant","title":"Observant","text":"<p>A reactive state management library for Python with observable objects, validation, undo/redo, and computed properties.</p>"},{"location":"#what-is-observant","title":"What is Observant?","text":"<p>Observant is a Python library that brings reactive programming to your data models. It allows you to:</p> <ul> <li>Track changes to your data</li> <li>Validate data as it changes</li> <li>Implement undo/redo functionality</li> <li>Create computed properties that update automatically</li> <li>Keep track of \"dirty\" state for unsaved changes</li> </ul> <p>At its core, Observant provides observable objects that notify listeners when their values change, making it easy to build reactive applications.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install observant\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#observable-objects","title":"Observable Objects","text":"<pre><code>from observant import Observable\n\n# Create an observable value\ncounter = Observable[int](0)\n\n# Listen for changes\ncounter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n# Update the value\ncounter.set(1)  # Prints: \"Counter changed to 1\"\n</code></pre>"},{"location":"#observable-collections","title":"Observable Collections","text":"<pre><code>from observant import ObservableList, ObservableDict\n\n# Observable list\ntasks = ObservableList[str]([\"Buy milk\"])\ntasks.on_change(lambda change: print(f\"Tasks changed: {change}\"))\ntasks.append(\"Write docs\")\n\n# Observable dictionary\nsettings = ObservableDict[str, str]({\"theme\": \"dark\"})\nsettings.on_change(lambda change: print(f\"Settings changed: {change}\"))\nsettings[\"language\"] = \"en\"\n</code></pre>"},{"location":"#observable-proxy","title":"Observable Proxy","text":"<pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user)\n\n# Get observable for a field\nname_obs = proxy.observable(str, \"name\")\nname_obs.on_change(lambda value: print(f\"Name changed to {value}\"))\n\n# Update the field\nname_obs.set(\"Alicia\")  # Prints: \"Name changed to Alicia\"\n\n# Save changes back to the model\nproxy.save_to(user)\nprint(user.name)  # Prints: \"Alicia\"\n</code></pre>"},{"location":"#validation","title":"Validation","text":"<pre><code>from observant import ObservableProxy\n\n# Add validators\nproxy.add_validator(\"age\", lambda age: \"Must be positive\" if age &lt;= 0 else None)\nproxy.add_validator(\"name\", lambda name: \"Name too short\" if len(name) &lt; 3 else None)\n\n# Check validation state\nprint(proxy.is_valid())  # True or False\nprint(proxy.validation_errors())  # Dictionary of field errors\n</code></pre>"},{"location":"#undoredo","title":"Undo/Redo","text":"<pre><code>from observant import ObservableProxy\n\n# Enable undo\nproxy = ObservableProxy(user, undo=True)\n\n# Make changes\nproxy.observable(str, \"name\").set(\"Bob\")\nproxy.observable(int, \"age\").set(25)\n\n# Undo changes\nproxy.undo(\"name\")  # Reverts name to \"Alicia\"\nproxy.undo(\"age\")   # Reverts age to 30\n\n# Redo changes\nproxy.redo(\"name\")  # Sets name back to \"Bob\"\n</code></pre>"},{"location":"#computed-properties","title":"Computed Properties","text":"<pre><code>from observant import ObservableProxy\n\n# Register a computed property\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\n\n# Access the computed value\nprint(proxy.computed(str, \"full_name\").get())\n</code></pre>"},{"location":"#complete-form-example","title":"Complete Form Example","text":"<pre><code># This is a complete form implementation with validation, dirty tracking, and save logic\nfrom dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass FormData:\n    username: str\n    email: str\n    age: int\n\n# Create a model and proxy\nform = FormData(username=\"\", email=\"\", age=0)\nproxy = ObservableProxy(form, undo=True)\n\n# Add validation\nproxy.add_validator(\"username\", lambda v: \"Required\" if not v else None)\nproxy.add_validator(\"email\", lambda v: \"Invalid email\" if \"@\" not in v else None)\nproxy.add_validator(\"age\", lambda v: \"Must be 18+\" if v &lt; 18 else None)\n\n# Update fields\nproxy.observable(str, \"username\").set(\"alice\")\nproxy.observable(str, \"email\").set(\"alice@example.com\")\nproxy.observable(int, \"age\").set(25)\n\n# Check if valid\nif proxy.is_valid():\n    # Save changes\n    proxy.save_to(form)\n    print(\"Form saved!\")\n\n    # Reset dirty state after saving\n    proxy.reset_dirty()\nelse:\n    # Show errors\n    print(\"Validation errors:\", proxy.validation_errors())\n</code></pre>"},{"location":"#where-to-go-next","title":"Where to Go Next","text":"<ul> <li>Getting Started - Learn the basics</li> <li>Change Tracking - Understand how observables work</li> <li>API Reference - Detailed API documentation</li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":"<p>This guide will help you get started with Observant, a reactive state management library for Python.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Install Observant using pip:</p> <pre><code>pip install observant\n</code></pre>"},{"location":"getting_started/#basic-concepts","title":"Basic Concepts","text":"<p>Before diving into code examples, let's understand the core concepts of Observant.</p>"},{"location":"getting_started/#observable","title":"Observable","text":"<p>An <code>Observable</code> is a wrapper around a value that notifies listeners when the value changes. It's the simplest building block in Observant.</p> <pre><code>from observant import Observable\n\n# Create an observable with an initial value\nname = Observable[str](\"Alice\")\n\n# Register a callback to be notified when the value changes\nname.on_change(lambda value: print(f\"Name changed to: {value}\"))\n\n# Change the value\nname.set(\"Bob\")  # Prints: \"Name changed to: Bob\"\n\n# Get the current value\ncurrent_name = name.get()  # Returns: \"Bob\"\n</code></pre>"},{"location":"getting_started/#observablelist-and-observabledict","title":"ObservableList and ObservableDict","text":"<p>Observant also provides observable collections that notify listeners when items are added, removed, or updated.</p> <pre><code>from observant import ObservableList, ObservableDict\n\n# Observable list\ntasks = ObservableList[str]([\"Task 1\"])\ntasks.on_change(lambda change: print(f\"Tasks changed: {change}\"))\ntasks.append(\"Task 2\")  # Notifies listeners\n\n# Observable dictionary\nsettings = ObservableDict[str, str]({\"theme\": \"dark\"})\nsettings.on_change(lambda change: print(f\"Settings changed: {change}\"))\nsettings[\"language\"] = \"en\"  # Notifies listeners\n</code></pre>"},{"location":"getting_started/#observableproxy","title":"ObservableProxy","text":"<p>The <code>ObservableProxy</code> is the most powerful component in Observant. It wraps an object (typically a dataclass) and provides observable access to its fields.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n    email: str\n\n# Create a user and wrap it with a proxy\nuser = User(name=\"Alice\", age=30, email=\"alice@example.com\")\nproxy = ObservableProxy(user)\n\n# Get observables for individual fields\nname_obs = proxy.observable(str, \"name\")\nage_obs = proxy.observable(int, \"age\")\n\n# Register change listeners\nname_obs.on_change(lambda value: print(f\"Name changed to: {value}\"))\nage_obs.on_change(lambda value: print(f\"Age changed to: {value}\"))\n\n# Update fields\nname_obs.set(\"Alicia\")  # Prints: \"Name changed to: Alicia\"\nage_obs.set(31)         # Prints: \"Age changed to: 31\"\n\n# Save changes back to the original object\nproxy.save_to(user)\nprint(user.name)  # Prints: \"Alicia\"\nprint(user.age)   # Prints: 31\n</code></pre>"},{"location":"getting_started/#minimal-example","title":"Minimal Example","text":"<p>Here's a complete example showing how to use Observant with a simple form:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass LoginForm:\n    username: str\n    password: str\n    remember_me: bool\n\n# Create a form and proxy\nform = LoginForm(username=\"\", password=\"\", remember_me=False)\nproxy = ObservableProxy(form)\n\n# Add validation\nproxy.add_validator(\"username\", lambda v: \"Username required\" if not v else None)\nproxy.add_validator(\"password\", lambda v: \"Password too short\" if len(v) &lt; 8 else None)\n\n# Track changes\nproxy.observable(str, \"username\").on_change(lambda v: print(f\"Username: {v}\"))\nproxy.observable(str, \"password\").on_change(lambda v: print(f\"Password: {'*' * len(v)}\"))\nproxy.observable(bool, \"remember_me\").on_change(lambda v: print(f\"Remember me: {v}\"))\n\n# Update fields\nproxy.observable(str, \"username\").set(\"alice\")\nproxy.observable(str, \"password\").set(\"securepassword\")\nproxy.observable(bool, \"remember_me\").set(True)\n\n# Check validation\nif proxy.is_valid():\n    print(\"Form is valid!\")\n    proxy.save_to(form)\nelse:\n    print(\"Validation errors:\", proxy.validation_errors())\n</code></pre>"},{"location":"getting_started/#anatomy-of-a-proxy","title":"Anatomy of a Proxy","text":"<p>The <code>ObservableProxy</code> is the central component of Observant. Here's what it provides:</p> <ol> <li> <p>Field Observables: Access individual fields as observables    <pre><code>name_obs = proxy.observable(str, \"name\")\n</code></pre></p> </li> <li> <p>Collection Observables: Access lists and dictionaries as observable collections    <pre><code>tasks_list = proxy.observable_list(str, \"tasks\")\nsettings_dict = proxy.observable_dict((str, str), \"settings\")\n</code></pre></p> </li> <li> <p>Validation: Add validators to fields and check validation state    <pre><code>proxy.add_validator(\"email\", lambda v: \"Invalid email\" if \"@\" not in v else None)\nis_valid = proxy.is_valid()\nerrors = proxy.validation_errors()\n</code></pre></p> </li> <li> <p>Computed Properties: Define properties that depend on other fields    <pre><code>proxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\nfull_name = proxy.computed(str, \"full_name\").get()\n</code></pre></p> </li> <li> <p>Undo/Redo: Track changes and undo/redo them    <pre><code>proxy = ObservableProxy(user, undo=True)\nproxy.observable(str, \"name\").set(\"Bob\")\nproxy.undo(\"name\")  # Reverts to previous value\n</code></pre></p> </li> <li> <p>Dirty Tracking: Track unsaved changes    <pre><code>is_dirty = proxy.is_dirty()\ndirty_fields = proxy.dirty_fields()\nproxy.reset_dirty()\n</code></pre></p> </li> <li> <p>Saving and Loading: Save changes back to the model or load from a dictionary    <pre><code>proxy.save_to(user)\nproxy.load_dict({\"name\": \"Charlie\", \"age\": 25})\n</code></pre></p> </li> </ol>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, you can explore more advanced features:</p> <ul> <li>Change Tracking: Learn more about observables and change notifications</li> <li>Validation: Add validation to your models</li> <li>Computed Properties: Create properties that depend on other fields</li> <li>Undo and Redo: Implement undo/redo functionality</li> <li>Dirty Tracking: Track unsaved changes</li> <li>Sync vs Non-Sync: Understand immediate vs. deferred updates</li> <li>Saving and Loading: Save changes and load data</li> </ul>"},{"location":"api_reference/","title":"API Reference","text":"<p>This section provides detailed documentation for the Observant API. It covers all the classes, methods, and types available in the library.</p>"},{"location":"api_reference/#core-classes","title":"Core Classes","text":"<ul> <li>Observable: The base observable class for scalar values</li> <li>ObservableList: An observable list that notifies listeners when items are added, removed, or modified</li> <li>ObservableDict: An observable dictionary that notifies listeners when items are added, updated, or removed</li> <li>ObservableProxy: An observable proxy that wraps an object and provides observable access to its fields</li> </ul>"},{"location":"api_reference/#types","title":"Types","text":"<p>The Types section documents the various types used throughout the library:</p> <ul> <li>ObservableCollectionChangeType: An enum that represents the type of change that occurred in a collection</li> <li>ObservableListChange: A class that represents a change to an observable list</li> <li>ObservableDictChange: A class that represents a change to an observable dictionary</li> <li>ProxyFieldKey: A class that represents a field key in an ObservableProxy</li> <li>UndoConfig: A class that represents the configuration for undo/redo functionality</li> </ul>"},{"location":"api_reference/#interfaces","title":"Interfaces","text":"<p>The Interfaces section documents the interfaces that define the contract for observable objects:</p> <ul> <li>IObservable: The base interface for observable objects</li> <li>IObservableList: The interface for observable lists</li> <li>IObservableDict: The interface for observable dictionaries</li> <li>IObservableProxy: The interface for observable proxies</li> </ul>"},{"location":"api_reference/observable/","title":"Observable","text":""},{"location":"api_reference/observable/#observant.observable.Observable","title":"<code>observant.observable.Observable</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>IObservable[T]</code></p> <p>A generic observable value that notifies listeners when its value changes.</p> <p>Observable is the core building block of Observant's reactive system. It wraps a single value and provides methods to get, set, and observe changes to that value.</p> <p>Attributes:</p> Name Type Description <code>_value</code> <code>T</code> <p>The current value of the observable.</p> <code>_callbacks</code> <code>list[Callable[[T], None]]</code> <p>List of callback functions to be called when the value changes.</p> <code>_on_change_enabled</code> <code>bool</code> <p>Whether callbacks are enabled.</p> <p>Examples:</p> <pre><code># Create an observable integer\ncounter = Observable[int](0)\n\n# Register a callback to be notified when the value changes\ncounter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n# Update the value\ncounter.set(1)  # Prints: \"Counter changed to 1\"\n\n# Get the current value\ncurrent_value = counter.get()  # Returns: 1\n</code></pre> Source code in <code>observant\\observable.py</code> <pre><code>class Observable(Generic[T], IObservable[T]):\n    \"\"\"\n    A generic observable value that notifies listeners when its value changes.\n\n    Observable is the core building block of Observant's reactive system. It wraps\n    a single value and provides methods to get, set, and observe changes to that value.\n\n    Attributes:\n        _value: The current value of the observable.\n        _callbacks: List of callback functions to be called when the value changes.\n        _on_change_enabled: Whether callbacks are enabled.\n\n    Examples:\n        ```python\n        # Create an observable integer\n        counter = Observable[int](0)\n\n        # Register a callback to be notified when the value changes\n        counter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n        # Update the value\n        counter.set(1)  # Prints: \"Counter changed to 1\"\n\n        # Get the current value\n        current_value = counter.get()  # Returns: 1\n        ```\n    \"\"\"\n\n    _value: T\n    _callbacks: list[Callable[[T], None]]\n    _on_change_enabled: bool = True\n\n    def __init__(self, value: T, *, on_change: Callable[[T], None] | None = None, on_change_enabled: bool = True) -&gt; None:\n        \"\"\"\n        Initialize the Observable with a value.\n\n        Args:\n            value: The initial value of the observable.\n            on_change: Optional callback function to register immediately.\n            on_change_enabled: Whether callbacks should be enabled initially.\n        \"\"\"\n        print(f\"DEBUG: Observable.__init__ called with value {value}\")\n        self._value = value\n        self._callbacks = []\n        self._on_change_enabled = on_change_enabled\n        print(\"DEBUG: Observable.__init__ - Initialized with empty callbacks list\")\n\n    @override\n    def get(self) -&gt; T:\n        \"\"\"\n        Get the current value of the observable.\n\n        Returns:\n            The current value stored in this observable.\n\n        Examples:\n            ```python\n            counter = Observable[int](0)\n            value = counter.get()  # Returns: 0\n            ```\n        \"\"\"\n        return self._value\n\n    @override\n    def set(self, value: T, notify: bool = True) -&gt; None:\n        \"\"\"\n        Set a new value for the observable and notify all registered callbacks.\n\n        This method updates the internal value and, if notify is True and callbacks\n        are enabled, calls all registered callbacks with the new value.\n\n        Args:\n            value: The new value to set.\n            notify: Whether to notify the callbacks after setting the value.\n\n        Examples:\n            ```python\n            counter = Observable[int](0)\n            counter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n            # Update with notification\n            counter.set(1)  # Prints: \"Counter changed to 1\"\n\n            # Update without notification\n            counter.set(2, notify=False)  # No output\n            ```\n        \"\"\"\n        print(f\"DEBUG: Observable.set called with value {value}\")\n        self._value = value\n\n        if not notify or not self._on_change_enabled:\n            print(\"DEBUG: Observable.set - on_change is disabled, skipping callbacks\")\n            return\n\n        print(f\"DEBUG: Observable.set - Notifying {len(self._callbacks)} callbacks\")\n        for i, callback in enumerate(self._callbacks):\n            print(f\"DEBUG: Observable.set - Calling callback {i}\")\n            callback(value)\n            print(f\"DEBUG: Observable.set - Callback {i} completed\")\n        print(\"DEBUG: Observable.set - Completed\")\n\n    @override\n    def on_change(self, callback: Callable[[T], None]) -&gt; None:\n        \"\"\"\n        Register a callback function to be called when the value changes.\n\n        The callback will be called with the new value whenever set() is called\n        with notify=True and callbacks are enabled. Callbacks are called in the\n        order they were registered.\n\n        If the same callback function is registered multiple times, it will only\n        be added once.\n\n        Args:\n            callback: A function that takes the new value as its argument.\n\n        Examples:\n            ```python\n            counter = Observable[int](0)\n\n            # Register a callback\n            counter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n            # Register another callback\n            counter.on_change(lambda value: print(f\"Counter is now {value}\"))\n\n            # Update the value\n            counter.set(1)\n            # Prints:\n            # \"Counter changed to 1\"\n            # \"Counter is now 1\"\n            ```\n        \"\"\"\n        print(f\"DEBUG: Observable.on_change called, current callbacks: {len(self._callbacks)}\")\n        # Check if this callback is already registered to avoid duplicates\n        for existing_cb in self._callbacks:\n            if existing_cb == callback:\n                print(\"DEBUG: Observable.on_change - Callback already registered, skipping\")\n                return\n\n        self._callbacks.append(callback)\n        print(f\"DEBUG: Observable.on_change - Added callback, now have {len(self._callbacks)} callbacks\")\n\n    @override\n    def enable(self) -&gt; None:\n        \"\"\"\n        Enable the observable to notify changes.\n\n        After calling this method, subsequent calls to set() with notify=True\n        will trigger callbacks.\n\n        Examples:\n            ```python\n            counter = Observable[int](0)\n            counter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n            # Disable notifications\n            counter.disable()\n            counter.set(1)  # No output\n\n            # Enable notifications\n            counter.enable()\n            counter.set(2)  # Prints: \"Counter changed to 2\"\n            ```\n        \"\"\"\n        print(\"DEBUG: Observable.enable called\")\n        self._on_change_enabled = True\n\n    @override\n    def disable(self) -&gt; None:\n        \"\"\"\n        Disable the observable from notifying changes.\n\n        After calling this method, subsequent calls to set() will not trigger\n        callbacks, even if notify=True.\n\n        Examples:\n            ```python\n            counter = Observable[int](0)\n            counter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n            # Disable notifications\n            counter.disable()\n            counter.set(1)  # No output\n            ```\n        \"\"\"\n        print(\"DEBUG: Observable.disable called\")\n        self._on_change_enabled = False\n\n    def __bool__(self) -&gt; bool:\n        \"\"\"\n        Convert the observable to a boolean.\n\n        This allows using the observable directly in boolean contexts.\n\n        Returns:\n            The boolean value of the current value.\n\n        Examples:\n            ```python\n            counter = Observable[int](0)\n            if not counter:\n                print(\"Counter is zero\")  # This will print\n\n            counter.set(1)\n            if counter:\n                print(\"Counter is non-zero\")  # This will print\n            ```\n        \"\"\"\n        return bool(self.get())\n\n    @override\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Convert the observable to a string.\n\n        This allows using the observable directly in string contexts.\n\n        Returns:\n            The string representation of the current value.\n\n        Examples:\n            ```python\n            counter = Observable[int](42)\n            print(f\"The counter is {counter}\")  # Prints: \"The counter is 42\"\n            ```\n        \"\"\"\n        return str(self.get())\n\n    @override\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Get the representation of the observable.\n\n        Returns:\n            A string representation of the observable, including its class name\n            and current value.\n\n        Examples:\n            ```python\n            counter = Observable[int](42)\n            repr(counter)  # Returns: \"Observable(42)\"\n            ```\n        \"\"\"\n        return f\"{self.__class__.__name__}({self.get()!r})\"\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.__bool__","title":"<code>__bool__()</code>","text":"<p>Convert the observable to a boolean.</p> <p>This allows using the observable directly in boolean contexts.</p> <p>Returns:</p> Type Description <code>bool</code> <p>The boolean value of the current value.</p> <p>Examples:</p> <pre><code>counter = Observable[int](0)\nif not counter:\n    print(\"Counter is zero\")  # This will print\n\ncounter.set(1)\nif counter:\n    print(\"Counter is non-zero\")  # This will print\n</code></pre> Source code in <code>observant\\observable.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"\n    Convert the observable to a boolean.\n\n    This allows using the observable directly in boolean contexts.\n\n    Returns:\n        The boolean value of the current value.\n\n    Examples:\n        ```python\n        counter = Observable[int](0)\n        if not counter:\n            print(\"Counter is zero\")  # This will print\n\n        counter.set(1)\n        if counter:\n            print(\"Counter is non-zero\")  # This will print\n        ```\n    \"\"\"\n    return bool(self.get())\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.__init__","title":"<code>__init__(value, *, on_change=None, on_change_enabled=True)</code>","text":"<p>Initialize the Observable with a value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The initial value of the observable.</p> required <code>on_change</code> <code>Callable[[T], None] | None</code> <p>Optional callback function to register immediately.</p> <code>None</code> <code>on_change_enabled</code> <code>bool</code> <p>Whether callbacks should be enabled initially.</p> <code>True</code> Source code in <code>observant\\observable.py</code> <pre><code>def __init__(self, value: T, *, on_change: Callable[[T], None] | None = None, on_change_enabled: bool = True) -&gt; None:\n    \"\"\"\n    Initialize the Observable with a value.\n\n    Args:\n        value: The initial value of the observable.\n        on_change: Optional callback function to register immediately.\n        on_change_enabled: Whether callbacks should be enabled initially.\n    \"\"\"\n    print(f\"DEBUG: Observable.__init__ called with value {value}\")\n    self._value = value\n    self._callbacks = []\n    self._on_change_enabled = on_change_enabled\n    print(\"DEBUG: Observable.__init__ - Initialized with empty callbacks list\")\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.__repr__","title":"<code>__repr__()</code>","text":"<p>Get the representation of the observable.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the observable, including its class name</p> <code>str</code> <p>and current value.</p> <p>Examples:</p> <pre><code>counter = Observable[int](42)\nrepr(counter)  # Returns: \"Observable(42)\"\n</code></pre> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef __repr__(self) -&gt; str:\n    \"\"\"\n    Get the representation of the observable.\n\n    Returns:\n        A string representation of the observable, including its class name\n        and current value.\n\n    Examples:\n        ```python\n        counter = Observable[int](42)\n        repr(counter)  # Returns: \"Observable(42)\"\n        ```\n    \"\"\"\n    return f\"{self.__class__.__name__}({self.get()!r})\"\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.__str__","title":"<code>__str__()</code>","text":"<p>Convert the observable to a string.</p> <p>This allows using the observable directly in string contexts.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the current value.</p> <p>Examples:</p> <pre><code>counter = Observable[int](42)\nprint(f\"The counter is {counter}\")  # Prints: \"The counter is 42\"\n</code></pre> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef __str__(self) -&gt; str:\n    \"\"\"\n    Convert the observable to a string.\n\n    This allows using the observable directly in string contexts.\n\n    Returns:\n        The string representation of the current value.\n\n    Examples:\n        ```python\n        counter = Observable[int](42)\n        print(f\"The counter is {counter}\")  # Prints: \"The counter is 42\"\n        ```\n    \"\"\"\n    return str(self.get())\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.disable","title":"<code>disable()</code>","text":"<p>Disable the observable from notifying changes.</p> <p>After calling this method, subsequent calls to set() will not trigger callbacks, even if notify=True.</p> <p>Examples:</p> <pre><code>counter = Observable[int](0)\ncounter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n# Disable notifications\ncounter.disable()\ncounter.set(1)  # No output\n</code></pre> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef disable(self) -&gt; None:\n    \"\"\"\n    Disable the observable from notifying changes.\n\n    After calling this method, subsequent calls to set() will not trigger\n    callbacks, even if notify=True.\n\n    Examples:\n        ```python\n        counter = Observable[int](0)\n        counter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n        # Disable notifications\n        counter.disable()\n        counter.set(1)  # No output\n        ```\n    \"\"\"\n    print(\"DEBUG: Observable.disable called\")\n    self._on_change_enabled = False\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.enable","title":"<code>enable()</code>","text":"<p>Enable the observable to notify changes.</p> <p>After calling this method, subsequent calls to set() with notify=True will trigger callbacks.</p> <p>Examples:</p> <pre><code>counter = Observable[int](0)\ncounter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n# Disable notifications\ncounter.disable()\ncounter.set(1)  # No output\n\n# Enable notifications\ncounter.enable()\ncounter.set(2)  # Prints: \"Counter changed to 2\"\n</code></pre> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef enable(self) -&gt; None:\n    \"\"\"\n    Enable the observable to notify changes.\n\n    After calling this method, subsequent calls to set() with notify=True\n    will trigger callbacks.\n\n    Examples:\n        ```python\n        counter = Observable[int](0)\n        counter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n        # Disable notifications\n        counter.disable()\n        counter.set(1)  # No output\n\n        # Enable notifications\n        counter.enable()\n        counter.set(2)  # Prints: \"Counter changed to 2\"\n        ```\n    \"\"\"\n    print(\"DEBUG: Observable.enable called\")\n    self._on_change_enabled = True\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.get","title":"<code>get()</code>","text":"<p>Get the current value of the observable.</p> <p>Returns:</p> Type Description <code>T</code> <p>The current value stored in this observable.</p> <p>Examples:</p> <pre><code>counter = Observable[int](0)\nvalue = counter.get()  # Returns: 0\n</code></pre> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef get(self) -&gt; T:\n    \"\"\"\n    Get the current value of the observable.\n\n    Returns:\n        The current value stored in this observable.\n\n    Examples:\n        ```python\n        counter = Observable[int](0)\n        value = counter.get()  # Returns: 0\n        ```\n    \"\"\"\n    return self._value\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.on_change","title":"<code>on_change(callback)</code>","text":"<p>Register a callback function to be called when the value changes.</p> <p>The callback will be called with the new value whenever set() is called with notify=True and callbacks are enabled. Callbacks are called in the order they were registered.</p> <p>If the same callback function is registered multiple times, it will only be added once.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[T], None]</code> <p>A function that takes the new value as its argument.</p> required <p>Examples:</p> <pre><code>counter = Observable[int](0)\n\n# Register a callback\ncounter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n# Register another callback\ncounter.on_change(lambda value: print(f\"Counter is now {value}\"))\n\n# Update the value\ncounter.set(1)\n# Prints:\n# \"Counter changed to 1\"\n# \"Counter is now 1\"\n</code></pre> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef on_change(self, callback: Callable[[T], None]) -&gt; None:\n    \"\"\"\n    Register a callback function to be called when the value changes.\n\n    The callback will be called with the new value whenever set() is called\n    with notify=True and callbacks are enabled. Callbacks are called in the\n    order they were registered.\n\n    If the same callback function is registered multiple times, it will only\n    be added once.\n\n    Args:\n        callback: A function that takes the new value as its argument.\n\n    Examples:\n        ```python\n        counter = Observable[int](0)\n\n        # Register a callback\n        counter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n        # Register another callback\n        counter.on_change(lambda value: print(f\"Counter is now {value}\"))\n\n        # Update the value\n        counter.set(1)\n        # Prints:\n        # \"Counter changed to 1\"\n        # \"Counter is now 1\"\n        ```\n    \"\"\"\n    print(f\"DEBUG: Observable.on_change called, current callbacks: {len(self._callbacks)}\")\n    # Check if this callback is already registered to avoid duplicates\n    for existing_cb in self._callbacks:\n        if existing_cb == callback:\n            print(\"DEBUG: Observable.on_change - Callback already registered, skipping\")\n            return\n\n    self._callbacks.append(callback)\n    print(f\"DEBUG: Observable.on_change - Added callback, now have {len(self._callbacks)} callbacks\")\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.set","title":"<code>set(value, notify=True)</code>","text":"<p>Set a new value for the observable and notify all registered callbacks.</p> <p>This method updates the internal value and, if notify is True and callbacks are enabled, calls all registered callbacks with the new value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The new value to set.</p> required <code>notify</code> <code>bool</code> <p>Whether to notify the callbacks after setting the value.</p> <code>True</code> <p>Examples:</p> <pre><code>counter = Observable[int](0)\ncounter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n# Update with notification\ncounter.set(1)  # Prints: \"Counter changed to 1\"\n\n# Update without notification\ncounter.set(2, notify=False)  # No output\n</code></pre> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef set(self, value: T, notify: bool = True) -&gt; None:\n    \"\"\"\n    Set a new value for the observable and notify all registered callbacks.\n\n    This method updates the internal value and, if notify is True and callbacks\n    are enabled, calls all registered callbacks with the new value.\n\n    Args:\n        value: The new value to set.\n        notify: Whether to notify the callbacks after setting the value.\n\n    Examples:\n        ```python\n        counter = Observable[int](0)\n        counter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n        # Update with notification\n        counter.set(1)  # Prints: \"Counter changed to 1\"\n\n        # Update without notification\n        counter.set(2, notify=False)  # No output\n        ```\n    \"\"\"\n    print(f\"DEBUG: Observable.set called with value {value}\")\n    self._value = value\n\n    if not notify or not self._on_change_enabled:\n        print(\"DEBUG: Observable.set - on_change is disabled, skipping callbacks\")\n        return\n\n    print(f\"DEBUG: Observable.set - Notifying {len(self._callbacks)} callbacks\")\n    for i, callback in enumerate(self._callbacks):\n        print(f\"DEBUG: Observable.set - Calling callback {i}\")\n        callback(value)\n        print(f\"DEBUG: Observable.set - Callback {i} completed\")\n    print(\"DEBUG: Observable.set - Completed\")\n</code></pre>"},{"location":"api_reference/observable_dict/","title":"ObservableDict","text":""},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict","title":"<code>observant.observable_dict.ObservableDict</code>","text":"<p>               Bases: <code>Generic[TKey, TValue]</code>, <code>IObservableDict[TKey, TValue]</code></p> <p>An observable implementation of Python's dictionary that notifies listeners of changes.</p> <p>ObservableDict wraps a Python dictionary and provides the same interface, but with additional notification capabilities. It can either create its own internal dictionary or work with an existing one.</p> <p>When the dictionary is modified (items added, removed, updated, etc.), registered callbacks are notified with details about the change. This allows other components to react to changes in the dictionary.</p> <p>Attributes:</p> Name Type Description <code>_items</code> <code>dict[TKey, TValue]</code> <p>The internal dictionary being observed.</p> <code>_change_callbacks</code> <code>list[Callable[[ObservableDictChange[TKey, TValue]], None]]</code> <p>Callbacks for all types of changes.</p> <code>_add_callbacks</code> <code>list[Callable[[TKey, TValue], None]]</code> <p>Callbacks specifically for add operations.</p> <code>_remove_callbacks</code> <code>list[Callable[[TKey, TValue], None]]</code> <p>Callbacks specifically for remove operations.</p> <code>_update_callbacks</code> <code>list[Callable[[TKey, TValue], None]]</code> <p>Callbacks specifically for update operations.</p> <code>_clear_callbacks</code> <code>list[Callable[[dict[TKey, TValue]], None]]</code> <p>Callbacks specifically for clear operations.</p> <p>Examples:</p> <pre><code># Create an empty observable dictionary\nsettings = ObservableDict[str, int]()\n\n# Create with initial items\nuser_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n\n# Register a callback for all changes\nuser_data.on_change(lambda change: print(f\"Change: {change.type}\"))\n\n# Register a callback for adds\nuser_data.on_add(lambda key, value: print(f\"Added {key}: {value}\"))\n\n# Modify the dictionary\nuser_data[\"phone\"] = \"555-1234\"  # Triggers callbacks\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>class ObservableDict(Generic[TKey, TValue], IObservableDict[TKey, TValue]):\n    \"\"\"\n    An observable implementation of Python's dictionary that notifies listeners of changes.\n\n    ObservableDict wraps a Python dictionary and provides the same interface, but with\n    additional notification capabilities. It can either create its own internal\n    dictionary or work with an existing one.\n\n    When the dictionary is modified (items added, removed, updated, etc.), registered\n    callbacks are notified with details about the change. This allows other components\n    to react to changes in the dictionary.\n\n    Attributes:\n        _items: The internal dictionary being observed.\n        _change_callbacks: Callbacks for all types of changes.\n        _add_callbacks: Callbacks specifically for add operations.\n        _remove_callbacks: Callbacks specifically for remove operations.\n        _update_callbacks: Callbacks specifically for update operations.\n        _clear_callbacks: Callbacks specifically for clear operations.\n\n    Examples:\n        ```python\n        # Create an empty observable dictionary\n        settings = ObservableDict[str, int]()\n\n        # Create with initial items\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n\n        # Register a callback for all changes\n        user_data.on_change(lambda change: print(f\"Change: {change.type}\"))\n\n        # Register a callback for adds\n        user_data.on_add(lambda key, value: print(f\"Added {key}: {value}\"))\n\n        # Modify the dictionary\n        user_data[\"phone\"] = \"555-1234\"  # Triggers callbacks\n        ```\n    \"\"\"\n\n    def __init__(self, items: dict[TKey, TValue] | None = None, *, copy: bool = False) -&gt; None:\n        \"\"\"\n        Initialize with optional external dict reference.\n\n        Args:\n            items: Optional external dict to observe. If None, creates a new dict.\n            copy: If True, creates a copy of the provided dict instead of using it directly.\n                This is useful when you want to avoid modifying the original dict.\n\n        Examples:\n            ```python\n            # Create an empty observable dictionary\n            empty_dict = ObservableDict[str, int]()\n\n            # Create with initial items\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n\n            # Create with a copy of initial items\n            original = {\"red\": \"#FF0000\", \"green\": \"#00FF00\"}\n            colors = ObservableDict[str, str](original, copy=True)\n            colors[\"blue\"] = \"#0000FF\"  # original dict is not modified\n            ```\n        \"\"\"\n        if copy:\n            self._items: dict[TKey, TValue] = dict(items) if items is not None else {}\n        else:\n            self._items = items if items is not None else {}\n        self._change_callbacks: list[Callable[[ObservableDictChange[TKey, TValue]], None]] = []\n        self._add_callbacks: list[Callable[[TKey, TValue], None]] = []\n        self._remove_callbacks: list[Callable[[TKey, TValue], None]] = []\n        self._update_callbacks: list[Callable[[TKey, TValue], None]] = []\n        self._clear_callbacks: list[Callable[[dict[TKey, TValue]], None]] = []\n\n    @override\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Return the number of items in the dictionary.\n\n        Returns:\n            The number of items in the dictionary.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n            length = len(user_data)  # Returns: 2\n            ```\n        \"\"\"\n        return len(self._items)\n\n    @override\n    def __getitem__(self, key: TKey) -&gt; TValue:\n        \"\"\"\n        Get an item from the dictionary.\n\n        Args:\n            key: The key to look up.\n\n        Returns:\n            The value for the key.\n\n        Raises:\n            KeyError: If the key is not found.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n            name = user_data[\"name\"]  # Returns: \"Alice\"\n            ```\n        \"\"\"\n        return self._items[key]\n\n    @override\n    def __setitem__(self, key: TKey, value: TValue) -&gt; None:\n        \"\"\"\n        Set an item in the dictionary.\n\n        This method notifies callbacks about the added or updated item.\n        If the key already exists, an update notification is sent.\n        If the key is new, an add notification is sent.\n\n        Args:\n            key: The key to set.\n            value: The value to set.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\n            user_data[\"email\"] = \"alice@example.com\"  # Triggers add callbacks\n            user_data[\"name\"] = \"Alicia\"  # Triggers update callbacks\n            ```\n        \"\"\"\n        if key in self._items:\n            self._items[key] = value\n            self._notify_update(key, value)\n        else:\n            self._items[key] = value\n            self._notify_add(key, value)\n\n    @override\n    def __delitem__(self, key: TKey) -&gt; None:\n        \"\"\"\n        Delete an item from the dictionary.\n\n        This method notifies callbacks about the removed item.\n\n        Args:\n            key: The key to delete.\n\n        Raises:\n            KeyError: If the key is not found.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n            del user_data[\"email\"]  # Triggers remove callbacks\n            ```\n        \"\"\"\n        value = self._items[key]\n        del self._items[key]\n        self._notify_remove(key, value)\n\n    @override\n    def __iter__(self) -&gt; Iterator[TKey]:\n        \"\"\"\n        Return an iterator over the keys in the dictionary.\n\n        Returns:\n            An iterator over the keys in the dictionary.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n            for key in user_data:\n                print(key)  # Prints: \"name\", \"email\"\n            ```\n        \"\"\"\n        return iter(self._items)\n\n    @override\n    def __contains__(self, key: TKey) -&gt; bool:\n        \"\"\"\n        Check if a key is in the dictionary.\n\n        Args:\n            key: The key to check for.\n\n        Returns:\n            True if the key is in the dictionary, False otherwise.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n            if \"name\" in user_data:\n                print(\"Name is present\")\n            ```\n        \"\"\"\n        return key in self._items\n\n    @override\n    def get(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"\n        Return the value for a key if it exists, otherwise return a default value.\n\n        This method does not modify the dictionary or trigger any callbacks.\n\n        Args:\n            key: The key to look up.\n            default: The default value to return if the key is not found.\n\n        Returns:\n            The value for the key, or the default value.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\n            email = user_data.get(\"email\", \"No email\")  # Returns: \"No email\"\n            name = user_data.get(\"name\", \"Unknown\")  # Returns: \"Alice\"\n            ```\n        \"\"\"\n        return self._items.get(key, default)\n\n    @override\n    def setdefault(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"\n        Return the value for a key if it exists, otherwise set and return the default value.\n\n        If the key does not exist, this method adds it with the default value and\n        triggers add callbacks.\n\n        Args:\n            key: The key to look up.\n            default: The default value to set and return if the key is not found.\n\n        Returns:\n            The value for the key, or the default value.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\n            email = user_data.setdefault(\"email\", \"alice@example.com\")  # Returns: \"alice@example.com\" and adds it\n            name = user_data.setdefault(\"name\", \"Unknown\")  # Returns: \"Alice\" without changing it\n            ```\n        \"\"\"\n        if key not in self._items:\n            self._items[key] = cast(TValue, default)  # Cast to V since we know it's a value\n            self._notify_add(key, cast(TValue, default))\n            return default\n        return self._items[key]\n\n    @override\n    def pop(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"\n        Remove and return the value for a key if it exists, otherwise return a default value.\n\n        If the key exists, this method removes it and triggers remove callbacks.\n        If the key does not exist and a default is provided, no callbacks are triggered.\n\n        Args:\n            key: The key to look up.\n            default: The default value to return if the key is not found.\n\n        Returns:\n            The value for the key, or the default value.\n\n        Raises:\n            KeyError: If the key is not found and no default value is provided.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n            email = user_data.pop(\"email\")  # Returns: \"alice@example.com\" and removes it\n            phone = user_data.pop(\"phone\", \"No phone\")  # Returns: \"No phone\" without modifying the dict\n            ```\n        \"\"\"\n        if key in self._items:\n            value = self._items.pop(key)\n            self._notify_remove(key, value)\n            return value\n        if default is not None:\n            return default\n        raise KeyError(key)\n\n    @override\n    def popitem(self) -&gt; tuple[TKey, TValue]:\n        \"\"\"\n        Remove and return a (key, value) pair from the dictionary.\n\n        This method removes an arbitrary (key, value) pair and triggers remove callbacks.\n        In Python 3.7+, the pairs are returned in LIFO order (last inserted, first returned).\n\n        Returns:\n            A (key, value) pair.\n\n        Raises:\n            KeyError: If the dictionary is empty.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n            key, value = user_data.popitem()  # Might return: (\"email\", \"alice@example.com\")\n            ```\n        \"\"\"\n        key, value = self._items.popitem()\n        self._notify_remove(key, value)\n        return key, value\n\n    @override\n    def clear(self) -&gt; None:\n        \"\"\"\n        Remove all items from the dictionary.\n\n        This method notifies callbacks about the cleared items.\n        If the dictionary is already empty, no notifications are sent.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n            user_data.clear()  # Dictionary becomes {}\n            ```\n        \"\"\"\n        if not self._items:\n            return\n        items = self._items.copy()\n        self._items.clear()\n        self._notify_clear(items)\n\n    @override\n    def update(self, other: dict[TKey, TValue]) -&gt; None:\n        \"\"\"\n        Update the dictionary with the key/value pairs from another dictionary.\n\n        This method notifies callbacks about added and updated items.\n        For each key in the other dictionary:\n        - If the key already exists, an update notification is sent.\n        - If the key is new, an add notification is sent.\n        If the other dictionary is empty, no notifications are sent.\n\n        Args:\n            other: Another dictionary to update from.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\n            user_data.update({\"email\": \"alice@example.com\", \"name\": \"Alicia\"})\n            # Dictionary becomes {\"name\": \"Alicia\", \"email\": \"alice@example.com\"}\n            ```\n        \"\"\"\n        if not other:\n            return\n        added_items: dict[TKey, TValue] = {}\n        updated_items: dict[TKey, TValue] = {}\n        for key, value in other.items():\n            if key in self._items:\n                updated_items[key] = value\n            else:\n                added_items[key] = value\n        self._items.update(other)\n\n        # Notify for added items\n        if added_items:\n            for key, value in added_items.items():\n                self._notify_add(key, value)\n\n        # Notify for updated items\n        if updated_items:\n            for key, value in updated_items.items():\n                self._notify_update(key, value)\n\n    @override\n    def keys(self) -&gt; list[TKey]:\n        \"\"\"\n        Return a list of all keys in the dictionary.\n\n        This method does not modify the dictionary or trigger any callbacks.\n\n        Returns:\n            A list of keys.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n            keys = user_data.keys()  # Returns: [\"name\", \"email\"]\n            ```\n        \"\"\"\n        return list(self._items.keys())\n\n    @override\n    def values(self) -&gt; list[TValue]:\n        \"\"\"\n        Return a list of all values in the dictionary.\n\n        This method does not modify the dictionary or trigger any callbacks.\n\n        Returns:\n            A list of values.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n            values = user_data.values()  # Returns: [\"Alice\", \"alice@example.com\"]\n            ```\n        \"\"\"\n        return list(self._items.values())\n\n    @override\n    def items(self) -&gt; list[tuple[TKey, TValue]]:\n        \"\"\"\n        Return a list of all (key, value) pairs in the dictionary.\n\n        This method does not modify the dictionary or trigger any callbacks.\n\n        Returns:\n            A list of (key, value) pairs.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n            items = user_data.items()  # Returns: [(\"name\", \"Alice\"), (\"email\", \"alice@example.com\")]\n            ```\n        \"\"\"\n        return list(self._items.items())\n\n    @override\n    def copy(self) -&gt; dict[TKey, TValue]:\n        \"\"\"\n        Return a shallow copy of the dictionary.\n\n        This method returns a regular Python dictionary, not an ObservableDict.\n        It does not modify the dictionary or trigger any callbacks.\n\n        Returns:\n            A shallow copy of the dictionary as a regular Python dictionary.\n\n        Examples:\n            ```python\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n            copy = user_data.copy()  # Returns: {\"name\": \"Alice\", \"email\": \"alice@example.com\"} as a regular dict\n            ```\n        \"\"\"\n        return self._items.copy()\n\n    @override\n    def on_change(self, callback: Callable[[ObservableDictChange[TKey, TValue]], None]) -&gt; None:\n        \"\"\"\n        Add a callback to be called when the dictionary changes.\n\n        The callback will be called with an ObservableDictChange object that contains\n        information about the type of change (add, remove, update, clear) and the affected items.\n\n        Args:\n            callback: A function that takes an ObservableDictChange object.\n\n        Examples:\n            ```python\n            def on_dict_change(change):\n                print(f\"Change type: {change.type}\")\n                if change.type == ObservableCollectionChangeType.ADD:\n                    print(f\"Added key: {change.key}, value: {change.value}\")\n                elif change.type == ObservableCollectionChangeType.UPDATE:\n                    print(f\"Updated key: {change.key}, new value: {change.value}\")\n\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\n            user_data.on_change(on_dict_change)\n            user_data[\"email\"] = \"alice@example.com\"  # Triggers the callback\n            ```\n        \"\"\"\n        self._change_callbacks.append(callback)\n\n    @override\n    def on_add(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"\n        Register for add events with key and value.\n\n        This is a more specific alternative to on_change that only triggers\n        for add operations and provides a simpler callback signature.\n\n        Args:\n            callback: A function that takes a key and value.\n\n        Examples:\n            ```python\n            def on_item_added(key, value):\n                print(f\"Added {key}: {value}\")\n\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\n            user_data.on_add(on_item_added)\n            user_data[\"email\"] = \"alice@example.com\"  # Triggers the callback with (\"email\", \"alice@example.com\")\n            ```\n        \"\"\"\n        self._add_callbacks.append(callback)\n\n    @override\n    def on_remove(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"\n        Register for remove events with key and value.\n\n        This is a more specific alternative to on_change that only triggers\n        for remove operations and provides a simpler callback signature.\n\n        Args:\n            callback: A function that takes a key and value.\n\n        Examples:\n            ```python\n            def on_item_removed(key, value):\n                print(f\"Removed {key}: {value}\")\n\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n            user_data.on_remove(on_item_removed)\n            del user_data[\"email\"]  # Triggers the callback with (\"email\", \"alice@example.com\")\n            ```\n        \"\"\"\n        self._remove_callbacks.append(callback)\n\n    @override\n    def on_update(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"\n        Register for update events with key and new value.\n\n        This is a more specific alternative to on_change that only triggers\n        for update operations and provides a simpler callback signature.\n\n        Args:\n            callback: A function that takes a key and new value.\n\n        Examples:\n            ```python\n            def on_item_updated(key, value):\n                print(f\"Updated {key} to {value}\")\n\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\n            user_data.on_update(on_item_updated)\n            user_data[\"name\"] = \"Alicia\"  # Triggers the callback with (\"name\", \"Alicia\")\n            ```\n        \"\"\"\n        self._update_callbacks.append(callback)\n\n    @override\n    def on_clear(self, callback: Callable[[dict[TKey, TValue]], None]) -&gt; None:\n        \"\"\"\n        Register for clear events with the cleared items.\n\n        This is a more specific alternative to on_change that only triggers\n        for clear operations and provides a simpler callback signature.\n\n        Args:\n            callback: A function that takes a dict of cleared items.\n\n        Examples:\n            ```python\n            def on_dict_cleared(items):\n                print(f\"Cleared {len(items)} items: {items}\")\n\n            user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n            user_data.on_clear(on_dict_cleared)\n            user_data.clear()  # Triggers the callback with {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\n            ```\n        \"\"\"\n        self._clear_callbacks.append(callback)\n\n    def _notify_add(self, key: TKey, value: TValue) -&gt; None:\n        \"\"\"\n        Notify all callbacks of an item being added.\n\n        This internal method is called by methods that add items to the dictionary.\n        It notifies both specific add callbacks and general change callbacks.\n\n        Args:\n            key: The key that was added.\n            value: The value that was added.\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._add_callbacks:\n            callback(key, value)\n\n        # Create a dictionary with the single item for the items field\n        items_dict = {key: value}\n\n        # Call general change callbacks\n        change = ObservableDictChange(\n            type=ObservableCollectionChangeType.ADD,\n            key=key,\n            value=value,\n            items=items_dict,\n        )\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_remove(self, key: TKey, value: TValue) -&gt; None:\n        \"\"\"\n        Notify all callbacks of an item being removed.\n\n        This internal method is called by methods that remove items from the dictionary.\n        It notifies both specific remove callbacks and general change callbacks.\n\n        Args:\n            key: The key that was removed.\n            value: The value that was removed.\n        \"\"\"\n        print(f\"DEBUG: ObservableDict._notify_remove called with key={key}, value={value}\")\n\n        # Call specific callbacks\n        for callback in self._remove_callbacks:\n            callback(key, value)\n\n        # Create a dictionary with the single item for the items field\n        items_dict = {key: value}\n\n        # Call general change callbacks\n        change = ObservableDictChange(\n            type=ObservableCollectionChangeType.REMOVE,\n            key=key,\n            value=value,\n            items=items_dict,\n        )\n        print(f\"DEBUG: ObservableDict._notify_remove - Created change object: type={change.type}, key={change.key}, value={change.value}\")\n        for callback in self._change_callbacks:\n            callback(change)\n        print(\"DEBUG: ObservableDict._notify_remove - Completed\")\n\n    def _notify_update(self, key: TKey, value: TValue) -&gt; None:\n        \"\"\"\n        Notify all callbacks of an item being updated.\n\n        This internal method is called by methods that update items in the dictionary.\n        It notifies both specific update callbacks and general change callbacks.\n\n        Args:\n            key: The key that was updated.\n            value: The new value.\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._update_callbacks:\n            callback(key, value)\n\n        # Create a dictionary with the single item for the items field\n        items_dict = {key: value}\n\n        # Call general change callbacks\n        change = ObservableDictChange(\n            type=ObservableCollectionChangeType.UPDATE,\n            key=key,\n            value=value,\n            items=items_dict,\n        )\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_clear(self, items: dict[TKey, TValue]) -&gt; None:\n        \"\"\"\n        Notify all callbacks of the dictionary being cleared.\n\n        This internal method is called by the clear method.\n        It notifies both specific clear callbacks and general change callbacks.\n\n        Args:\n            items: The items that were cleared.\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._clear_callbacks:\n            callback(items)\n\n        # Call general change callbacks\n        change = ObservableDictChange(type=ObservableCollectionChangeType.CLEAR, items=items)\n        for callback in self._change_callbacks:\n            callback(change)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Check if a key is in the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TKey</code> <p>The key to check for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the key is in the dictionary, False otherwise.</p> <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\nif \"name\" in user_data:\n    print(\"Name is present\")\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __contains__(self, key: TKey) -&gt; bool:\n    \"\"\"\n    Check if a key is in the dictionary.\n\n    Args:\n        key: The key to check for.\n\n    Returns:\n        True if the key is in the dictionary, False otherwise.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n        if \"name\" in user_data:\n            print(\"Name is present\")\n        ```\n    \"\"\"\n    return key in self._items\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Delete an item from the dictionary.</p> <p>This method notifies callbacks about the removed item.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TKey</code> <p>The key to delete.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found.</p> <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\ndel user_data[\"email\"]  # Triggers remove callbacks\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __delitem__(self, key: TKey) -&gt; None:\n    \"\"\"\n    Delete an item from the dictionary.\n\n    This method notifies callbacks about the removed item.\n\n    Args:\n        key: The key to delete.\n\n    Raises:\n        KeyError: If the key is not found.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n        del user_data[\"email\"]  # Triggers remove callbacks\n        ```\n    \"\"\"\n    value = self._items[key]\n    del self._items[key]\n    self._notify_remove(key, value)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get an item from the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TKey</code> <p>The key to look up.</p> required <p>Returns:</p> Type Description <code>TValue</code> <p>The value for the key.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found.</p> <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\nname = user_data[\"name\"]  # Returns: \"Alice\"\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __getitem__(self, key: TKey) -&gt; TValue:\n    \"\"\"\n    Get an item from the dictionary.\n\n    Args:\n        key: The key to look up.\n\n    Returns:\n        The value for the key.\n\n    Raises:\n        KeyError: If the key is not found.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n        name = user_data[\"name\"]  # Returns: \"Alice\"\n        ```\n    \"\"\"\n    return self._items[key]\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__init__","title":"<code>__init__(items=None, *, copy=False)</code>","text":"<p>Initialize with optional external dict reference.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>dict[TKey, TValue] | None</code> <p>Optional external dict to observe. If None, creates a new dict.</p> <code>None</code> <code>copy</code> <code>bool</code> <p>If True, creates a copy of the provided dict instead of using it directly. This is useful when you want to avoid modifying the original dict.</p> <code>False</code> <p>Examples:</p> <pre><code># Create an empty observable dictionary\nempty_dict = ObservableDict[str, int]()\n\n# Create with initial items\nuser_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n\n# Create with a copy of initial items\noriginal = {\"red\": \"#FF0000\", \"green\": \"#00FF00\"}\ncolors = ObservableDict[str, str](original, copy=True)\ncolors[\"blue\"] = \"#0000FF\"  # original dict is not modified\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>def __init__(self, items: dict[TKey, TValue] | None = None, *, copy: bool = False) -&gt; None:\n    \"\"\"\n    Initialize with optional external dict reference.\n\n    Args:\n        items: Optional external dict to observe. If None, creates a new dict.\n        copy: If True, creates a copy of the provided dict instead of using it directly.\n            This is useful when you want to avoid modifying the original dict.\n\n    Examples:\n        ```python\n        # Create an empty observable dictionary\n        empty_dict = ObservableDict[str, int]()\n\n        # Create with initial items\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n\n        # Create with a copy of initial items\n        original = {\"red\": \"#FF0000\", \"green\": \"#00FF00\"}\n        colors = ObservableDict[str, str](original, copy=True)\n        colors[\"blue\"] = \"#0000FF\"  # original dict is not modified\n        ```\n    \"\"\"\n    if copy:\n        self._items: dict[TKey, TValue] = dict(items) if items is not None else {}\n    else:\n        self._items = items if items is not None else {}\n    self._change_callbacks: list[Callable[[ObservableDictChange[TKey, TValue]], None]] = []\n    self._add_callbacks: list[Callable[[TKey, TValue], None]] = []\n    self._remove_callbacks: list[Callable[[TKey, TValue], None]] = []\n    self._update_callbacks: list[Callable[[TKey, TValue], None]] = []\n    self._clear_callbacks: list[Callable[[dict[TKey, TValue]], None]] = []\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the keys in the dictionary.</p> <p>Returns:</p> Type Description <code>Iterator[TKey]</code> <p>An iterator over the keys in the dictionary.</p> <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\nfor key in user_data:\n    print(key)  # Prints: \"name\", \"email\"\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __iter__(self) -&gt; Iterator[TKey]:\n    \"\"\"\n    Return an iterator over the keys in the dictionary.\n\n    Returns:\n        An iterator over the keys in the dictionary.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n        for key in user_data:\n            print(key)  # Prints: \"name\", \"email\"\n        ```\n    \"\"\"\n    return iter(self._items)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of items in the dictionary.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of items in the dictionary.</p> <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\nlength = len(user_data)  # Returns: 2\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __len__(self) -&gt; int:\n    \"\"\"\n    Return the number of items in the dictionary.\n\n    Returns:\n        The number of items in the dictionary.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n        length = len(user_data)  # Returns: 2\n        ```\n    \"\"\"\n    return len(self._items)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set an item in the dictionary.</p> <p>This method notifies callbacks about the added or updated item. If the key already exists, an update notification is sent. If the key is new, an add notification is sent.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TKey</code> <p>The key to set.</p> required <code>value</code> <code>TValue</code> <p>The value to set.</p> required <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\nuser_data[\"email\"] = \"alice@example.com\"  # Triggers add callbacks\nuser_data[\"name\"] = \"Alicia\"  # Triggers update callbacks\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __setitem__(self, key: TKey, value: TValue) -&gt; None:\n    \"\"\"\n    Set an item in the dictionary.\n\n    This method notifies callbacks about the added or updated item.\n    If the key already exists, an update notification is sent.\n    If the key is new, an add notification is sent.\n\n    Args:\n        key: The key to set.\n        value: The value to set.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\n        user_data[\"email\"] = \"alice@example.com\"  # Triggers add callbacks\n        user_data[\"name\"] = \"Alicia\"  # Triggers update callbacks\n        ```\n    \"\"\"\n    if key in self._items:\n        self._items[key] = value\n        self._notify_update(key, value)\n    else:\n        self._items[key] = value\n        self._notify_add(key, value)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.clear","title":"<code>clear()</code>","text":"<p>Remove all items from the dictionary.</p> <p>This method notifies callbacks about the cleared items. If the dictionary is already empty, no notifications are sent.</p> <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\nuser_data.clear()  # Dictionary becomes {}\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef clear(self) -&gt; None:\n    \"\"\"\n    Remove all items from the dictionary.\n\n    This method notifies callbacks about the cleared items.\n    If the dictionary is already empty, no notifications are sent.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n        user_data.clear()  # Dictionary becomes {}\n        ```\n    \"\"\"\n    if not self._items:\n        return\n    items = self._items.copy()\n    self._items.clear()\n    self._notify_clear(items)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.copy","title":"<code>copy()</code>","text":"<p>Return a shallow copy of the dictionary.</p> <p>This method returns a regular Python dictionary, not an ObservableDict. It does not modify the dictionary or trigger any callbacks.</p> <p>Returns:</p> Type Description <code>dict[TKey, TValue]</code> <p>A shallow copy of the dictionary as a regular Python dictionary.</p> <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\ncopy = user_data.copy()  # Returns: {\"name\": \"Alice\", \"email\": \"alice@example.com\"} as a regular dict\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef copy(self) -&gt; dict[TKey, TValue]:\n    \"\"\"\n    Return a shallow copy of the dictionary.\n\n    This method returns a regular Python dictionary, not an ObservableDict.\n    It does not modify the dictionary or trigger any callbacks.\n\n    Returns:\n        A shallow copy of the dictionary as a regular Python dictionary.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n        copy = user_data.copy()  # Returns: {\"name\": \"Alice\", \"email\": \"alice@example.com\"} as a regular dict\n        ```\n    \"\"\"\n    return self._items.copy()\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.get","title":"<code>get(key, default=None)</code>","text":"<p>Return the value for a key if it exists, otherwise return a default value.</p> <p>This method does not modify the dictionary or trigger any callbacks.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TKey</code> <p>The key to look up.</p> required <code>default</code> <code>TValue | None</code> <p>The default value to return if the key is not found.</p> <code>None</code> <p>Returns:</p> Type Description <code>TValue | None</code> <p>The value for the key, or the default value.</p> <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\nemail = user_data.get(\"email\", \"No email\")  # Returns: \"No email\"\nname = user_data.get(\"name\", \"Unknown\")  # Returns: \"Alice\"\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef get(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"\n    Return the value for a key if it exists, otherwise return a default value.\n\n    This method does not modify the dictionary or trigger any callbacks.\n\n    Args:\n        key: The key to look up.\n        default: The default value to return if the key is not found.\n\n    Returns:\n        The value for the key, or the default value.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\n        email = user_data.get(\"email\", \"No email\")  # Returns: \"No email\"\n        name = user_data.get(\"name\", \"Unknown\")  # Returns: \"Alice\"\n        ```\n    \"\"\"\n    return self._items.get(key, default)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.items","title":"<code>items()</code>","text":"<p>Return a list of all (key, value) pairs in the dictionary.</p> <p>This method does not modify the dictionary or trigger any callbacks.</p> <p>Returns:</p> Type Description <code>list[tuple[TKey, TValue]]</code> <p>A list of (key, value) pairs.</p> <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\nitems = user_data.items()  # Returns: [(\"name\", \"Alice\"), (\"email\", \"alice@example.com\")]\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef items(self) -&gt; list[tuple[TKey, TValue]]:\n    \"\"\"\n    Return a list of all (key, value) pairs in the dictionary.\n\n    This method does not modify the dictionary or trigger any callbacks.\n\n    Returns:\n        A list of (key, value) pairs.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n        items = user_data.items()  # Returns: [(\"name\", \"Alice\"), (\"email\", \"alice@example.com\")]\n        ```\n    \"\"\"\n    return list(self._items.items())\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.keys","title":"<code>keys()</code>","text":"<p>Return a list of all keys in the dictionary.</p> <p>This method does not modify the dictionary or trigger any callbacks.</p> <p>Returns:</p> Type Description <code>list[TKey]</code> <p>A list of keys.</p> <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\nkeys = user_data.keys()  # Returns: [\"name\", \"email\"]\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef keys(self) -&gt; list[TKey]:\n    \"\"\"\n    Return a list of all keys in the dictionary.\n\n    This method does not modify the dictionary or trigger any callbacks.\n\n    Returns:\n        A list of keys.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n        keys = user_data.keys()  # Returns: [\"name\", \"email\"]\n        ```\n    \"\"\"\n    return list(self._items.keys())\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.on_add","title":"<code>on_add(callback)</code>","text":"<p>Register for add events with key and value.</p> <p>This is a more specific alternative to on_change that only triggers for add operations and provides a simpler callback signature.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[TKey, TValue], None]</code> <p>A function that takes a key and value.</p> required <p>Examples:</p> <pre><code>def on_item_added(key, value):\n    print(f\"Added {key}: {value}\")\n\nuser_data = ObservableDict[str, str]({\"name\": \"Alice\"})\nuser_data.on_add(on_item_added)\nuser_data[\"email\"] = \"alice@example.com\"  # Triggers the callback with (\"email\", \"alice@example.com\")\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef on_add(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"\n    Register for add events with key and value.\n\n    This is a more specific alternative to on_change that only triggers\n    for add operations and provides a simpler callback signature.\n\n    Args:\n        callback: A function that takes a key and value.\n\n    Examples:\n        ```python\n        def on_item_added(key, value):\n            print(f\"Added {key}: {value}\")\n\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\n        user_data.on_add(on_item_added)\n        user_data[\"email\"] = \"alice@example.com\"  # Triggers the callback with (\"email\", \"alice@example.com\")\n        ```\n    \"\"\"\n    self._add_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.on_change","title":"<code>on_change(callback)</code>","text":"<p>Add a callback to be called when the dictionary changes.</p> <p>The callback will be called with an ObservableDictChange object that contains information about the type of change (add, remove, update, clear) and the affected items.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ObservableDictChange[TKey, TValue]], None]</code> <p>A function that takes an ObservableDictChange object.</p> required <p>Examples:</p> <pre><code>def on_dict_change(change):\n    print(f\"Change type: {change.type}\")\n    if change.type == ObservableCollectionChangeType.ADD:\n        print(f\"Added key: {change.key}, value: {change.value}\")\n    elif change.type == ObservableCollectionChangeType.UPDATE:\n        print(f\"Updated key: {change.key}, new value: {change.value}\")\n\nuser_data = ObservableDict[str, str]({\"name\": \"Alice\"})\nuser_data.on_change(on_dict_change)\nuser_data[\"email\"] = \"alice@example.com\"  # Triggers the callback\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef on_change(self, callback: Callable[[ObservableDictChange[TKey, TValue]], None]) -&gt; None:\n    \"\"\"\n    Add a callback to be called when the dictionary changes.\n\n    The callback will be called with an ObservableDictChange object that contains\n    information about the type of change (add, remove, update, clear) and the affected items.\n\n    Args:\n        callback: A function that takes an ObservableDictChange object.\n\n    Examples:\n        ```python\n        def on_dict_change(change):\n            print(f\"Change type: {change.type}\")\n            if change.type == ObservableCollectionChangeType.ADD:\n                print(f\"Added key: {change.key}, value: {change.value}\")\n            elif change.type == ObservableCollectionChangeType.UPDATE:\n                print(f\"Updated key: {change.key}, new value: {change.value}\")\n\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\n        user_data.on_change(on_dict_change)\n        user_data[\"email\"] = \"alice@example.com\"  # Triggers the callback\n        ```\n    \"\"\"\n    self._change_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.on_clear","title":"<code>on_clear(callback)</code>","text":"<p>Register for clear events with the cleared items.</p> <p>This is a more specific alternative to on_change that only triggers for clear operations and provides a simpler callback signature.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[dict[TKey, TValue]], None]</code> <p>A function that takes a dict of cleared items.</p> required <p>Examples:</p> <pre><code>def on_dict_cleared(items):\n    print(f\"Cleared {len(items)} items: {items}\")\n\nuser_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\nuser_data.on_clear(on_dict_cleared)\nuser_data.clear()  # Triggers the callback with {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef on_clear(self, callback: Callable[[dict[TKey, TValue]], None]) -&gt; None:\n    \"\"\"\n    Register for clear events with the cleared items.\n\n    This is a more specific alternative to on_change that only triggers\n    for clear operations and provides a simpler callback signature.\n\n    Args:\n        callback: A function that takes a dict of cleared items.\n\n    Examples:\n        ```python\n        def on_dict_cleared(items):\n            print(f\"Cleared {len(items)} items: {items}\")\n\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n        user_data.on_clear(on_dict_cleared)\n        user_data.clear()  # Triggers the callback with {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\n        ```\n    \"\"\"\n    self._clear_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.on_remove","title":"<code>on_remove(callback)</code>","text":"<p>Register for remove events with key and value.</p> <p>This is a more specific alternative to on_change that only triggers for remove operations and provides a simpler callback signature.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[TKey, TValue], None]</code> <p>A function that takes a key and value.</p> required <p>Examples:</p> <pre><code>def on_item_removed(key, value):\n    print(f\"Removed {key}: {value}\")\n\nuser_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\nuser_data.on_remove(on_item_removed)\ndel user_data[\"email\"]  # Triggers the callback with (\"email\", \"alice@example.com\")\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef on_remove(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"\n    Register for remove events with key and value.\n\n    This is a more specific alternative to on_change that only triggers\n    for remove operations and provides a simpler callback signature.\n\n    Args:\n        callback: A function that takes a key and value.\n\n    Examples:\n        ```python\n        def on_item_removed(key, value):\n            print(f\"Removed {key}: {value}\")\n\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n        user_data.on_remove(on_item_removed)\n        del user_data[\"email\"]  # Triggers the callback with (\"email\", \"alice@example.com\")\n        ```\n    \"\"\"\n    self._remove_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.on_update","title":"<code>on_update(callback)</code>","text":"<p>Register for update events with key and new value.</p> <p>This is a more specific alternative to on_change that only triggers for update operations and provides a simpler callback signature.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[TKey, TValue], None]</code> <p>A function that takes a key and new value.</p> required <p>Examples:</p> <pre><code>def on_item_updated(key, value):\n    print(f\"Updated {key} to {value}\")\n\nuser_data = ObservableDict[str, str]({\"name\": \"Alice\"})\nuser_data.on_update(on_item_updated)\nuser_data[\"name\"] = \"Alicia\"  # Triggers the callback with (\"name\", \"Alicia\")\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef on_update(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"\n    Register for update events with key and new value.\n\n    This is a more specific alternative to on_change that only triggers\n    for update operations and provides a simpler callback signature.\n\n    Args:\n        callback: A function that takes a key and new value.\n\n    Examples:\n        ```python\n        def on_item_updated(key, value):\n            print(f\"Updated {key} to {value}\")\n\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\n        user_data.on_update(on_item_updated)\n        user_data[\"name\"] = \"Alicia\"  # Triggers the callback with (\"name\", \"Alicia\")\n        ```\n    \"\"\"\n    self._update_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.pop","title":"<code>pop(key, default=None)</code>","text":"<p>Remove and return the value for a key if it exists, otherwise return a default value.</p> <p>If the key exists, this method removes it and triggers remove callbacks. If the key does not exist and a default is provided, no callbacks are triggered.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TKey</code> <p>The key to look up.</p> required <code>default</code> <code>TValue | None</code> <p>The default value to return if the key is not found.</p> <code>None</code> <p>Returns:</p> Type Description <code>TValue | None</code> <p>The value for the key, or the default value.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found and no default value is provided.</p> <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\nemail = user_data.pop(\"email\")  # Returns: \"alice@example.com\" and removes it\nphone = user_data.pop(\"phone\", \"No phone\")  # Returns: \"No phone\" without modifying the dict\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef pop(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"\n    Remove and return the value for a key if it exists, otherwise return a default value.\n\n    If the key exists, this method removes it and triggers remove callbacks.\n    If the key does not exist and a default is provided, no callbacks are triggered.\n\n    Args:\n        key: The key to look up.\n        default: The default value to return if the key is not found.\n\n    Returns:\n        The value for the key, or the default value.\n\n    Raises:\n        KeyError: If the key is not found and no default value is provided.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n        email = user_data.pop(\"email\")  # Returns: \"alice@example.com\" and removes it\n        phone = user_data.pop(\"phone\", \"No phone\")  # Returns: \"No phone\" without modifying the dict\n        ```\n    \"\"\"\n    if key in self._items:\n        value = self._items.pop(key)\n        self._notify_remove(key, value)\n        return value\n    if default is not None:\n        return default\n    raise KeyError(key)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.popitem","title":"<code>popitem()</code>","text":"<p>Remove and return a (key, value) pair from the dictionary.</p> <p>This method removes an arbitrary (key, value) pair and triggers remove callbacks. In Python 3.7+, the pairs are returned in LIFO order (last inserted, first returned).</p> <p>Returns:</p> Type Description <code>tuple[TKey, TValue]</code> <p>A (key, value) pair.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the dictionary is empty.</p> <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\nkey, value = user_data.popitem()  # Might return: (\"email\", \"alice@example.com\")\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef popitem(self) -&gt; tuple[TKey, TValue]:\n    \"\"\"\n    Remove and return a (key, value) pair from the dictionary.\n\n    This method removes an arbitrary (key, value) pair and triggers remove callbacks.\n    In Python 3.7+, the pairs are returned in LIFO order (last inserted, first returned).\n\n    Returns:\n        A (key, value) pair.\n\n    Raises:\n        KeyError: If the dictionary is empty.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n        key, value = user_data.popitem()  # Might return: (\"email\", \"alice@example.com\")\n        ```\n    \"\"\"\n    key, value = self._items.popitem()\n    self._notify_remove(key, value)\n    return key, value\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.setdefault","title":"<code>setdefault(key, default=None)</code>","text":"<p>Return the value for a key if it exists, otherwise set and return the default value.</p> <p>If the key does not exist, this method adds it with the default value and triggers add callbacks.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TKey</code> <p>The key to look up.</p> required <code>default</code> <code>TValue | None</code> <p>The default value to set and return if the key is not found.</p> <code>None</code> <p>Returns:</p> Type Description <code>TValue | None</code> <p>The value for the key, or the default value.</p> <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\nemail = user_data.setdefault(\"email\", \"alice@example.com\")  # Returns: \"alice@example.com\" and adds it\nname = user_data.setdefault(\"name\", \"Unknown\")  # Returns: \"Alice\" without changing it\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef setdefault(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"\n    Return the value for a key if it exists, otherwise set and return the default value.\n\n    If the key does not exist, this method adds it with the default value and\n    triggers add callbacks.\n\n    Args:\n        key: The key to look up.\n        default: The default value to set and return if the key is not found.\n\n    Returns:\n        The value for the key, or the default value.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\n        email = user_data.setdefault(\"email\", \"alice@example.com\")  # Returns: \"alice@example.com\" and adds it\n        name = user_data.setdefault(\"name\", \"Unknown\")  # Returns: \"Alice\" without changing it\n        ```\n    \"\"\"\n    if key not in self._items:\n        self._items[key] = cast(TValue, default)  # Cast to V since we know it's a value\n        self._notify_add(key, cast(TValue, default))\n        return default\n    return self._items[key]\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.update","title":"<code>update(other)</code>","text":"<p>Update the dictionary with the key/value pairs from another dictionary.</p> <p>This method notifies callbacks about added and updated items. For each key in the other dictionary: - If the key already exists, an update notification is sent. - If the key is new, an add notification is sent. If the other dictionary is empty, no notifications are sent.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>dict[TKey, TValue]</code> <p>Another dictionary to update from.</p> required <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\nuser_data.update({\"email\": \"alice@example.com\", \"name\": \"Alicia\"})\n# Dictionary becomes {\"name\": \"Alicia\", \"email\": \"alice@example.com\"}\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef update(self, other: dict[TKey, TValue]) -&gt; None:\n    \"\"\"\n    Update the dictionary with the key/value pairs from another dictionary.\n\n    This method notifies callbacks about added and updated items.\n    For each key in the other dictionary:\n    - If the key already exists, an update notification is sent.\n    - If the key is new, an add notification is sent.\n    If the other dictionary is empty, no notifications are sent.\n\n    Args:\n        other: Another dictionary to update from.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\"})\n        user_data.update({\"email\": \"alice@example.com\", \"name\": \"Alicia\"})\n        # Dictionary becomes {\"name\": \"Alicia\", \"email\": \"alice@example.com\"}\n        ```\n    \"\"\"\n    if not other:\n        return\n    added_items: dict[TKey, TValue] = {}\n    updated_items: dict[TKey, TValue] = {}\n    for key, value in other.items():\n        if key in self._items:\n            updated_items[key] = value\n        else:\n            added_items[key] = value\n    self._items.update(other)\n\n    # Notify for added items\n    if added_items:\n        for key, value in added_items.items():\n            self._notify_add(key, value)\n\n    # Notify for updated items\n    if updated_items:\n        for key, value in updated_items.items():\n            self._notify_update(key, value)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.values","title":"<code>values()</code>","text":"<p>Return a list of all values in the dictionary.</p> <p>This method does not modify the dictionary or trigger any callbacks.</p> <p>Returns:</p> Type Description <code>list[TValue]</code> <p>A list of values.</p> <p>Examples:</p> <pre><code>user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\nvalues = user_data.values()  # Returns: [\"Alice\", \"alice@example.com\"]\n</code></pre> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef values(self) -&gt; list[TValue]:\n    \"\"\"\n    Return a list of all values in the dictionary.\n\n    This method does not modify the dictionary or trigger any callbacks.\n\n    Returns:\n        A list of values.\n\n    Examples:\n        ```python\n        user_data = ObservableDict[str, str]({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n        values = user_data.values()  # Returns: [\"Alice\", \"alice@example.com\"]\n        ```\n    \"\"\"\n    return list(self._items.values())\n</code></pre>"},{"location":"api_reference/observable_list/","title":"ObservableList","text":""},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList","title":"<code>observant.observable_list.ObservableList</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>IObservableList[T]</code></p> <p>An observable implementation of Python's list that notifies listeners of changes.</p> <p>ObservableList wraps a Python list and provides the same interface, but with additional notification capabilities. It can either create its own internal list or work with an existing list.</p> <p>When the list is modified (items added, removed, etc.), registered callbacks are notified with details about the change. This allows other components to react to changes in the list.</p> <p>Attributes:</p> Name Type Description <code>_items</code> <code>list[T]</code> <p>The internal list being observed.</p> <code>_change_callbacks</code> <code>list[Callable[[ObservableListChange[T]], None]]</code> <p>Callbacks for all types of changes.</p> <code>_add_callbacks</code> <code>list[Callable[[T, int], None]]</code> <p>Callbacks specifically for add operations.</p> <code>_remove_callbacks</code> <code>list[Callable[[T, int], None]]</code> <p>Callbacks specifically for remove operations.</p> <code>_clear_callbacks</code> <code>list[Callable[[list[T]], None]]</code> <p>Callbacks specifically for clear operations.</p> <p>Examples:</p> <pre><code># Create an empty observable list\nnumbers = ObservableList[int]()\n\n# Create with initial items\nnames = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n\n# Register a callback for all changes\nnames.on_change(lambda change: print(f\"Change: {change.type}\"))\n\n# Register a callback for adds\nnames.on_add(lambda item, index: print(f\"Added {item} at index {index}\"))\n\n# Modify the list\nnames.append(\"David\")  # Triggers callbacks\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>class ObservableList(Generic[T], IObservableList[T]):\n    \"\"\"\n    An observable implementation of Python's list that notifies listeners of changes.\n\n    ObservableList wraps a Python list and provides the same interface, but with\n    additional notification capabilities. It can either create its own internal\n    list or work with an existing list.\n\n    When the list is modified (items added, removed, etc.), registered callbacks\n    are notified with details about the change. This allows other components to\n    react to changes in the list.\n\n    Attributes:\n        _items: The internal list being observed.\n        _change_callbacks: Callbacks for all types of changes.\n        _add_callbacks: Callbacks specifically for add operations.\n        _remove_callbacks: Callbacks specifically for remove operations.\n        _clear_callbacks: Callbacks specifically for clear operations.\n\n    Examples:\n        ```python\n        # Create an empty observable list\n        numbers = ObservableList[int]()\n\n        # Create with initial items\n        names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n\n        # Register a callback for all changes\n        names.on_change(lambda change: print(f\"Change: {change.type}\"))\n\n        # Register a callback for adds\n        names.on_add(lambda item, index: print(f\"Added {item} at index {index}\"))\n\n        # Modify the list\n        names.append(\"David\")  # Triggers callbacks\n        ```\n    \"\"\"\n\n    def __init__(self, items: list[T] | None = None, *, copy: bool = False):\n        \"\"\"\n        Initialize with optional external list reference.\n\n        Args:\n            items: Optional external list to observe. If None, creates a new list.\n            copy: If True, creates a copy of the provided list instead of using it directly.\n                This is useful when you want to avoid modifying the original list.\n\n        Examples:\n            ```python\n            # Create an empty observable list\n            empty_list = ObservableList[int]()\n\n            # Create with initial items\n            names = ObservableList[str]([\"Alice\", \"Bob\"])\n\n            # Create with a copy of initial items\n            original = [\"Red\", \"Green\", \"Blue\"]\n            colors = ObservableList[str](original, copy=True)\n            colors.append(\"Yellow\")  # original list is not modified\n            ```\n        \"\"\"\n        if copy:\n            self._items: list[T] = list(items) if items is not None else []\n        else:\n            self._items: list[T] = items if items is not None else []\n        self._change_callbacks: list[Callable[[ObservableListChange[T]], None]] = []\n        self._add_callbacks: list[Callable[[T, int], None]] = []\n        self._remove_callbacks: list[Callable[[T, int], None]] = []\n        self._clear_callbacks: list[Callable[[list[T]], None]] = []\n\n    @override\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Return the number of items in the list.\n\n        Returns:\n            The number of items in the list.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\", \"Bob\"])\n            length = len(names)  # Returns: 2\n            ```\n        \"\"\"\n        return len(self._items)\n\n    @override\n    def __getitem__(self, index: int | slice) -&gt; T | list[T]:\n        \"\"\"\n        Get an item or slice of items from the list.\n\n        Args:\n            index: The index or slice to retrieve.\n\n        Returns:\n            The item at the specified index, or a list of items if a slice was provided.\n\n        Raises:\n            IndexError: If the index is out of range.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n            first = names[0]  # Returns: \"Alice\"\n            subset = names[1:3]  # Returns: [\"Bob\", \"Charlie\"]\n            ```\n        \"\"\"\n        return self._items[index]\n\n    @override\n    def __setitem__(self, index: int | slice, value: T | list[T]) -&gt; None:\n        \"\"\"\n        Set an item or slice of items in the list.\n\n        This method notifies callbacks about the removed items and then about the\n        added items. For a single item replacement, this results in a remove notification\n        followed by an add notification.\n\n        Args:\n            index: The index or slice to set.\n            value: The item or list of items to set.\n\n        Raises:\n            IndexError: If the index is out of range.\n            TypeError: If the value is not of the correct type.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n            names[1] = \"Robert\"  # Replace \"Bob\" with \"Robert\"\n            names[1:3] = [\"Eve\", \"Frank\"]  # Replace \"Robert\" and \"Charlie\"\n            ```\n        \"\"\"\n        if isinstance(index, slice):\n            # Remove old items\n            old_items = self._items[index]\n            if old_items:\n                self._notify_remove_items(old_items, index.start)\n\n            # Add new items\n            if isinstance(value, list):\n                # Explicitly cast to list[C] to help Pylance\n                self._items[index] = value\n                if value:\n                    typed_value: list[T] = cast(list[T], value)\n                    self._notify_add_items(typed_value, index.start)\n            else:\n                # Handle single item assigned to slice\n                single_value: T = cast(T, value)\n                items_list: list[T] = [single_value]\n                self._items[index] = items_list\n                self._notify_add_items(items_list, index.start)\n        else:\n            # Remove old item\n            old_item = self._items[index]\n            self._notify_remove(old_item, index)\n\n            # Add new item\n            new_value: T = cast(T, value)  # Cast to T since we know it's a single item\n            self._items[index] = new_value\n            self._notify_add(new_value, index)\n\n    @override\n    def __delitem__(self, index: int | slice) -&gt; None:\n        \"\"\"\n        Delete an item or slice of items from the list.\n\n        This method notifies callbacks about the removed items.\n\n        Args:\n            index: The index or slice to delete.\n\n        Raises:\n            IndexError: If the index is out of range.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n            del names[1]  # Remove \"Bob\"\n            del names[0:1]  # Remove \"Alice\"\n            ```\n        \"\"\"\n        if isinstance(index, slice):\n            items = self._items[index]\n            if items:\n                self._notify_remove_items(items, index.start)\n        else:\n            item = self._items[index]\n            self._notify_remove(item, index)\n        del self._items[index]\n\n    @override\n    def __iter__(self) -&gt; Iterator[T]:\n        \"\"\"\n        Return an iterator over the items in the list.\n\n        Returns:\n            An iterator over the items in the list.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n            for name in names:\n                print(name)\n            ```\n        \"\"\"\n        return iter(self._items)\n\n    @override\n    def __contains__(self, item: T) -&gt; bool:\n        \"\"\"\n        Check if an item is in the list.\n\n        Args:\n            item: The item to check for.\n\n        Returns:\n            True if the item is in the list, False otherwise.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n            if \"Bob\" in names:\n                print(\"Bob is in the list\")\n            ```\n        \"\"\"\n        return item in self._items\n\n    @override\n    def append(self, item: T) -&gt; None:\n        \"\"\"\n        Add an item to the end of the list.\n\n        This method notifies callbacks about the added item.\n\n        Args:\n            item: The item to add.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\", \"Bob\"])\n            names.append(\"Charlie\")  # List becomes [\"Alice\", \"Bob\", \"Charlie\"]\n            ```\n        \"\"\"\n        self._items.append(item)\n        self._notify_add(item, len(self._items) - 1)\n\n    @override\n    def extend(self, items: list[T]) -&gt; None:\n        \"\"\"\n        Extend the list by appending all items from the iterable.\n\n        This method notifies callbacks about the added items.\n        If the items list is empty, no notifications are sent.\n\n        Args:\n            items: The items to add.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\"])\n            names.extend([\"Bob\", \"Charlie\"])  # List becomes [\"Alice\", \"Bob\", \"Charlie\"]\n            ```\n        \"\"\"\n        if not items:\n            return\n        start_index = len(self._items)\n        self._items.extend(items)\n        self._notify_add_items(items, start_index)\n\n    @override\n    def insert(self, index: int, item: T) -&gt; None:\n        \"\"\"\n        Insert an item at a given position.\n\n        This method notifies callbacks about the added item.\n        If index is greater than the length of the list, the item is appended.\n        If index is negative, the item is inserted at index + len(self).\n\n        Args:\n            index: The position to insert the item.\n            item: The item to insert.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\", \"Charlie\"])\n            names.insert(1, \"Bob\")  # List becomes [\"Alice\", \"Bob\", \"Charlie\"]\n            ```\n        \"\"\"\n        self._items.insert(index, item)\n        self._notify_add(item, index)\n\n    @override\n    def remove(self, item: T) -&gt; None:\n        \"\"\"\n        Remove the first occurrence of an item from the list.\n\n        This method notifies callbacks about the removed item.\n\n        Args:\n            item: The item to remove.\n\n        Raises:\n            ValueError: If the item is not in the list.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\", \"Bob\"])\n            names.remove(\"Bob\")  # List becomes [\"Alice\", \"Charlie\", \"Bob\"]\n            ```\n        \"\"\"\n        index = self._items.index(item)\n        self._items.remove(item)\n        self._notify_remove(item, index)\n\n    @override\n    def pop(self, index: int = -1) -&gt; T:\n        \"\"\"\n        Remove and return an item at a given position.\n\n        This method notifies callbacks about the removed item.\n\n        Args:\n            index: The position to remove the item from (default is -1, which is the last item).\n\n        Returns:\n            The removed item.\n\n        Raises:\n            IndexError: If the list is empty or index is out of range.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n            last = names.pop()  # Returns: \"Charlie\", list becomes [\"Alice\", \"Bob\"]\n            first = names.pop(0)  # Returns: \"Alice\", list becomes [\"Bob\"]\n            ```\n        \"\"\"\n        item = self._items[index]\n        self._items.pop(index)\n        self._notify_remove(item, index)\n        return item\n\n    @override\n    def clear(self) -&gt; None:\n        \"\"\"\n        Remove all items from the list.\n\n        This method notifies callbacks about the cleared items.\n        If the list is already empty, no notifications are sent.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n            names.clear()  # List becomes []\n            ```\n        \"\"\"\n        if not self._items:\n            return\n        items = self._items.copy()\n        self._items.clear()\n        self._notify_clear(items)\n\n    @override\n    def index(self, item: T, start: int = 0, end: int | None = None) -&gt; int:\n        \"\"\"\n        Return the index of the first occurrence of an item.\n\n        Args:\n            item: The item to find.\n            start: The start index to search from.\n            end: The end index to search to.\n\n        Returns:\n            The index of the item.\n\n        Raises:\n            ValueError: If the item is not in the list.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\", \"Bob\"])\n            index = names.index(\"Bob\")  # Returns: 1\n            index = names.index(\"Bob\", 2)  # Returns: 3 (search starts at index 2)\n            ```\n        \"\"\"\n        if end is None:\n            return self._items.index(item, start)\n        return self._items.index(item, start, end)\n\n    @override\n    def count(self, item: T) -&gt; int:\n        \"\"\"\n        Return the number of occurrences of an item in the list.\n\n        Args:\n            item: The item to count.\n\n        Returns:\n            The number of occurrences.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\", \"Bob\"])\n            count = names.count(\"Bob\")  # Returns: 2\n            ```\n        \"\"\"\n        return self._items.count(item)\n\n    @override\n    def sort(\n        self,\n        *,\n        key: Callable[[T], Any] | None = None,\n        reverse: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Sort the list in place.\n\n        This method does not notify callbacks as the items themselves haven't changed,\n        only their order.\n\n        Args:\n            key: A function that takes an item and returns a key for sorting.\n            reverse: Whether to sort in reverse order.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Charlie\", \"Alice\", \"Bob\"])\n            names.sort()  # List becomes [\"Alice\", \"Bob\", \"Charlie\"]\n\n            # Sort by length of name\n            names.sort(key=len)  # List becomes [\"Bob\", \"Alice\", \"Charlie\"]\n\n            # Sort in reverse order\n            names.sort(reverse=True)  # List becomes [\"Charlie\", \"Bob\", \"Alice\"]\n            ```\n        \"\"\"\n\n        # Note: pylance is just WRONG about the keys being wrong types.\n\n        if key is None:\n            if reverse:\n                self._items.sort(key=None, reverse=True)  # type: ignore\n            else:\n                self._items.sort(key=None, reverse=False)  # type: ignore\n        else:\n            self._items.sort(key=key, reverse=reverse)\n\n    @override\n    def reverse(self) -&gt; None:\n        \"\"\"\n        Reverse the list in place.\n\n        This method does not notify callbacks as the items themselves haven't changed,\n        only their order.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n            names.reverse()  # List becomes [\"Charlie\", \"Bob\", \"Alice\"]\n            ```\n        \"\"\"\n        self._items.reverse()\n        # No notification needed as the items themselves haven't changed\n\n    @override\n    def copy(self) -&gt; list[T]:\n        \"\"\"\n        Return a shallow copy of the list.\n\n        This method returns a regular Python list, not an ObservableList.\n\n        Returns:\n            A shallow copy of the list as a regular Python list.\n\n        Examples:\n            ```python\n            names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n            copy = names.copy()  # Returns: [\"Alice\", \"Bob\", \"Charlie\"] as a regular list\n            ```\n        \"\"\"\n        return self._items.copy()\n\n    @override\n    def on_change(self, callback: Callable[[ObservableListChange[T]], None]) -&gt; None:\n        \"\"\"\n        Add a callback to be called when the list changes.\n\n        The callback will be called with an ObservableListChange object that contains\n        information about the type of change (add, remove, clear) and the affected items.\n\n        Args:\n            callback: A function that takes an ObservableListChange object.\n\n        Examples:\n            ```python\n            def on_list_change(change):\n                print(f\"Change type: {change.type}\")\n                if change.type == ObservableCollectionChangeType.ADD:\n                    print(f\"Added at index {change.index}\")\n                    if change.item:\n                        print(f\"Added item: {change.item}\")\n                    elif change.items:\n                        print(f\"Added items: {change.items}\")\n\n            names = ObservableList[str]([\"Alice\"])\n            names.on_change(on_list_change)\n            names.append(\"Bob\")  # Triggers the callback\n            ```\n        \"\"\"\n        self._change_callbacks.append(callback)\n\n    @override\n    def on_add(self, callback: Callable[[T, int], None]) -&gt; None:\n        \"\"\"\n        Register for add events with item and index.\n\n        This is a more specific alternative to on_change that only triggers\n        for add operations and provides a simpler callback signature.\n\n        Args:\n            callback: A function that takes an item and its index.\n\n        Examples:\n            ```python\n            def on_item_added(item, index):\n                print(f\"Added {item} at index {index}\")\n\n            names = ObservableList[str]([\"Alice\"])\n            names.on_add(on_item_added)\n            names.append(\"Bob\")  # Triggers the callback with (\"Bob\", 1)\n            ```\n        \"\"\"\n        self._add_callbacks.append(callback)\n\n    @override\n    def on_remove(self, callback: Callable[[T, int], None]) -&gt; None:\n        \"\"\"\n        Register for remove events with item and index.\n\n        This is a more specific alternative to on_change that only triggers\n        for remove operations and provides a simpler callback signature.\n\n        Args:\n            callback: A function that takes an item and its index.\n\n        Examples:\n            ```python\n            def on_item_removed(item, index):\n                print(f\"Removed {item} from index {index}\")\n\n            names = ObservableList[str]([\"Alice\", \"Bob\"])\n            names.on_remove(on_item_removed)\n            names.pop(1)  # Triggers the callback with (\"Bob\", 1)\n            ```\n        \"\"\"\n        self._remove_callbacks.append(callback)\n\n    @override\n    def on_clear(self, callback: Callable[[list[T]], None]) -&gt; None:\n        \"\"\"\n        Register for clear events with the cleared items.\n\n        This is a more specific alternative to on_change that only triggers\n        for clear operations and provides a simpler callback signature.\n\n        Args:\n            callback: A function that takes a list of cleared items.\n\n        Examples:\n            ```python\n            def on_list_cleared(items):\n                print(f\"Cleared {len(items)} items: {items}\")\n\n            names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n            names.on_clear(on_list_cleared)\n            names.clear()  # Triggers the callback with [\"Alice\", \"Bob\", \"Charlie\"]\n            ```\n        \"\"\"\n        self._clear_callbacks.append(callback)\n\n    def _notify_add(self, item: T, index: int) -&gt; None:\n        \"\"\"\n        Notify all callbacks of an item being added.\n\n        This internal method is called by methods that add items to the list.\n        It notifies both specific add callbacks and general change callbacks.\n\n        Args:\n            item: The item that was added.\n            index: The index where the item was added.\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._add_callbacks:\n            callback(item, index)\n\n        # Call general change callbacks\n        change = ObservableListChange(type=ObservableCollectionChangeType.ADD, index=index, item=item)\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_add_items(self, items: list[T], start_index: int) -&gt; None:\n        \"\"\"\n        Notify all callbacks of multiple items being added.\n\n        This internal method is called by methods that add multiple items to the list.\n        It notifies both specific add callbacks for each item and general change callbacks\n        with all items.\n\n        Args:\n            items: The items that were added.\n            start_index: The index where the items were added.\n        \"\"\"\n        # Call specific callbacks for each item\n        for i, item in enumerate(items):\n            index = start_index + i\n            for callback in self._add_callbacks:\n                callback(item, index)\n\n        # Call general change callbacks\n        change = ObservableListChange(type=ObservableCollectionChangeType.ADD, index=start_index, items=items)\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_remove(self, item: T, index: int) -&gt; None:\n        \"\"\"\n        Notify all callbacks of an item being removed.\n\n        This internal method is called by methods that remove items from the list.\n        It notifies both specific remove callbacks and general change callbacks.\n\n        Args:\n            item: The item that was removed.\n            index: The index where the item was removed.\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._remove_callbacks:\n            callback(item, index)\n\n        # Call general change callbacks\n        change = ObservableListChange(type=ObservableCollectionChangeType.REMOVE, index=index, item=item)\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_remove_items(self, items: list[T], start_index: int) -&gt; None:\n        \"\"\"\n        Notify all callbacks of multiple items being removed.\n\n        This internal method is called by methods that remove multiple items from the list.\n        It notifies both specific remove callbacks for each item and general change callbacks\n        with all items.\n\n        Args:\n            items: The items that were removed.\n            start_index: The index where the items were removed.\n        \"\"\"\n        # Call specific callbacks for each item\n        for i, item in enumerate(items):\n            index = start_index + i\n            for callback in self._remove_callbacks:\n                callback(item, index)\n\n        # Call general change callbacks\n        change = ObservableListChange(type=ObservableCollectionChangeType.REMOVE, index=start_index, items=items)\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_clear(self, items: list[T]) -&gt; None:\n        \"\"\"\n        Notify all callbacks of the list being cleared.\n\n        This internal method is called by the clear method.\n        It notifies both specific clear callbacks and general change callbacks.\n\n        Args:\n            items: The items that were cleared.\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._clear_callbacks:\n            callback(items)\n\n        # Call general change callbacks\n        change = ObservableListChange(type=ObservableCollectionChangeType.CLEAR, items=items)\n        for callback in self._change_callbacks:\n            callback(change)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__contains__","title":"<code>__contains__(item)</code>","text":"<p>Check if an item is in the list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to check for.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the item is in the list, False otherwise.</p> <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\nif \"Bob\" in names:\n    print(\"Bob is in the list\")\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __contains__(self, item: T) -&gt; bool:\n    \"\"\"\n    Check if an item is in the list.\n\n    Args:\n        item: The item to check for.\n\n    Returns:\n        True if the item is in the list, False otherwise.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n        if \"Bob\" in names:\n            print(\"Bob is in the list\")\n        ```\n    \"\"\"\n    return item in self._items\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__delitem__","title":"<code>__delitem__(index)</code>","text":"<p>Delete an item or slice of items from the list.</p> <p>This method notifies callbacks about the removed items.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | slice</code> <p>The index or slice to delete.</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range.</p> <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\ndel names[1]  # Remove \"Bob\"\ndel names[0:1]  # Remove \"Alice\"\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __delitem__(self, index: int | slice) -&gt; None:\n    \"\"\"\n    Delete an item or slice of items from the list.\n\n    This method notifies callbacks about the removed items.\n\n    Args:\n        index: The index or slice to delete.\n\n    Raises:\n        IndexError: If the index is out of range.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n        del names[1]  # Remove \"Bob\"\n        del names[0:1]  # Remove \"Alice\"\n        ```\n    \"\"\"\n    if isinstance(index, slice):\n        items = self._items[index]\n        if items:\n            self._notify_remove_items(items, index.start)\n    else:\n        item = self._items[index]\n        self._notify_remove(item, index)\n    del self._items[index]\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Get an item or slice of items from the list.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | slice</code> <p>The index or slice to retrieve.</p> required <p>Returns:</p> Type Description <code>T | list[T]</code> <p>The item at the specified index, or a list of items if a slice was provided.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range.</p> <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\nfirst = names[0]  # Returns: \"Alice\"\nsubset = names[1:3]  # Returns: [\"Bob\", \"Charlie\"]\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __getitem__(self, index: int | slice) -&gt; T | list[T]:\n    \"\"\"\n    Get an item or slice of items from the list.\n\n    Args:\n        index: The index or slice to retrieve.\n\n    Returns:\n        The item at the specified index, or a list of items if a slice was provided.\n\n    Raises:\n        IndexError: If the index is out of range.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n        first = names[0]  # Returns: \"Alice\"\n        subset = names[1:3]  # Returns: [\"Bob\", \"Charlie\"]\n        ```\n    \"\"\"\n    return self._items[index]\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__init__","title":"<code>__init__(items=None, *, copy=False)</code>","text":"<p>Initialize with optional external list reference.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[T] | None</code> <p>Optional external list to observe. If None, creates a new list.</p> <code>None</code> <code>copy</code> <code>bool</code> <p>If True, creates a copy of the provided list instead of using it directly. This is useful when you want to avoid modifying the original list.</p> <code>False</code> <p>Examples:</p> <pre><code># Create an empty observable list\nempty_list = ObservableList[int]()\n\n# Create with initial items\nnames = ObservableList[str]([\"Alice\", \"Bob\"])\n\n# Create with a copy of initial items\noriginal = [\"Red\", \"Green\", \"Blue\"]\ncolors = ObservableList[str](original, copy=True)\ncolors.append(\"Yellow\")  # original list is not modified\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>def __init__(self, items: list[T] | None = None, *, copy: bool = False):\n    \"\"\"\n    Initialize with optional external list reference.\n\n    Args:\n        items: Optional external list to observe. If None, creates a new list.\n        copy: If True, creates a copy of the provided list instead of using it directly.\n            This is useful when you want to avoid modifying the original list.\n\n    Examples:\n        ```python\n        # Create an empty observable list\n        empty_list = ObservableList[int]()\n\n        # Create with initial items\n        names = ObservableList[str]([\"Alice\", \"Bob\"])\n\n        # Create with a copy of initial items\n        original = [\"Red\", \"Green\", \"Blue\"]\n        colors = ObservableList[str](original, copy=True)\n        colors.append(\"Yellow\")  # original list is not modified\n        ```\n    \"\"\"\n    if copy:\n        self._items: list[T] = list(items) if items is not None else []\n    else:\n        self._items: list[T] = items if items is not None else []\n    self._change_callbacks: list[Callable[[ObservableListChange[T]], None]] = []\n    self._add_callbacks: list[Callable[[T, int], None]] = []\n    self._remove_callbacks: list[Callable[[T, int], None]] = []\n    self._clear_callbacks: list[Callable[[list[T]], None]] = []\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the items in the list.</p> <p>Returns:</p> Type Description <code>Iterator[T]</code> <p>An iterator over the items in the list.</p> <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\nfor name in names:\n    print(name)\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __iter__(self) -&gt; Iterator[T]:\n    \"\"\"\n    Return an iterator over the items in the list.\n\n    Returns:\n        An iterator over the items in the list.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n        for name in names:\n            print(name)\n        ```\n    \"\"\"\n    return iter(self._items)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of items in the list.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of items in the list.</p> <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\", \"Bob\"])\nlength = len(names)  # Returns: 2\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __len__(self) -&gt; int:\n    \"\"\"\n    Return the number of items in the list.\n\n    Returns:\n        The number of items in the list.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\", \"Bob\"])\n        length = len(names)  # Returns: 2\n        ```\n    \"\"\"\n    return len(self._items)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__setitem__","title":"<code>__setitem__(index, value)</code>","text":"<p>Set an item or slice of items in the list.</p> <p>This method notifies callbacks about the removed items and then about the added items. For a single item replacement, this results in a remove notification followed by an add notification.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | slice</code> <p>The index or slice to set.</p> required <code>value</code> <code>T | list[T]</code> <p>The item or list of items to set.</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range.</p> <code>TypeError</code> <p>If the value is not of the correct type.</p> <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\nnames[1] = \"Robert\"  # Replace \"Bob\" with \"Robert\"\nnames[1:3] = [\"Eve\", \"Frank\"]  # Replace \"Robert\" and \"Charlie\"\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __setitem__(self, index: int | slice, value: T | list[T]) -&gt; None:\n    \"\"\"\n    Set an item or slice of items in the list.\n\n    This method notifies callbacks about the removed items and then about the\n    added items. For a single item replacement, this results in a remove notification\n    followed by an add notification.\n\n    Args:\n        index: The index or slice to set.\n        value: The item or list of items to set.\n\n    Raises:\n        IndexError: If the index is out of range.\n        TypeError: If the value is not of the correct type.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n        names[1] = \"Robert\"  # Replace \"Bob\" with \"Robert\"\n        names[1:3] = [\"Eve\", \"Frank\"]  # Replace \"Robert\" and \"Charlie\"\n        ```\n    \"\"\"\n    if isinstance(index, slice):\n        # Remove old items\n        old_items = self._items[index]\n        if old_items:\n            self._notify_remove_items(old_items, index.start)\n\n        # Add new items\n        if isinstance(value, list):\n            # Explicitly cast to list[C] to help Pylance\n            self._items[index] = value\n            if value:\n                typed_value: list[T] = cast(list[T], value)\n                self._notify_add_items(typed_value, index.start)\n        else:\n            # Handle single item assigned to slice\n            single_value: T = cast(T, value)\n            items_list: list[T] = [single_value]\n            self._items[index] = items_list\n            self._notify_add_items(items_list, index.start)\n    else:\n        # Remove old item\n        old_item = self._items[index]\n        self._notify_remove(old_item, index)\n\n        # Add new item\n        new_value: T = cast(T, value)  # Cast to T since we know it's a single item\n        self._items[index] = new_value\n        self._notify_add(new_value, index)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.append","title":"<code>append(item)</code>","text":"<p>Add an item to the end of the list.</p> <p>This method notifies callbacks about the added item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to add.</p> required <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\", \"Bob\"])\nnames.append(\"Charlie\")  # List becomes [\"Alice\", \"Bob\", \"Charlie\"]\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef append(self, item: T) -&gt; None:\n    \"\"\"\n    Add an item to the end of the list.\n\n    This method notifies callbacks about the added item.\n\n    Args:\n        item: The item to add.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\", \"Bob\"])\n        names.append(\"Charlie\")  # List becomes [\"Alice\", \"Bob\", \"Charlie\"]\n        ```\n    \"\"\"\n    self._items.append(item)\n    self._notify_add(item, len(self._items) - 1)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.clear","title":"<code>clear()</code>","text":"<p>Remove all items from the list.</p> <p>This method notifies callbacks about the cleared items. If the list is already empty, no notifications are sent.</p> <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\nnames.clear()  # List becomes []\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef clear(self) -&gt; None:\n    \"\"\"\n    Remove all items from the list.\n\n    This method notifies callbacks about the cleared items.\n    If the list is already empty, no notifications are sent.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n        names.clear()  # List becomes []\n        ```\n    \"\"\"\n    if not self._items:\n        return\n    items = self._items.copy()\n    self._items.clear()\n    self._notify_clear(items)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.copy","title":"<code>copy()</code>","text":"<p>Return a shallow copy of the list.</p> <p>This method returns a regular Python list, not an ObservableList.</p> <p>Returns:</p> Type Description <code>list[T]</code> <p>A shallow copy of the list as a regular Python list.</p> <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\ncopy = names.copy()  # Returns: [\"Alice\", \"Bob\", \"Charlie\"] as a regular list\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef copy(self) -&gt; list[T]:\n    \"\"\"\n    Return a shallow copy of the list.\n\n    This method returns a regular Python list, not an ObservableList.\n\n    Returns:\n        A shallow copy of the list as a regular Python list.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n        copy = names.copy()  # Returns: [\"Alice\", \"Bob\", \"Charlie\"] as a regular list\n        ```\n    \"\"\"\n    return self._items.copy()\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.count","title":"<code>count(item)</code>","text":"<p>Return the number of occurrences of an item in the list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to count.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of occurrences.</p> <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\", \"Bob\"])\ncount = names.count(\"Bob\")  # Returns: 2\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef count(self, item: T) -&gt; int:\n    \"\"\"\n    Return the number of occurrences of an item in the list.\n\n    Args:\n        item: The item to count.\n\n    Returns:\n        The number of occurrences.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\", \"Bob\"])\n        count = names.count(\"Bob\")  # Returns: 2\n        ```\n    \"\"\"\n    return self._items.count(item)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.extend","title":"<code>extend(items)</code>","text":"<p>Extend the list by appending all items from the iterable.</p> <p>This method notifies callbacks about the added items. If the items list is empty, no notifications are sent.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[T]</code> <p>The items to add.</p> required <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\"])\nnames.extend([\"Bob\", \"Charlie\"])  # List becomes [\"Alice\", \"Bob\", \"Charlie\"]\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef extend(self, items: list[T]) -&gt; None:\n    \"\"\"\n    Extend the list by appending all items from the iterable.\n\n    This method notifies callbacks about the added items.\n    If the items list is empty, no notifications are sent.\n\n    Args:\n        items: The items to add.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\"])\n        names.extend([\"Bob\", \"Charlie\"])  # List becomes [\"Alice\", \"Bob\", \"Charlie\"]\n        ```\n    \"\"\"\n    if not items:\n        return\n    start_index = len(self._items)\n    self._items.extend(items)\n    self._notify_add_items(items, start_index)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.index","title":"<code>index(item, start=0, end=None)</code>","text":"<p>Return the index of the first occurrence of an item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to find.</p> required <code>start</code> <code>int</code> <p>The start index to search from.</p> <code>0</code> <code>end</code> <code>int | None</code> <p>The end index to search to.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The index of the item.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the item is not in the list.</p> <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\", \"Bob\"])\nindex = names.index(\"Bob\")  # Returns: 1\nindex = names.index(\"Bob\", 2)  # Returns: 3 (search starts at index 2)\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef index(self, item: T, start: int = 0, end: int | None = None) -&gt; int:\n    \"\"\"\n    Return the index of the first occurrence of an item.\n\n    Args:\n        item: The item to find.\n        start: The start index to search from.\n        end: The end index to search to.\n\n    Returns:\n        The index of the item.\n\n    Raises:\n        ValueError: If the item is not in the list.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\", \"Bob\"])\n        index = names.index(\"Bob\")  # Returns: 1\n        index = names.index(\"Bob\", 2)  # Returns: 3 (search starts at index 2)\n        ```\n    \"\"\"\n    if end is None:\n        return self._items.index(item, start)\n    return self._items.index(item, start, end)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.insert","title":"<code>insert(index, item)</code>","text":"<p>Insert an item at a given position.</p> <p>This method notifies callbacks about the added item. If index is greater than the length of the list, the item is appended. If index is negative, the item is inserted at index + len(self).</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The position to insert the item.</p> required <code>item</code> <code>T</code> <p>The item to insert.</p> required <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\", \"Charlie\"])\nnames.insert(1, \"Bob\")  # List becomes [\"Alice\", \"Bob\", \"Charlie\"]\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef insert(self, index: int, item: T) -&gt; None:\n    \"\"\"\n    Insert an item at a given position.\n\n    This method notifies callbacks about the added item.\n    If index is greater than the length of the list, the item is appended.\n    If index is negative, the item is inserted at index + len(self).\n\n    Args:\n        index: The position to insert the item.\n        item: The item to insert.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\", \"Charlie\"])\n        names.insert(1, \"Bob\")  # List becomes [\"Alice\", \"Bob\", \"Charlie\"]\n        ```\n    \"\"\"\n    self._items.insert(index, item)\n    self._notify_add(item, index)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.on_add","title":"<code>on_add(callback)</code>","text":"<p>Register for add events with item and index.</p> <p>This is a more specific alternative to on_change that only triggers for add operations and provides a simpler callback signature.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[T, int], None]</code> <p>A function that takes an item and its index.</p> required <p>Examples:</p> <pre><code>def on_item_added(item, index):\n    print(f\"Added {item} at index {index}\")\n\nnames = ObservableList[str]([\"Alice\"])\nnames.on_add(on_item_added)\nnames.append(\"Bob\")  # Triggers the callback with (\"Bob\", 1)\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef on_add(self, callback: Callable[[T, int], None]) -&gt; None:\n    \"\"\"\n    Register for add events with item and index.\n\n    This is a more specific alternative to on_change that only triggers\n    for add operations and provides a simpler callback signature.\n\n    Args:\n        callback: A function that takes an item and its index.\n\n    Examples:\n        ```python\n        def on_item_added(item, index):\n            print(f\"Added {item} at index {index}\")\n\n        names = ObservableList[str]([\"Alice\"])\n        names.on_add(on_item_added)\n        names.append(\"Bob\")  # Triggers the callback with (\"Bob\", 1)\n        ```\n    \"\"\"\n    self._add_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.on_change","title":"<code>on_change(callback)</code>","text":"<p>Add a callback to be called when the list changes.</p> <p>The callback will be called with an ObservableListChange object that contains information about the type of change (add, remove, clear) and the affected items.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ObservableListChange[T]], None]</code> <p>A function that takes an ObservableListChange object.</p> required <p>Examples:</p> <pre><code>def on_list_change(change):\n    print(f\"Change type: {change.type}\")\n    if change.type == ObservableCollectionChangeType.ADD:\n        print(f\"Added at index {change.index}\")\n        if change.item:\n            print(f\"Added item: {change.item}\")\n        elif change.items:\n            print(f\"Added items: {change.items}\")\n\nnames = ObservableList[str]([\"Alice\"])\nnames.on_change(on_list_change)\nnames.append(\"Bob\")  # Triggers the callback\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef on_change(self, callback: Callable[[ObservableListChange[T]], None]) -&gt; None:\n    \"\"\"\n    Add a callback to be called when the list changes.\n\n    The callback will be called with an ObservableListChange object that contains\n    information about the type of change (add, remove, clear) and the affected items.\n\n    Args:\n        callback: A function that takes an ObservableListChange object.\n\n    Examples:\n        ```python\n        def on_list_change(change):\n            print(f\"Change type: {change.type}\")\n            if change.type == ObservableCollectionChangeType.ADD:\n                print(f\"Added at index {change.index}\")\n                if change.item:\n                    print(f\"Added item: {change.item}\")\n                elif change.items:\n                    print(f\"Added items: {change.items}\")\n\n        names = ObservableList[str]([\"Alice\"])\n        names.on_change(on_list_change)\n        names.append(\"Bob\")  # Triggers the callback\n        ```\n    \"\"\"\n    self._change_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.on_clear","title":"<code>on_clear(callback)</code>","text":"<p>Register for clear events with the cleared items.</p> <p>This is a more specific alternative to on_change that only triggers for clear operations and provides a simpler callback signature.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[list[T]], None]</code> <p>A function that takes a list of cleared items.</p> required <p>Examples:</p> <pre><code>def on_list_cleared(items):\n    print(f\"Cleared {len(items)} items: {items}\")\n\nnames = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\nnames.on_clear(on_list_cleared)\nnames.clear()  # Triggers the callback with [\"Alice\", \"Bob\", \"Charlie\"]\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef on_clear(self, callback: Callable[[list[T]], None]) -&gt; None:\n    \"\"\"\n    Register for clear events with the cleared items.\n\n    This is a more specific alternative to on_change that only triggers\n    for clear operations and provides a simpler callback signature.\n\n    Args:\n        callback: A function that takes a list of cleared items.\n\n    Examples:\n        ```python\n        def on_list_cleared(items):\n            print(f\"Cleared {len(items)} items: {items}\")\n\n        names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n        names.on_clear(on_list_cleared)\n        names.clear()  # Triggers the callback with [\"Alice\", \"Bob\", \"Charlie\"]\n        ```\n    \"\"\"\n    self._clear_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.on_remove","title":"<code>on_remove(callback)</code>","text":"<p>Register for remove events with item and index.</p> <p>This is a more specific alternative to on_change that only triggers for remove operations and provides a simpler callback signature.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[T, int], None]</code> <p>A function that takes an item and its index.</p> required <p>Examples:</p> <pre><code>def on_item_removed(item, index):\n    print(f\"Removed {item} from index {index}\")\n\nnames = ObservableList[str]([\"Alice\", \"Bob\"])\nnames.on_remove(on_item_removed)\nnames.pop(1)  # Triggers the callback with (\"Bob\", 1)\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef on_remove(self, callback: Callable[[T, int], None]) -&gt; None:\n    \"\"\"\n    Register for remove events with item and index.\n\n    This is a more specific alternative to on_change that only triggers\n    for remove operations and provides a simpler callback signature.\n\n    Args:\n        callback: A function that takes an item and its index.\n\n    Examples:\n        ```python\n        def on_item_removed(item, index):\n            print(f\"Removed {item} from index {index}\")\n\n        names = ObservableList[str]([\"Alice\", \"Bob\"])\n        names.on_remove(on_item_removed)\n        names.pop(1)  # Triggers the callback with (\"Bob\", 1)\n        ```\n    \"\"\"\n    self._remove_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.pop","title":"<code>pop(index=-1)</code>","text":"<p>Remove and return an item at a given position.</p> <p>This method notifies callbacks about the removed item.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The position to remove the item from (default is -1, which is the last item).</p> <code>-1</code> <p>Returns:</p> Type Description <code>T</code> <p>The removed item.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the list is empty or index is out of range.</p> <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\nlast = names.pop()  # Returns: \"Charlie\", list becomes [\"Alice\", \"Bob\"]\nfirst = names.pop(0)  # Returns: \"Alice\", list becomes [\"Bob\"]\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef pop(self, index: int = -1) -&gt; T:\n    \"\"\"\n    Remove and return an item at a given position.\n\n    This method notifies callbacks about the removed item.\n\n    Args:\n        index: The position to remove the item from (default is -1, which is the last item).\n\n    Returns:\n        The removed item.\n\n    Raises:\n        IndexError: If the list is empty or index is out of range.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n        last = names.pop()  # Returns: \"Charlie\", list becomes [\"Alice\", \"Bob\"]\n        first = names.pop(0)  # Returns: \"Alice\", list becomes [\"Bob\"]\n        ```\n    \"\"\"\n    item = self._items[index]\n    self._items.pop(index)\n    self._notify_remove(item, index)\n    return item\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.remove","title":"<code>remove(item)</code>","text":"<p>Remove the first occurrence of an item from the list.</p> <p>This method notifies callbacks about the removed item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to remove.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the item is not in the list.</p> <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\", \"Bob\"])\nnames.remove(\"Bob\")  # List becomes [\"Alice\", \"Charlie\", \"Bob\"]\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef remove(self, item: T) -&gt; None:\n    \"\"\"\n    Remove the first occurrence of an item from the list.\n\n    This method notifies callbacks about the removed item.\n\n    Args:\n        item: The item to remove.\n\n    Raises:\n        ValueError: If the item is not in the list.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\", \"Bob\"])\n        names.remove(\"Bob\")  # List becomes [\"Alice\", \"Charlie\", \"Bob\"]\n        ```\n    \"\"\"\n    index = self._items.index(item)\n    self._items.remove(item)\n    self._notify_remove(item, index)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.reverse","title":"<code>reverse()</code>","text":"<p>Reverse the list in place.</p> <p>This method does not notify callbacks as the items themselves haven't changed, only their order.</p> <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\nnames.reverse()  # List becomes [\"Charlie\", \"Bob\", \"Alice\"]\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef reverse(self) -&gt; None:\n    \"\"\"\n    Reverse the list in place.\n\n    This method does not notify callbacks as the items themselves haven't changed,\n    only their order.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Alice\", \"Bob\", \"Charlie\"])\n        names.reverse()  # List becomes [\"Charlie\", \"Bob\", \"Alice\"]\n        ```\n    \"\"\"\n    self._items.reverse()\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.sort","title":"<code>sort(*, key=None, reverse=False)</code>","text":"<p>Sort the list in place.</p> <p>This method does not notify callbacks as the items themselves haven't changed, only their order.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], Any] | None</code> <p>A function that takes an item and returns a key for sorting.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Whether to sort in reverse order.</p> <code>False</code> <p>Examples:</p> <pre><code>names = ObservableList[str]([\"Charlie\", \"Alice\", \"Bob\"])\nnames.sort()  # List becomes [\"Alice\", \"Bob\", \"Charlie\"]\n\n# Sort by length of name\nnames.sort(key=len)  # List becomes [\"Bob\", \"Alice\", \"Charlie\"]\n\n# Sort in reverse order\nnames.sort(reverse=True)  # List becomes [\"Charlie\", \"Bob\", \"Alice\"]\n</code></pre> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef sort(\n    self,\n    *,\n    key: Callable[[T], Any] | None = None,\n    reverse: bool = False,\n) -&gt; None:\n    \"\"\"\n    Sort the list in place.\n\n    This method does not notify callbacks as the items themselves haven't changed,\n    only their order.\n\n    Args:\n        key: A function that takes an item and returns a key for sorting.\n        reverse: Whether to sort in reverse order.\n\n    Examples:\n        ```python\n        names = ObservableList[str]([\"Charlie\", \"Alice\", \"Bob\"])\n        names.sort()  # List becomes [\"Alice\", \"Bob\", \"Charlie\"]\n\n        # Sort by length of name\n        names.sort(key=len)  # List becomes [\"Bob\", \"Alice\", \"Charlie\"]\n\n        # Sort in reverse order\n        names.sort(reverse=True)  # List becomes [\"Charlie\", \"Bob\", \"Alice\"]\n        ```\n    \"\"\"\n\n    # Note: pylance is just WRONG about the keys being wrong types.\n\n    if key is None:\n        if reverse:\n            self._items.sort(key=None, reverse=True)  # type: ignore\n        else:\n            self._items.sort(key=None, reverse=False)  # type: ignore\n    else:\n        self._items.sort(key=key, reverse=reverse)\n</code></pre>"},{"location":"api_reference/observable_proxy/","title":"ObservableProxy","text":""},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy","title":"<code>observant.observable_proxy.ObservableProxy</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>IObservableProxy[T]</code></p> <p>Proxy for a data object that exposes its fields as Observable, ObservableList, or ObservableDict.</p> <p>ObservableProxy is the central class in the observant library, providing a reactive interface to any Python object. It wraps a data object and exposes its fields as observable properties that can be watched for changes.</p> <p>Key features: - Expose scalar fields as Observable objects - Expose list fields as ObservableList objects - Expose dictionary fields as ObservableDict objects - Optional synchronization with the source model - Validation with error tracking - Computed properties that depend on other observables - Undo/redo functionality with configurable history - Change tracking (dirty state)</p> <p>The proxy can be configured to automatically sync changes back to the source model, or to require explicit saving. It also supports undo/redo functionality with configurable history size and debounce timing.</p> <p>Attributes:</p> Name Type Description <code>_obj</code> <p>The object being proxied.</p> <code>_sync_default</code> <p>Whether to sync changes back to the model by default.</p> <code>_scalars</code> <code>dict[ProxyFieldKey, Observable[Any]]</code> <p>Dictionary of scalar observables.</p> <code>_lists</code> <code>dict[ProxyFieldKey, ObservableList[Any]]</code> <p>Dictionary of list observables.</p> <code>_dicts</code> <code>dict[ProxyFieldKey, ObservableDict[Any, Any]]</code> <p>Dictionary of dictionary observables.</p> <code>_computeds</code> <code>dict[str, Observable[Any]]</code> <p>Dictionary of computed observables.</p> <code>_dirty_fields</code> <code>set[str]</code> <p>Set of field names that have been modified.</p> <code>_validators</code> <code>dict[str, list[Callable[[Any], str | None]]]</code> <p>Dictionary of validator functions for each field.</p> <code>_validation_errors_dict</code> <p>Observable dictionary of validation errors.</p> <code>_validation_for_cache</code> <code>dict[str, Observable[list[str]]]</code> <p>Cache of validation observables for each field.</p> <code>_is_valid_obs</code> <p>Observable indicating whether all fields are valid.</p> <code>_default_undo_config</code> <p>Default undo configuration.</p> <code>_field_undo_configs</code> <code>dict[str, UndoConfig]</code> <p>Dictionary of undo configurations for each field.</p> <code>_undo_stacks</code> <code>dict[str, list[Callable[[], None]]]</code> <p>Dictionary of undo stacks for each field.</p> <code>_redo_stacks</code> <code>dict[str, list[Callable[[], None]]]</code> <p>Dictionary of redo stacks for each field.</p> <code>_last_change_times</code> <code>dict[str, float]</code> <p>Dictionary of last change times for each field.</p> <code>_pending_undo_groups</code> <code>dict[str, Callable[[], None] | None]</code> <p>Dictionary of pending undo groups for each field.</p> <code>_initial_values</code> <code>dict[str, Any]</code> <p>Dictionary of initial values for each field.</p> <p>Examples:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n    tags: list[str]\n\n# Create a user object\nuser = User(name=\"Alice\", age=30, tags=[\"developer\", \"python\"])\n\n# Create a proxy with automatic sync\nproxy = ObservableProxy(user, sync=True)\n\n# Get observables for fields\nname_obs = proxy.observable(str, \"name\")\nage_obs = proxy.observable(int, \"age\")\ntags_obs = proxy.observable_list(str, \"tags\")\n\n# Register change callbacks\nname_obs.on_change(lambda v: print(f\"Name changed to {v}\"))\n\n# Modify values through the observables\nname_obs.set(\"Bob\")  # Prints: \"Name changed to Bob\"\ntags_obs.append(\"observant\")\n\n# The original object is updated automatically with sync=True\nprint(user.name)  # Prints: \"Bob\"\nprint(user.tags)  # Prints: [\"developer\", \"python\", \"observant\"]\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>class ObservableProxy(Generic[T], IObservableProxy[T]):\n    \"\"\"\n    Proxy for a data object that exposes its fields as Observable, ObservableList, or ObservableDict.\n\n    ObservableProxy is the central class in the observant library, providing a reactive\n    interface to any Python object. It wraps a data object and exposes its fields as\n    observable properties that can be watched for changes.\n\n    Key features:\n    - Expose scalar fields as Observable objects\n    - Expose list fields as ObservableList objects\n    - Expose dictionary fields as ObservableDict objects\n    - Optional synchronization with the source model\n    - Validation with error tracking\n    - Computed properties that depend on other observables\n    - Undo/redo functionality with configurable history\n    - Change tracking (dirty state)\n\n    The proxy can be configured to automatically sync changes back to the source model,\n    or to require explicit saving. It also supports undo/redo functionality with\n    configurable history size and debounce timing.\n\n    Attributes:\n        _obj: The object being proxied.\n        _sync_default: Whether to sync changes back to the model by default.\n        _scalars: Dictionary of scalar observables.\n        _lists: Dictionary of list observables.\n        _dicts: Dictionary of dictionary observables.\n        _computeds: Dictionary of computed observables.\n        _dirty_fields: Set of field names that have been modified.\n        _validators: Dictionary of validator functions for each field.\n        _validation_errors_dict: Observable dictionary of validation errors.\n        _validation_for_cache: Cache of validation observables for each field.\n        _is_valid_obs: Observable indicating whether all fields are valid.\n        _default_undo_config: Default undo configuration.\n        _field_undo_configs: Dictionary of undo configurations for each field.\n        _undo_stacks: Dictionary of undo stacks for each field.\n        _redo_stacks: Dictionary of redo stacks for each field.\n        _last_change_times: Dictionary of last change times for each field.\n        _pending_undo_groups: Dictionary of pending undo groups for each field.\n        _initial_values: Dictionary of initial values for each field.\n\n    Examples:\n        ```python\n        from dataclasses import dataclass\n        from observant import ObservableProxy\n\n        @dataclass\n        class User:\n            name: str\n            age: int\n            tags: list[str]\n\n        # Create a user object\n        user = User(name=\"Alice\", age=30, tags=[\"developer\", \"python\"])\n\n        # Create a proxy with automatic sync\n        proxy = ObservableProxy(user, sync=True)\n\n        # Get observables for fields\n        name_obs = proxy.observable(str, \"name\")\n        age_obs = proxy.observable(int, \"age\")\n        tags_obs = proxy.observable_list(str, \"tags\")\n\n        # Register change callbacks\n        name_obs.on_change(lambda v: print(f\"Name changed to {v}\"))\n\n        # Modify values through the observables\n        name_obs.set(\"Bob\")  # Prints: \"Name changed to Bob\"\n        tags_obs.append(\"observant\")\n\n        # The original object is updated automatically with sync=True\n        print(user.name)  # Prints: \"Bob\"\n        print(user.tags)  # Prints: [\"developer\", \"python\", \"observant\"]\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        obj: T,\n        *,\n        sync: bool = False,\n        undo: bool = False,  # Undo is disabled by default\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a new ObservableProxy for a data object.\n\n        Creates a proxy that wraps a data object and exposes its fields as observable\n        properties. The proxy can be configured to automatically sync changes back to\n        the source model, or to require explicit saving.\n\n        Args:\n            obj: The object to proxy. This can be any Python object with attributes.\n            sync: If True, observables will sync back to the model immediately when changed.\n                 If False, changes must be saved explicitly using save_to().\n            undo: If True, enables undo/redo functionality for all fields.\n                 Individual fields can override this setting.\n            undo_max: Maximum number of undo steps to store per field.\n                     None means unlimited (though default is 100 if not specified).\n            undo_debounce_ms: Time window in milliseconds to group changes into a single undo step.\n                             None means no debouncing (every change is a separate undo step).\n\n        Examples:\n            ```python\n            # Create a proxy with no automatic sync\n            user = User(name=\"Alice\", age=30)\n            proxy = ObservableProxy(user)\n\n            # Create a proxy with automatic sync\n            settings = Settings(theme=\"dark\", font_size=12)\n            proxy = ObservableProxy(settings, sync=True)\n\n            # Create a proxy with undo/redo enabled\n            document = Document(title=\"Draft\", content=\"Hello world\")\n            proxy = ObservableProxy(document, undo=True, undo_max=50, undo_debounce_ms=500)\n            ```\n        \"\"\"\n        self._obj = obj\n        self._sync_default = sync\n\n        # Print a warning if sync and undo are both enabled\n        if sync and undo:\n            print(\"Warning: sync=True with undo=True may cause unexpected model mutations during undo/redo.\")\n\n        self._scalars: dict[ProxyFieldKey, Observable[Any]] = {}\n        self._lists: dict[ProxyFieldKey, ObservableList[Any]] = {}\n        self._dicts: dict[ProxyFieldKey, ObservableDict[Any, Any]] = {}\n        self._computeds: dict[str, Observable[Any]] = {}\n        self._dirty_fields: set[str] = set()\n\n        # Validation related fields\n        self._validators: dict[str, list[Callable[[Any], str | None]]] = {}\n        self._validation_errors_dict = ObservableDict[str, list[str]]({})\n        self._validation_for_cache: dict[str, Observable[list[str]]] = {}\n        self._is_valid_obs = Observable[bool](True)\n\n        # Undo/redo related fields\n        self._default_undo_config = UndoConfig(enabled=undo, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n        self._field_undo_configs: dict[str, UndoConfig] = {}\n        self._undo_stacks: dict[str, list[Callable[[], None]]] = {}\n        self._redo_stacks: dict[str, list[Callable[[], None]]] = {}\n        self._last_change_times: dict[str, float] = {}\n        self._pending_undo_groups: dict[str, Callable[[], None] | None] = {}\n        self._initial_values: dict[str, Any] = {}  # Store initial values for undo\n\n    @override\n    def observable(\n        self,\n        typ: type[TValue],\n        attr: str,\n        *,\n        sync: bool | None = None,\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; IObservable[TValue]:\n        \"\"\"\n        Get or create an Observable[T] for a scalar field.\n\n        Creates or returns an existing Observable for a scalar field of the proxied object.\n        The Observable allows watching for changes to the field value and modifying it.\n\n        Args:\n            typ: The type of the field.\n            attr: The field name.\n            sync: Whether to sync changes back to the model immediately.\n                 If None, uses the default sync setting from the proxy.\n            undo_max: Maximum number of undo steps to store. None means use the default.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n\n        Returns:\n            An Observable containing the field value.\n\n        Examples:\n            ```python\n            # Get an observable for a string field\n            name_obs = proxy.observable(str, \"name\")\n\n            # Register a callback\n            name_obs.on_change(lambda value: print(f\"Name changed to {value}\"))\n\n            # Get the current value\n            current_name = name_obs.get()\n\n            # Set a new value\n            name_obs.set(\"New Name\")\n            ```\n        \"\"\"\n        sync = self._sync_default if sync is None else sync\n        key = ProxyFieldKey(attr, sync)\n\n        # Set up undo config if provided\n        if undo_max is not None or undo_debounce_ms is not None:\n            self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n        # Get the initial value\n        val = getattr(self._obj, attr)\n\n        if key not in self._scalars:\n            # Create observable with callbacks disabled to prevent premature tracking\n            # obs = Observable(val, on_change_enabled=False)\n            obs = UndoableObservable(val, attr, self, on_change_enabled=False)\n\n            # Store the observable first so it can be found by _track_scalar_change\n            self._scalars[key] = obs\n\n            if sync:\n                obs.on_change(lambda v: setattr(self._obj, attr, v))\n            # Register dirty tracking callback\n            obs.on_change(lambda _: self._dirty_fields.add(attr))\n            # Register validation callback\n            obs.on_change(lambda v: self._validate_field(attr, v))\n            # Undo tracking is now handled by UndoableObservable\n\n            # Initial value tracking is now handled by UndoableObservable\n\n            # Now enable callbacks for future changes\n            obs.enable()\n        else:\n            # Get the existing observable\n            obs = self._scalars[key]\n\n        return self._scalars[key]\n\n    @override\n    def observable_list(\n        self,\n        typ: type[TValue],\n        attr: str,\n        *,\n        sync: bool | None = None,\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; IObservableList[TValue]:\n        \"\"\"\n        Get or create an ObservableList[T] for a list field.\n\n        Creates or returns an existing ObservableList for a list field of the proxied object.\n        The ObservableList provides the same interface as a regular Python list, but with\n        change notification capabilities.\n\n        Args:\n            typ: The type of the list elements.\n            attr: The field name.\n            sync: Whether to sync changes back to the model immediately.\n                 If None, uses the default sync setting from the proxy.\n            undo_max: Maximum number of undo steps to store. None means use the default.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n\n        Returns:\n            An ObservableList containing the field value.\n\n        Examples:\n            ```python\n            # Get an observable list for a tags field\n            tags_obs = proxy.observable_list(str, \"tags\")\n\n            # Register a callback\n            tags_obs.on_change(lambda change: print(f\"Tags changed: {change.type}\"))\n\n            # Modify the list\n            tags_obs.append(\"new_tag\")\n            tags_obs.remove(\"old_tag\")\n            ```\n        \"\"\"\n        sync = self._sync_default if sync is None else sync\n        key = ProxyFieldKey(attr, sync)\n\n        # Set up undo config if provided\n        if undo_max is not None or undo_debounce_ms is not None:\n            self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n        if key not in self._lists:\n            val_raw = getattr(self._obj, attr)\n            val: list[T] = cast(list[T], val_raw)\n            obs = ObservableList(val, copy=not sync)\n            if sync:\n                obs.on_change(lambda _: setattr(self._obj, attr, obs.copy()))\n            # Register dirty tracking callback\n            obs.on_change(lambda _: self._dirty_fields.add(attr))\n            # Register validation callback\n            obs.on_change(lambda _: self._validate_field(attr, obs.copy()))\n            # Register undo tracking callback\n            obs.on_change(lambda c: self._track_list_change(attr, c))\n            self._lists[key] = obs\n\n        return self._lists[key]\n\n    @override\n    def observable_dict(\n        self,\n        typ: tuple[type[TDictKey], type[TDictValue]],\n        attr: str,\n        *,\n        sync: bool | None = None,\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; IObservableDict[TDictKey, TDictValue]:\n        \"\"\"\n        Get or create an ObservableDict for a dict field.\n\n        Creates or returns an existing ObservableDict for a dictionary field of the proxied object.\n        The ObservableDict provides the same interface as a regular Python dictionary, but with\n        change notification capabilities.\n\n        Args:\n            typ: A tuple of (key_type, value_type) for the dictionary.\n            attr: The field name.\n            sync: Whether to sync changes back to the model immediately.\n                 If None, uses the default sync setting from the proxy.\n            undo_max: Maximum number of undo steps to store. None means use the default.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n\n        Returns:\n            An ObservableDict containing the field value.\n\n        Examples:\n            ```python\n            # Get an observable dict for a metadata field\n            metadata_obs = proxy.observable_dict((str, str), \"metadata\")\n\n            # Register a callback\n            metadata_obs.on_change(lambda change: print(f\"Metadata changed: {change.type}\"))\n\n            # Modify the dictionary\n            metadata_obs[\"author\"] = \"Alice\"\n            del metadata_obs[\"draft\"]\n            ```\n        \"\"\"\n        sync = self._sync_default if sync is None else sync\n        key = ProxyFieldKey(attr, sync)\n\n        # Set up undo config if provided\n        if undo_max is not None or undo_debounce_ms is not None:\n            self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n        if key not in self._dicts:\n            val_raw = getattr(self._obj, attr)\n            val: dict[Any, Any] = cast(dict[Any, Any], val_raw)\n            obs = ObservableDict(val, copy=not sync)\n            if sync:\n                obs.on_change(lambda _: setattr(self._obj, attr, obs.copy()))\n            # Register dirty tracking callback\n            obs.on_change(lambda _: self._dirty_fields.add(attr))\n            # Register validation callback\n            obs.on_change(lambda _: self._validate_field(attr, obs.copy()))\n            # Register undo tracking callback\n            obs.on_change(lambda c: self._track_dict_change(attr, c))\n            self._dicts[key] = obs\n\n        return self._dicts[key]\n\n    @override\n    def get(self) -&gt; T:\n        \"\"\"\n        Get the original object being proxied.\n        \"\"\"\n        return self._obj\n\n    @override\n    def update(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Set one or more scalar observable values.\n\n        This is a convenience method for setting multiple scalar values at once.\n        It creates observables for any fields that don't already have them.\n\n        Args:\n            **kwargs: Keyword arguments where each key is a field name and each value\n                     is the new value to set for that field.\n\n        Examples:\n            ```python\n            # Update multiple fields at once\n            proxy.update(name=\"Alice\", age=30, active=True)\n            ```\n        \"\"\"\n        for attr, value in kwargs.items():\n            self.observable(object, attr).set(value)\n\n    @override\n    def load_dict(self, values: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Set multiple scalar observable values from a dict.\n\n        This is similar to update(), but takes a dictionary instead of keyword arguments.\n        It creates observables for any fields that don't already have them.\n\n        Args:\n            values: A dictionary where each key is a field name and each value\n                   is the new value to set for that field.\n\n        Examples:\n            ```python\n            # Load values from a dictionary\n            data = {\"name\": \"Alice\", \"age\": 30, \"active\": True}\n            proxy.load_dict(data)\n            ```\n        \"\"\"\n        for attr, value in values.items():\n            self.observable(object, attr).set(value)\n\n    @override\n    def save_to(self, obj: T) -&gt; None:\n        \"\"\"\n        Write all observable values back into the given object.\n\n        This method copies all values from the observables back to the target object.\n        It's useful when sync=False and you want to explicitly save changes.\n\n        Args:\n            obj: The object to write values to. This can be the original object\n                 or a different object of the same type.\n\n        Examples:\n            ```python\n            # Create a proxy with no automatic sync\n            user = User(name=\"Alice\", age=30)\n            proxy = ObservableProxy(user)\n\n            # Make changes through the proxy\n            proxy.observable(str, \"name\").set(\"Bob\")\n\n            # At this point, user.name is still \"Alice\"\n            print(user.name)  # Prints: \"Alice\"\n\n            # Save changes back to the original object\n            proxy.save_to(user)\n            print(user.name)  # Prints: \"Bob\"\n\n            # Or save to a new object\n            new_user = User(name=\"\", age=0)\n            proxy.save_to(new_user)\n            print(new_user.name)  # Prints: \"Bob\"\n            ```\n        \"\"\"\n        for key, obs in self._scalars.items():\n            setattr(obj, key.attr, obs.get())\n\n        for key, obs in self._lists.items():\n            setattr(obj, key.attr, obs.copy())\n\n        for key, obs in self._dicts.items():\n            setattr(obj, key.attr, obs.copy())\n\n        # Save computed fields that shadow real fields\n        for name, obs in self._computeds.items():\n            try:\n                # Check if the target object has this field\n                getattr(obj, name)\n                # If we get here, the field exists, so save the computed value\n                setattr(obj, name, obs.get())\n            except (AttributeError, TypeError):\n                # Field doesn't exist in the target object, skip it\n                pass\n\n        # Reset dirty state after saving\n        self.reset_dirty()\n\n    @override\n    def is_dirty(self) -&gt; bool:\n        \"\"\"\n        Check if any fields have been modified since initialization or last reset.\n\n        This method returns True if any observable field has been modified since\n        the proxy was created or since the last call to reset_dirty().\n\n        Returns:\n            True if any fields have been modified, False otherwise.\n\n        Examples:\n            ```python\n            # Create a proxy\n            user = User(name=\"Alice\", age=30)\n            proxy = ObservableProxy(user)\n\n            # Check if dirty initially\n            print(proxy.is_dirty())  # Prints: False\n\n            # Make a change\n            proxy.observable(str, \"name\").set(\"Bob\")\n\n            # Check if dirty after change\n            print(proxy.is_dirty())  # Prints: True\n\n            # Reset dirty state\n            proxy.reset_dirty()\n\n            # Check if dirty after reset\n            print(proxy.is_dirty())  # Prints: False\n            ```\n        \"\"\"\n        return bool(self._dirty_fields)\n\n    @override\n    def dirty_fields(self) -&gt; set[str]:\n        \"\"\"\n        Get the set of field names that have been modified.\n\n        This method returns a set containing the names of all fields that have been\n        modified since the proxy was created or since the last call to reset_dirty().\n\n        Returns:\n            A set of field names that have been modified.\n\n        Examples:\n            ```python\n            # Create a proxy\n            user = User(name=\"Alice\", age=30, active=True)\n            proxy = ObservableProxy(user)\n\n            # Make some changes\n            proxy.observable(str, \"name\").set(\"Bob\")\n            proxy.observable(int, \"age\").set(31)\n\n            # Get the dirty fields\n            dirty = proxy.dirty_fields()\n            print(dirty)  # Prints: {'name', 'age'}\n            ```\n        \"\"\"\n        return set(self._dirty_fields)\n\n    @override\n    def reset_dirty(self) -&gt; None:\n        \"\"\"\n        Reset the dirty state of all fields.\n\n        This method clears the dirty state of all fields, marking them as clean.\n        It's typically called after saving changes back to the model.\n\n        Examples:\n            ```python\n            # Create a proxy\n            user = User(name=\"Alice\", age=30)\n            proxy = ObservableProxy(user)\n\n            # Make a change\n            proxy.observable(str, \"name\").set(\"Bob\")\n            print(proxy.is_dirty())  # Prints: True\n\n            # Reset dirty state\n            proxy.reset_dirty()\n            print(proxy.is_dirty())  # Prints: False\n            ```\n        \"\"\"\n        self._dirty_fields.clear()\n\n    @override\n    def register_computed(\n        self,\n        name: str,\n        compute: Callable[[], TValue],\n        dependencies: list[str],\n    ) -&gt; None:\n        \"\"\"\n        Register a computed property that depends on other observables.\n\n        Computed properties are read-only observables that automatically update\n        when their dependencies change. They can depend on scalar fields, list fields,\n        dictionary fields, or other computed properties.\n\n        Args:\n            name: The name of the computed property.\n            compute: A function that returns the computed value.\n            dependencies: List of field names that this computed property depends on.\n\n        Examples:\n            ```python\n            # Create a proxy for a user object\n            user = User(name=\"Alice\", age=30)\n            proxy = ObservableProxy(user)\n\n            # Register a computed property for the user's greeting\n            proxy.register_computed(\n                name=\"greeting\",\n                compute=lambda: f\"Hello, {proxy.observable(str, 'name').get()}!\",\n                dependencies=[\"name\"]\n            )\n\n            # Get the computed property\n            greeting_obs = proxy.computed(str, \"greeting\")\n            print(greeting_obs.get())  # Prints: \"Hello, Alice!\"\n\n            # When the name changes, the greeting updates automatically\n            proxy.observable(str, \"name\").set(\"Bob\")\n            print(greeting_obs.get())  # Prints: \"Hello, Bob!\"\n            ```\n        \"\"\"\n        # Create an observable for the computed property\n        initial_value = compute()\n        obs = Observable(initial_value)\n        self._computeds[name] = obs\n\n        # Register callbacks for each dependency\n        for dep in dependencies:\n            # For scalar dependencies\n            def update_computed(_: Any) -&gt; None:\n                new_value = compute()\n                current = obs.get()\n                if new_value != current:\n                    obs.set(new_value)\n\n            # Try to find the dependency in scalars, lists, or dicts\n            for sync in [True, False]:\n                key = ProxyFieldKey(dep, sync)\n\n                if key in self._scalars:\n                    self._scalars[key].on_change(update_computed)\n                    break\n\n                if key in self._lists:\n                    self._lists[key].on_change(update_computed)\n                    break\n\n                if key in self._dicts:\n                    self._dicts[key].on_change(update_computed)\n                    break\n\n            # Check if the dependency is another computed property\n            if dep in self._computeds:\n                self._computeds[dep].on_change(update_computed)\n\n        # Validate the computed property when it changes\n        def validate_computed(_: Any) -&gt; None:\n            value = compute()\n            self._validate_field(name, value)\n\n        obs.on_change(validate_computed)\n\n    @override\n    def computed(\n        self,\n        typ: type[TValue],\n        name: str,\n    ) -&gt; IObservable[TValue]:\n        \"\"\"\n        Get a computed property by name.\n\n        Args:\n            typ: The type of the computed property.\n            name: The name of the computed property.\n\n        Returns:\n            An observable containing the computed value.\n        \"\"\"\n        if name not in self._computeds:\n            raise KeyError(f\"Computed property '{name}' not found\")\n\n        return self._computeds[name]\n\n    @override\n    def add_validator(\n        self,\n        attr: str,\n        validator: Callable[[Any], str | None],\n    ) -&gt; None:\n        \"\"\"\n        Add a validator function for a field.\n\n        Validators are functions that check if a field value is valid.\n        Multiple validators can be added for the same field.\n        Validation errors are tracked and can be observed.\n\n        Args:\n            attr: The field name to validate.\n            validator: A function that takes the field value and returns an error message\n                       if invalid, or None if valid.\n\n        Examples:\n            ```python\n            # Create a proxy for a user object\n            user = User(name=\"Alice\", age=30)\n            proxy = ObservableProxy(user)\n\n            # Add validators for the name field\n            proxy.add_validator(\n                \"name\",\n                lambda name: \"Name cannot be empty\" if not name else None\n            )\n            proxy.add_validator(\n                \"name\",\n                lambda name: \"Name too long\" if len(name) &gt; 50 else None\n            )\n\n            # Add a validator for the age field\n            proxy.add_validator(\n                \"age\",\n                lambda age: \"Age must be positive\" if age &lt; 0 else None\n            )\n\n            # Check if all fields are valid\n            is_valid = proxy.is_valid()\n            print(is_valid.get())  # Prints: True\n\n            # Set an invalid value\n            proxy.observable(str, \"name\").set(\"\")\n            print(is_valid.get())  # Prints: False\n\n            # Get validation errors for a specific field\n            name_errors = proxy.validation_for(\"name\")\n            print(name_errors.get())  # Prints: [\"Name cannot be empty\"]\n            ```\n        \"\"\"\n        if attr not in self._validators:\n            self._validators[attr] = []\n\n        self._validators[attr].append(validator)\n\n        # Validate the current value if it exists\n        self._validate_field_if_exists(attr)\n\n    def _validate_field_if_exists(self, attr: str) -&gt; None:\n        \"\"\"\n        Validate a field if it exists in any of the observable collections.\n\n        This method attempts to find the field in scalars, lists, or dicts collections,\n        and if found, validates it. If the field is not found in any observable collection,\n        it tries to get the value directly from the proxied object.\n\n        Args:\n            attr: The field name to validate.\n\n        Note:\n            This method is primarily used internally by the ObservableProxy class.\n            Users typically don't need to call this method directly.\n        \"\"\"\n        # Check in scalars\n        for key in self._scalars:\n            if key.attr == attr:\n                value = self._scalars[key].get()\n                self._validate_field(attr, value)\n                return\n\n        # Check in lists\n        for key in self._lists:\n            if key.attr == attr:\n                value = self._lists[key].copy()\n                self._validate_field(attr, value)\n                return\n\n        # Check in dicts\n        for key in self._dicts:\n            if key.attr == attr:\n                value = self._dicts[key].copy()\n                self._validate_field(attr, value)\n                return\n\n        # If we get here, the field doesn't exist in any observable collection yet\n        # Try to get it directly from the object\n        try:\n            value = getattr(self._obj, attr)\n            self._validate_field(attr, value)\n        except (AttributeError, TypeError):\n            # If we can't get the value, we can't validate it yet\n            pass\n\n    def _validate_field(self, attr: str, value: Any) -&gt; None:\n        \"\"\"\n        Validate a field value against all its validators.\n\n        Args:\n            attr: The field name.\n            value: The value to validate.\n        \"\"\"\n        if attr not in self._validators:\n            # No validators for this field, it's always valid\n            if attr in self._validation_errors_dict:\n                del self._validation_errors_dict[attr]\n            return\n\n        errors: list[str] = []\n\n        for validator in self._validators[attr]:\n            try:\n                result = validator(value)\n                if result is not None:\n                    errors.append(result)\n            except Exception as e:\n                errors.append(f\"Validation error: {str(e)}\")\n\n        if errors:\n            self._validation_errors_dict[attr] = errors\n        elif attr in self._validation_errors_dict:\n            del self._validation_errors_dict[attr]\n\n        # Update the is_valid observable\n        self._is_valid_obs.set(len(self._validation_errors_dict) == 0)\n\n    @override\n    def is_valid(self) -&gt; IObservable[bool]:\n        \"\"\"\n        Get an observable that indicates whether all fields are valid.\n\n        This method returns an observable that emits True if all fields are valid\n        according to their validators, and False if any field has validation errors.\n        The observable updates automatically when field values change.\n\n        Returns:\n            An observable that emits True if all fields are valid, False otherwise.\n\n        Examples:\n            ```python\n            # Create a proxy with validation\n            user = User(name=\"Alice\", age=30)\n            proxy = ObservableProxy(user)\n\n            # Add a validator\n            proxy.add_validator(\"age\", lambda age: \"Age must be positive\" if age &lt; 0 else None)\n\n            # Get the is_valid observable\n            is_valid = proxy.is_valid()\n\n            # Register a callback\n            is_valid.on_change(lambda valid: print(f\"Form is valid: {valid}\"))\n\n            # Initially valid\n            print(is_valid.get())  # Prints: True\n\n            # Make an invalid change\n            proxy.observable(int, \"age\").set(-5)  # Prints: \"Form is valid: False\"\n            ```\n        \"\"\"\n        return self._is_valid_obs\n\n    @override\n    def validation_errors(self) -&gt; IObservableDict[str, list[str]]:\n        \"\"\"\n        Get an observable dictionary of validation errors.\n\n        This method returns an observable dictionary that maps field names to lists\n        of error messages. The dictionary is updated automatically when field values\n        change and validation is performed.\n\n        Returns:\n            An observable dictionary mapping field names to lists of error messages.\n            Fields with no errors are not included in the dictionary.\n\n        Examples:\n            ```python\n            # Create a proxy with validation\n            user = User(name=\"\", age=-5)\n            proxy = ObservableProxy(user)\n\n            # Add validators\n            proxy.add_validator(\"name\", lambda name: \"Name cannot be empty\" if not name else None)\n            proxy.add_validator(\"age\", lambda age: \"Age must be positive\" if age &lt; 0 else None)\n\n            # Get validation errors\n            errors = proxy.validation_errors()\n            print(dict(errors))  # Prints: {'name': ['Name cannot be empty'], 'age': ['Age must be positive']}\n\n            # Fix one error\n            proxy.observable(str, \"name\").set(\"Alice\")\n            print(dict(errors))  # Prints: {'age': ['Age must be positive']}\n            ```\n        \"\"\"\n        return self._validation_errors_dict\n\n    @override\n    def validation_for(self, attr: str) -&gt; IObservable[list[str]]:\n        \"\"\"\n        Get an observable list of validation errors for a specific field.\n\n        This method returns an observable that emits a list of error messages for\n        the specified field. The observable updates automatically when the field\n        value changes and validation is performed.\n\n        Args:\n            attr: The field name to get validation errors for.\n\n        Returns:\n            An observable that emits a list of error messages for the field.\n            An empty list means the field is valid.\n\n        Examples:\n            ```python\n            # Create a proxy with validation\n            user = User(name=\"\", age=30)\n            proxy = ObservableProxy(user)\n\n            # Add validators for the name field\n            proxy.add_validator(\"name\", lambda name: \"Name cannot be empty\" if not name else None)\n            proxy.add_validator(\"name\", lambda name: \"Name too long\" if len(name) &gt; 50 else None)\n\n            # Get validation errors for the name field\n            name_errors = proxy.validation_for(\"name\")\n            print(name_errors.get())  # Prints: ['Name cannot be empty']\n\n            # Fix the error\n            proxy.observable(str, \"name\").set(\"Alice\")\n            print(name_errors.get())  # Prints: []\n            ```\n        \"\"\"\n        if attr not in self._validation_for_cache:\n            # Create a computed observable that depends on the validation errors dict\n            initial_value = self._validation_errors_dict.get(attr) or []\n            obs = Observable[list[str]](initial_value)\n\n            # Update the observable when the validation errors dict changes\n            def update_validation(_: Any) -&gt; None:\n                new_value = self._validation_errors_dict.get(attr) or []\n                current = obs.get()\n                if new_value != current:\n                    obs.set(new_value)\n\n            self._validation_errors_dict.on_change(update_validation)\n            self._validation_for_cache[attr] = obs\n\n        return self._validation_for_cache[attr]\n\n    @override\n    def reset_validation(self, attr: str | None = None, *, revalidate: bool = False) -&gt; None:\n        \"\"\"\n        Reset validation errors for a specific field or all fields.\n\n        This method clears validation errors for the specified field or all fields.\n        It can optionally re-run validators after clearing errors.\n\n        Args:\n            attr: The field name to reset validation for. If None, reset all fields.\n            revalidate: Whether to re-run validators after clearing errors.\n                       If True, validators will be run on the current field values.\n                       If False, fields will be marked as valid until the next change.\n\n        Examples:\n            ```python\n            # Create a proxy with validation\n            user = User(name=\"\", age=-5)\n            proxy = ObservableProxy(user)\n\n            # Add validators\n            proxy.add_validator(\"name\", lambda name: \"Name cannot be empty\" if not name else None)\n            proxy.add_validator(\"age\", lambda age: \"Age must be positive\" if age &lt; 0 else None)\n\n            # Check validation initially\n            print(proxy.is_valid().get())  # Prints: False\n\n            # Reset validation for all fields without revalidating\n            proxy.reset_validation()\n            print(proxy.is_valid().get())  # Prints: True\n\n            # Reset validation for all fields with revalidation\n            proxy.reset_validation(revalidate=True)\n            print(proxy.is_valid().get())  # Prints: False\n\n            # Reset validation for just the name field\n            proxy.reset_validation(\"name\")\n            print(proxy.validation_for(\"name\").get())  # Prints: []\n            print(proxy.validation_for(\"age\").get())   # Prints: ['Age must be positive']\n            ```\n        \"\"\"\n        if attr is None:\n            # Reset all validation errors\n            self._validation_errors_dict.clear()\n            # Update the is_valid observable\n            self._is_valid_obs.set(True)\n\n            # Re-run all validators if requested\n            if revalidate:\n                for field_name in self._validators.keys():\n                    self._validate_field_if_exists(field_name)\n        else:\n            # Reset validation errors for a specific field\n            if attr in self._validation_errors_dict:\n                del self._validation_errors_dict[attr]\n                # Update the is_valid observable\n                self._is_valid_obs.set(len(self._validation_errors_dict) == 0)\n\n            # Re-run validator for this field if requested\n            if revalidate:\n                self._validate_field_if_exists(attr)\n\n    @override\n    def set_undo_config(\n        self,\n        attr: str,\n        *,\n        enabled: bool | None = None,\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Set the undo configuration for a specific field.\n\n        This method allows configuring undo/redo behavior for individual fields.\n        Each field can have its own undo history size and debounce timing.\n\n        Args:\n            attr: The field name to configure.\n            enabled: Whether undo/redo functionality is enabled for this field.\n                    If None, uses the default from the proxy.\n            undo_max: Maximum number of undo steps to store. None means use the default.\n                     A value of 0 means no limit.\n            undo_debounce_ms: Time window in milliseconds to group changes into a single undo step.\n                             None means use the default. A value of 0 means no debouncing.\n\n        Examples:\n            ```python\n            # Create a proxy with undo enabled\n            document = Document(title=\"Draft\", content=\"Hello world\")\n            proxy = ObservableProxy(document, undo=True)\n\n            # Configure undo for the content field\n            proxy.set_undo_config(\n                \"content\",\n                undo_max=100,       # Store up to 100 undo steps\n                undo_debounce_ms=500  # Group changes within 500ms\n            )\n\n            # Disable undo for the title field\n            proxy.set_undo_config(\"title\", enabled=False)\n            ```\n        \"\"\"\n        # Get the current config or create a new one\n        config = self._field_undo_configs.get(attr, UndoConfig())\n\n        # Update the config with the provided values\n        if enabled is not None:\n            config.enabled = enabled\n        elif attr not in self._field_undo_configs:\n            # If this is a new config and enabled wasn't specified, inherit from default\n            config.enabled = self._default_undo_config.enabled\n\n        if undo_max is not None:\n            config.undo_max = undo_max\n        if undo_debounce_ms is not None:\n            config.undo_debounce_ms = undo_debounce_ms\n\n        # Store the updated config\n        self._field_undo_configs[attr] = config\n\n        # Enforce the max size if it's been reduced\n        if attr in self._undo_stacks and config.undo_max is not None:\n            while len(self._undo_stacks[attr]) &gt; config.undo_max:\n                self._undo_stacks[attr].pop(0)\n\n    def _get_undo_config(self, attr: str) -&gt; UndoConfig:\n        \"\"\"\n        Get the undo configuration for a field.\n\n        Args:\n            attr: The field name.\n\n        Returns:\n            The undo configuration for the field, or the default if not set.\n        \"\"\"\n        config = self._field_undo_configs.get(attr, self._default_undo_config)\n\n        # If undo_max is None, use the default from UndoConfig\n        if config.undo_max is None:\n            from observant.types.undo_config import UndoConfig as DefaultUndoConfig\n\n            config.undo_max = DefaultUndoConfig.undo_max\n\n        # Make sure the enabled flag is set correctly\n        # If this is a field-specific config, check if it has an explicit enabled flag\n        if attr in self._field_undo_configs:\n            # If the field has a specific config but no explicit enabled flag,\n            # inherit from the default config\n            if not hasattr(config, \"enabled\"):\n                config.enabled = self._default_undo_config.enabled\n\n        return config\n\n    # _track_scalar_change has been removed - UndoableObservable now handles this\n\n    def _track_list_change(self, attr: str, change: Any) -&gt; None:\n        \"\"\"\n        Track a change to a list field for undo/redo.\n\n        This method is called when a list field is modified. It creates undo and redo\n        functions based on the type of change (add, remove, clear) and adds them to\n        the undo stack.\n\n        Args:\n            attr: The field name.\n            change: The change object containing details about the modification.\n\n        Note:\n            This method is primarily used internally by the ObservableProxy class.\n            Users typically don't need to call this method directly.\n        \"\"\"\n        # Get the observable for this field\n        obs = None\n        for key, o in self._lists.items():\n            if key.attr == attr:\n                obs = o\n                break\n\n        if obs is None:\n            return  # Field not found\n\n        # Create a flag to prevent recursive tracking\n        tracking_enabled = [True]\n\n        # We don't need a tracking function here since it's already registered\n        # when the observable_list is created\n\n        # We don't need to add a new tracking callback here\n        # The callback is already registered when the observable_list is created\n\n        # Helper function to temporarily disable tracking\n        def with_tracking_disabled(action: Callable[[], None]) -&gt; None:\n            print(f\"DEBUG: with_tracking_disabled - Disabling tracking for {attr}\")\n            # Disable tracking during this operation\n            tracking_enabled[0] = False\n            # Perform the action\n            print(\"DEBUG: with_tracking_disabled - Executing action\")\n            action()\n            print(\"DEBUG: with_tracking_disabled - Action executed\")\n            # Re-enable tracking\n            tracking_enabled[0] = True\n            print(f\"DEBUG: with_tracking_disabled - Tracking re-enabled for {attr}\")\n\n        # Create undo/redo functions based on the change type\n        if hasattr(change, \"type\") and change.type == ObservableCollectionChangeType.CLEAR:\n            # This is a clear operation\n            old_items = change.items\n\n            def undo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs.extend(old_items)\n\n                with_tracking_disabled(action)\n\n            def redo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs.clear()\n\n                with_tracking_disabled(action)\n\n        elif hasattr(change, \"index\") and hasattr(change, \"item\"):\n            # This could be an append/insert or a remove operation\n            index = change.index\n            item = change.item\n\n            if change.type == ObservableCollectionChangeType.ADD:\n                # This is an append or insert\n                def undo_func() -&gt; None:\n                    def action() -&gt; None:\n                        if index is not None and index &lt; len(obs):  # Check if index is valid\n                            obs.pop(index)\n\n                    with_tracking_disabled(action)\n\n                def redo_func() -&gt; None:\n                    def action() -&gt; None:\n                        if index is not None:\n                            obs.insert(index, item)\n                        else:\n                            obs.append(item)\n\n                    with_tracking_disabled(action)\n            else:\n                # This is a remove operation\n                def undo_func() -&gt; None:\n                    def action() -&gt; None:\n                        if index is not None:\n                            obs.insert(index, item)\n                        else:\n                            obs.append(item)\n\n                    with_tracking_disabled(action)\n\n                def redo_func() -&gt; None:\n                    def action() -&gt; None:\n                        if index is not None and index &lt; len(obs):  # Check if index is valid\n                            obs.pop(index)\n\n                    with_tracking_disabled(action)\n\n        else:\n            # Unknown change type\n            return\n\n        # Add to the undo stack\n        self._add_to_undo_stack(attr, undo_func, redo_func, from_undo=True)\n\n    def _track_dict_change(self, attr: str, change: Any) -&gt; None:\n        \"\"\"\n        Track a change to a dict field for undo/redo.\n\n        This method is called when a dictionary field is modified. It creates undo and redo\n        functions based on the type of change (add, update, remove, clear) and adds them to\n        the undo stack.\n\n        Args:\n            attr: The field name.\n            change: The change object containing details about the modification.\n\n        Note:\n            This method is primarily used internally by the ObservableProxy class.\n            Users typically don't need to call this method directly.\n        \"\"\"\n        # Get the observable for this field\n        obs = None\n        for key, o in self._dicts.items():\n            if key.attr == attr:\n                obs = o\n                break\n\n        if obs is None:\n            return  # Field not found\n\n        # Create a flag to prevent recursive tracking\n        tracking_enabled = [True]\n\n        # We don't need a tracking function here since it's already registered\n        # when the observable_dict is created\n\n        # We don't need to add a new tracking callback here\n        # The callback is already registered when the observable_dict is created\n\n        # Helper function to temporarily disable tracking\n        def with_tracking_disabled(action: Callable[[], None]) -&gt; None:\n            print(f\"DEBUG: dict with_tracking_disabled - Disabling tracking for {attr}\")\n            # Disable tracking during this operation\n            tracking_enabled[0] = False\n            # Perform the action\n            print(\"DEBUG: dict with_tracking_disabled - Executing action\")\n            action()\n            print(\"DEBUG: dict with_tracking_disabled - Action executed\")\n            # Re-enable tracking\n            tracking_enabled[0] = True\n            print(f\"DEBUG: dict with_tracking_disabled - Tracking re-enabled for {attr}\")\n\n        # Create undo/redo functions based on the change type\n        if hasattr(change, \"key\") and hasattr(change, \"value\") and hasattr(change, \"old_value\"):\n            # This is a key update\n            dict_key = change.key\n            value = change.value\n            old_value = change.old_value\n\n            def undo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs[dict_key] = old_value\n\n                with_tracking_disabled(action)\n\n            def redo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs[dict_key] = value\n\n                with_tracking_disabled(action)\n\n        elif hasattr(change, \"key\") and hasattr(change, \"value\") and not hasattr(change, \"old_value\"):\n            # This is a new key\n            dict_key = change.key\n            value = change.value\n\n            def undo_func() -&gt; None:\n                def action() -&gt; None:\n                    if dict_key in obs:  # Check if key exists\n                        del obs[dict_key]\n\n                with_tracking_disabled(action)\n\n            def redo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs[dict_key] = value\n\n                with_tracking_disabled(action)\n\n        elif hasattr(change, \"key\") and hasattr(change, \"value\") and change.type == ObservableCollectionChangeType.REMOVE:\n            # This is a key deletion\n            dict_key = change.key\n            old_value = change.value\n\n            print(f\"DEBUG: _track_dict_change - Creating undo/redo functions for key deletion: {dict_key}={old_value}\")\n\n            def undo_func() -&gt; None:\n                print(f\"DEBUG: dict undo_func - Starting undo for key {dict_key}\")\n                print(f\"DEBUG: dict undo_func - Observable dict: {obs}\")\n                print(f\"DEBUG: dict undo_func - Observable dict keys: {list(obs.keys())}\")\n                print(f\"DEBUG: dict undo_func - Setting key {dict_key} to value {old_value}\")\n\n                # Directly set the key in the dictionary\n                obs[dict_key] = old_value\n\n                print(f\"DEBUG: dict undo_func - After restore, keys: {list(obs.keys())}\")\n                print(f\"DEBUG: dict undo_func - Completed undo for key {dict_key}\")\n\n            def redo_func() -&gt; None:\n                print(f\"DEBUG: dict redo_func - Starting redo for key {dict_key}\")\n                print(f\"DEBUG: dict redo_func - Observable dict: {obs}\")\n                print(f\"DEBUG: dict redo_func - Observable dict keys: {list(obs.keys())}\")\n                print(f\"DEBUG: dict redo_func - Deleting key {dict_key}\")\n\n                # Directly delete the key without using the action function\n                if dict_key in obs:  # Check if key exists\n                    del obs[dict_key]\n\n                print(f\"DEBUG: dict redo_func - After delete, keys: {list(obs.keys())}\")\n                print(f\"DEBUG: dict redo_func - Completed redo for key {dict_key}\")\n\n        elif hasattr(change, \"old_items\"):\n            # This is a clear\n            old_items = change.old_items\n\n            def undo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs.update(old_items)\n\n                with_tracking_disabled(action)\n\n            def redo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs.clear()\n\n                with_tracking_disabled(action)\n\n        else:\n            # Unknown change type\n            return\n\n        # Add to the undo stack\n        self._add_to_undo_stack(attr, undo_func, redo_func, from_undo=True)\n\n    def _add_to_undo_stack(self, attr: str, undo_func: Callable[[], None], redo_func: Callable[[], None], from_undo: bool = False) -&gt; None:\n        \"\"\"\n        Add an undo/redo pair to the undo stack for a field.\n\n        This method manages the undo and redo stacks for a field. It handles debouncing\n        (grouping changes within a time window), enforces maximum stack size, and\n        manages the pending undo groups.\n\n        Args:\n            attr: The field name.\n            undo_func: The function to call to undo the change.\n            redo_func: The function to call to redo the change.\n            from_undo: Whether this is being called from the undo method.\n\n        Note:\n            This method is primarily used internally by the ObservableProxy class.\n            Users typically don't need to call this method directly.\n        \"\"\"\n        print(f\"DEBUG: _add_to_undo_stack called for {attr}, from_undo={from_undo}\")\n\n        # Initialize stacks if they don't exist\n        if attr not in self._undo_stacks:\n            self._undo_stacks[attr] = []\n            print(f\"DEBUG: _add_to_undo_stack - Initialized undo stack for {attr}\")\n        if attr not in self._redo_stacks:\n            self._redo_stacks[attr] = []\n            print(f\"DEBUG: _add_to_undo_stack - Initialized redo stack for {attr}\")\n\n        # Get the undo config for this field\n        config = self._get_undo_config(attr)\n        print(f\"DEBUG: _add_to_undo_stack - Got undo config for {attr}: undo_max={config.undo_max}, undo_debounce_ms={config.undo_debounce_ms}\")\n\n        # Check if we should debounce this change\n        now = time.monotonic() * 1000  # Convert to milliseconds\n        last_change_time = self._last_change_times.get(attr, 0)\n        debounce_window = config.undo_debounce_ms\n        time_since_last_change = now - last_change_time\n\n        print(f\"DEBUG: _add_to_undo_stack - now={now}, last_change_time={last_change_time}, time_since_last_change={time_since_last_change}ms, debounce_window={debounce_window}ms\")\n        print(f\"DEBUG: _add_to_undo_stack - pending_undo_groups for {attr}: {attr in self._pending_undo_groups}\")\n        if attr in self._pending_undo_groups:\n            print(f\"DEBUG: _add_to_undo_stack - pending_undo_groups[{attr}] is None: {self._pending_undo_groups[attr] is None}\")\n\n        if debounce_window is not None and attr in self._pending_undo_groups and self._pending_undo_groups[attr] is not None and time_since_last_change &lt; debounce_window:\n            # We're within the debounce window, update the pending group\n            # The pending group is the redo function from the previous change\n            # We replace it with the new redo function\n            print(f\"DEBUG: _add_to_undo_stack - Within debounce window, updating pending group for {attr}\")\n            self._pending_undo_groups[attr] = redo_func\n        else:\n            # We're outside the debounce window or there's no pending group\n            print(f\"DEBUG: _add_to_undo_stack - Outside debounce window or no pending group for {attr}\")\n\n            # Clear the redo stack when a new change is made, but not if we're undoing\n            if not from_undo:\n                self._redo_stacks[attr].clear()\n                print(f\"DEBUG: _add_to_undo_stack - Cleared redo stack for {attr}\")\n\n            # Add the undo function to the stack\n            self._undo_stacks[attr].append(undo_func)\n            print(f\"DEBUG: _add_to_undo_stack - Added undo function to stack for {attr}, stack size: {len(self._undo_stacks[attr])}\")\n\n            # Enforce the max size\n            if config.undo_max is not None:\n                while len(self._undo_stacks[attr]) &gt; config.undo_max:\n                    self._undo_stacks[attr].pop(0)\n                    print(f\"DEBUG: _add_to_undo_stack - Enforced max size for {attr}, removed oldest undo function\")\n\n            # Set the pending group\n            self._pending_undo_groups[attr] = redo_func\n            print(f\"DEBUG: _add_to_undo_stack - Set pending group for {attr}\")\n\n        # Update the last change time\n        self._last_change_times[attr] = now\n        print(f\"DEBUG: _add_to_undo_stack - Updated last change time for {attr} to {now}\")\n        print(f\"DEBUG: _add_to_undo_stack - Completed for {attr}\")\n\n    @override\n    def undo(self, attr: str) -&gt; None:\n        \"\"\"\n        Undo the most recent change to a field.\n\n        This method reverts the most recent change to the specified field by\n        popping the top function from the undo stack and executing it. If the\n        field has no changes to undo, this method does nothing.\n\n        Args:\n            attr: The field name to undo changes for.\n\n        Examples:\n            ```python\n            # Create a proxy with undo enabled\n            document = Document(title=\"Draft\", content=\"Hello\")\n            proxy = ObservableProxy(document, undo=True)\n\n            # Make some changes\n            proxy.observable(str, \"content\").set(\"Hello world\")\n            proxy.observable(str, \"content\").set(\"Hello world!\")\n\n            # Undo the last change\n            proxy.undo(\"content\")  # Content is now \"Hello world\"\n\n            # Undo again\n            proxy.undo(\"content\")  # Content is now \"Hello\"\n            ```\n        \"\"\"\n        print(f\"DEBUG: undo called for {attr}\")\n\n        if attr not in self._undo_stacks or not self._undo_stacks[attr]:\n            print(f\"DEBUG: undo - Nothing to undo for {attr}\")\n            return  # Nothing to undo\n\n        # Pop the most recent undo function\n        undo_func = self._undo_stacks[attr].pop()\n        print(f\"DEBUG: undo - Popped undo function from stack for {attr}, remaining: {len(self._undo_stacks[attr])}\")\n\n        # Get the pending redo function\n        redo_func = self._pending_undo_groups.get(attr)\n        print(f\"DEBUG: undo - Got pending redo function for {attr}: {redo_func is not None}\")\n\n        # Add to the redo stack if it exists\n        if redo_func is not None:\n            self._redo_stacks[attr].append(redo_func)\n            print(f\"DEBUG: undo - Added redo function to stack for {attr}\")\n            self._pending_undo_groups[attr] = None\n            print(f\"DEBUG: undo - Cleared pending undo group for {attr}\")\n\n        # Find the observable for this field to set the undoing flag\n        obs = None\n        for key, o in self._scalars.items():\n            if key.attr == attr:\n                obs = o\n                break\n\n        # Execute the undo function with undoing flag set\n        print(f\"DEBUG: undo - Executing undo function for {attr}\")\n        print(f\"DEBUG: undo - undo_func: {undo_func}\")\n\n        # Set the undoing flag if we found the observable and it's a UndoableObservable\n        from observant.undoable_observable import UndoableObservable\n\n        if obs is not None and isinstance(obs, UndoableObservable):\n            obs.set_undoing(True)\n\n        try:\n            undo_func()\n        finally:\n            # Reset the undoing flag\n            if obs is not None and isinstance(obs, UndoableObservable):\n                obs.set_undoing(False)\n\n        print(f\"DEBUG: undo - Completed for {attr}\")\n\n        # If sync is enabled for this field, update the model\n        for key in self._scalars:\n            if key.attr == attr and key.sync:\n                value = self._scalars[key].get()\n                setattr(self._obj, attr, value)\n                print(f\"DEBUG: undo - Synced {attr} to model with value {value}\")\n                break\n\n    @override\n    def redo(self, attr: str) -&gt; None:\n        \"\"\"\n        Redo the most recently undone change to a field.\n\n        This method reapplies the most recently undone change to the specified field\n        by popping the top function from the redo stack and executing it. If the\n        field has no changes to redo, this method does nothing.\n\n        Args:\n            attr: The field name to redo changes for.\n\n        Examples:\n            ```python\n            # Create a proxy with undo enabled\n            document = Document(title=\"Draft\", content=\"Hello\")\n            proxy = ObservableProxy(document, undo=True)\n\n            # Make a change\n            proxy.observable(str, \"content\").set(\"Hello world\")\n\n            # Undo the change\n            proxy.undo(\"content\")  # Content is now \"Hello\"\n\n            # Redo the change\n            proxy.redo(\"content\")  # Content is now \"Hello world\" again\n            ```\n        \"\"\"\n        print(f\"DEBUG: redo called for {attr}\")\n        if attr not in self._redo_stacks or not self._redo_stacks[attr]:\n            print(f\"DEBUG: redo - Nothing to redo for {attr}\")\n            return  # Nothing to redo\n\n        # Pop the most recent redo function\n        redo_func = self._redo_stacks[attr].pop()\n        print(f\"DEBUG: redo - Popped redo function from stack for {attr}, remaining: {len(self._redo_stacks[attr])}\")\n\n        # Get the undo function that will undo this redo operation\n        # This is the function that was popped from the undo stack when undo was called\n        undo_func = None\n        if attr in self._pending_undo_groups:\n            undo_func = self._pending_undo_groups[attr]\n            print(f\"DEBUG: redo - Got pending undo function for {attr}: {undo_func is not None}\")\n\n        # Find the observable for this field to manually track changes\n        # We need to do this because the redo function disables tracking\n        obs_list = None\n        obs_dict = None\n\n        # Check if this is a list field\n        for key, o in self._lists.items():\n            if key.attr == attr:\n                obs_list = o\n                print(f\"DEBUG: redo - Found list observable for {attr}\")\n                break\n\n        # Check if this is a dict field\n        if obs_list is None:\n            for key, o in self._dicts.items():\n                if key.attr == attr:\n                    obs_dict = o\n                    print(f\"DEBUG: redo - Found dict observable for {attr}\")\n                    break\n\n        # We don't need to simulate change objects anymore\n\n        # Find the scalar observable for this field to set the undoing flag\n        obs_scalar = None\n        for key, o in self._scalars.items():\n            if key.attr == attr:\n                obs_scalar = o\n                break\n\n        # Execute the redo function with undoing flag set\n        print(f\"DEBUG: redo - Executing redo function for {attr}\")\n\n        # Set the undoing flag if we found the observable and it's a UndoableObservable\n        from observant.undoable_observable import UndoableObservable\n\n        if obs_scalar is not None and isinstance(obs_scalar, UndoableObservable):\n            obs_scalar.set_undoing(True)\n\n        try:\n            redo_func()\n        finally:\n            # Reset the undoing flag\n            if obs_scalar is not None and isinstance(obs_scalar, UndoableObservable):\n                obs_scalar.set_undoing(False)\n\n        print(f\"DEBUG: redo - Redo function executed for {attr}\")\n\n        # Add the undo function back to the undo stack\n        # This is necessary because the redo function disables tracking\n        if undo_func is not None:\n            self._undo_stacks.setdefault(attr, []).append(undo_func)\n            print(f\"DEBUG: redo - Added undo function back to stack for {attr}, stack size: {len(self._undo_stacks[attr])}\")\n            # Clear the pending undo group since we've used it\n            self._pending_undo_groups[attr] = None\n            print(f\"DEBUG: redo - Cleared pending undo group for {attr}\")\n        else:\n            # If we don't have an undo function from the pending group,\n            # we need to create one based on the current state\n            print(\"DEBUG: redo - No pending undo function, creating one\")\n\n            # For scalar fields\n            for key, o in self._scalars.items():\n                if key.attr == attr:\n                    # Create an undo function that will restore the current value\n                    current_value = o.get()\n\n                    def new_undo_func() -&gt; None:\n                        print(f\"DEBUG: new_undo_func called for {attr}\")\n                        o.set(current_value, notify=False)\n                        print(f\"DEBUG: new_undo_func completed for {attr}\")\n\n                    # Add it to the undo stack\n                    self._undo_stacks.setdefault(attr, []).append(new_undo_func)\n                    print(f\"DEBUG: redo - Created and added new undo function for scalar {attr}\")\n                    break\n\n            # For list fields\n            if obs_list is not None:\n                # Create an undo function that will restore the current list state\n                current_list = obs_list.copy()\n\n                def new_list_undo_func() -&gt; None:\n                    print(f\"DEBUG: new_list_undo_func called for {attr}\")\n                    # Clear the list and add all items back\n                    obs_list.clear()\n                    obs_list.extend(current_list)\n                    print(f\"DEBUG: new_list_undo_func completed for {attr}\")\n\n                # Add it to the undo stack\n                self._undo_stacks.setdefault(attr, []).append(new_list_undo_func)\n                print(f\"DEBUG: redo - Created and added new undo function for list {attr}\")\n\n            # For dict fields\n            if obs_dict is not None:\n                # Create an undo function that will restore the current dict state\n                current_dict = obs_dict.copy()\n\n                def new_dict_undo_func() -&gt; None:\n                    print(f\"DEBUG: new_dict_undo_func called for {attr}\")\n                    # Clear the dict and add all items back\n                    obs_dict.clear()\n                    obs_dict.update(current_dict)\n                    print(f\"DEBUG: new_dict_undo_func completed for {attr}\")\n\n                # Add it to the undo stack\n                self._undo_stacks.setdefault(attr, []).append(new_dict_undo_func)\n                print(f\"DEBUG: redo - Created and added new undo function for dict {attr}\")\n\n        print(f\"DEBUG: redo - Completed for {attr}\")\n\n        # If sync is enabled for this field, update the model\n        for key in self._scalars:\n            if key.attr == attr and key.sync:\n                value = self._scalars[key].get()\n                setattr(self._obj, attr, value)\n                print(f\"DEBUG: redo - Synced {attr} to model with value {value}\")\n                break\n\n    @override\n    def can_undo(self, attr: str) -&gt; bool:\n        \"\"\"\n        Check if there are changes that can be undone for a field.\n\n        This method returns True if there are changes in the undo stack for the\n        specified field, and False otherwise.\n\n        Args:\n            attr: The field name to check.\n\n        Returns:\n            True if there are changes that can be undone, False otherwise.\n\n        Examples:\n            ```python\n            # Create a proxy with undo enabled\n            document = Document(title=\"Draft\", content=\"Hello\")\n            proxy = ObservableProxy(document, undo=True)\n\n            # Check if we can undo initially\n            print(proxy.can_undo(\"content\"))  # Prints: False\n\n            # Make a change\n            proxy.observable(str, \"content\").set(\"Hello world\")\n\n            # Check if we can undo after change\n            print(proxy.can_undo(\"content\"))  # Prints: True\n\n            # Undo the change\n            proxy.undo(\"content\")\n\n            # Check if we can undo after undoing\n            print(proxy.can_undo(\"content\"))  # Prints: False\n            ```\n        \"\"\"\n        return attr in self._undo_stacks and bool(self._undo_stacks[attr])\n\n    @override\n    def can_redo(self, attr: str) -&gt; bool:\n        \"\"\"\n        Check if there are changes that can be redone for a field.\n\n        This method returns True if there are changes in the redo stack for the\n        specified field, and False otherwise.\n\n        Args:\n            attr: The field name to check.\n\n        Returns:\n            True if there are changes that can be redone, False otherwise.\n\n        Examples:\n            ```python\n            # Create a proxy with undo enabled\n            document = Document(title=\"Draft\", content=\"Hello\")\n            proxy = ObservableProxy(document, undo=True)\n\n            # Make a change\n            proxy.observable(str, \"content\").set(\"Hello world\")\n\n            # Check if we can redo initially\n            print(proxy.can_redo(\"content\"))  # Prints: False\n\n            # Undo the change\n            proxy.undo(\"content\")\n\n            # Check if we can redo after undoing\n            print(proxy.can_redo(\"content\"))  # Prints: True\n\n            # Redo the change\n            proxy.redo(\"content\")\n\n            # Check if we can redo after redoing\n            print(proxy.can_redo(\"content\"))  # Prints: False\n            ```\n        \"\"\"\n        return attr in self._redo_stacks and bool(self._redo_stacks[attr])\n\n    @override\n    def track_scalar_change(self, attr: str, old_value: Any, new_value: Any) -&gt; None:\n        \"\"\"\n        Track a scalar change for undo/redo functionality.\n\n        This method is called by UndoableObservable when a scalar field value changes.\n        It creates undo and redo functions and adds them to the undo stack.\n\n        Args:\n            attr: The field name that changed.\n            old_value: The old value before the change.\n            new_value: The new value after the change.\n\n        Note:\n            This method is primarily used internally by the ObservableProxy class.\n            Users typically don't need to call this method directly.\n        \"\"\"\n        print(f\"DEBUG: track_scalar_change called for {attr} with old={old_value}, new={new_value}\")\n        if old_value == new_value:\n            print(\"DEBUG: values are the same, skipping\")\n            return\n\n        # Check if undo is enabled for this field\n        config = self._get_undo_config(attr)\n        if not config.enabled:\n            print(f\"DEBUG: undo is disabled for {attr}, skipping\")\n            return\n\n        # Get the observable for this field\n        obs = None\n        for key, o in self._scalars.items():\n            if key.attr == attr:\n                obs = o\n                break\n\n        if obs is None:\n            print(f\"DEBUG: track_scalar_change - Field {attr} not found\")\n            return  # Field not found\n\n        # Create undo/redo functions\n        def undo_func() -&gt; None:\n            print(f\"DEBUG: undo_func called for {attr}, setting value to {old_value}\")\n            # Set the old value with triggering callbacks to ensure computed properties update\n            obs.set(old_value)\n\n            # If we're undoing to the original value, clear the dirty state\n            if old_value == self._initial_values.get(attr):\n                self._dirty_fields.discard(attr)\n\n            print(f\"DEBUG: undo_func completed for {attr}\")\n\n        def redo_func() -&gt; None:\n            print(f\"DEBUG: redo_func called for {attr}, setting value to {new_value}\")\n            # Set the new value with triggering callbacks to ensure computed properties update\n            obs.set(new_value)\n\n            # If we're redoing to a non-original value, mark as dirty\n            if new_value != self._initial_values.get(attr):\n                self._dirty_fields.add(attr)\n\n            print(f\"DEBUG: redo_func completed for {attr}\")\n\n        # Add to the undo stack\n        print(f\"DEBUG: track_scalar_change - Calling _add_to_undo_stack for {attr}\")\n        self._add_to_undo_stack(attr, undo_func, redo_func)\n        print(f\"DEBUG: track_scalar_change - Completed for {attr}\")\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.__init__","title":"<code>__init__(obj, *, sync=False, undo=False, undo_max=None, undo_debounce_ms=None)</code>","text":"<p>Initialize a new ObservableProxy for a data object.</p> <p>Creates a proxy that wraps a data object and exposes its fields as observable properties. The proxy can be configured to automatically sync changes back to the source model, or to require explicit saving.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>T</code> <p>The object to proxy. This can be any Python object with attributes.</p> required <code>sync</code> <code>bool</code> <p>If True, observables will sync back to the model immediately when changed.  If False, changes must be saved explicitly using save_to().</p> <code>False</code> <code>undo</code> <code>bool</code> <p>If True, enables undo/redo functionality for all fields.  Individual fields can override this setting.</p> <code>False</code> <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store per field.      None means unlimited (though default is 100 if not specified).</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes into a single undo step.              None means no debouncing (every change is a separate undo step).</p> <code>None</code> <p>Examples:</p> <pre><code># Create a proxy with no automatic sync\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user)\n\n# Create a proxy with automatic sync\nsettings = Settings(theme=\"dark\", font_size=12)\nproxy = ObservableProxy(settings, sync=True)\n\n# Create a proxy with undo/redo enabled\ndocument = Document(title=\"Draft\", content=\"Hello world\")\nproxy = ObservableProxy(document, undo=True, undo_max=50, undo_debounce_ms=500)\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>def __init__(\n    self,\n    obj: T,\n    *,\n    sync: bool = False,\n    undo: bool = False,  # Undo is disabled by default\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a new ObservableProxy for a data object.\n\n    Creates a proxy that wraps a data object and exposes its fields as observable\n    properties. The proxy can be configured to automatically sync changes back to\n    the source model, or to require explicit saving.\n\n    Args:\n        obj: The object to proxy. This can be any Python object with attributes.\n        sync: If True, observables will sync back to the model immediately when changed.\n             If False, changes must be saved explicitly using save_to().\n        undo: If True, enables undo/redo functionality for all fields.\n             Individual fields can override this setting.\n        undo_max: Maximum number of undo steps to store per field.\n                 None means unlimited (though default is 100 if not specified).\n        undo_debounce_ms: Time window in milliseconds to group changes into a single undo step.\n                         None means no debouncing (every change is a separate undo step).\n\n    Examples:\n        ```python\n        # Create a proxy with no automatic sync\n        user = User(name=\"Alice\", age=30)\n        proxy = ObservableProxy(user)\n\n        # Create a proxy with automatic sync\n        settings = Settings(theme=\"dark\", font_size=12)\n        proxy = ObservableProxy(settings, sync=True)\n\n        # Create a proxy with undo/redo enabled\n        document = Document(title=\"Draft\", content=\"Hello world\")\n        proxy = ObservableProxy(document, undo=True, undo_max=50, undo_debounce_ms=500)\n        ```\n    \"\"\"\n    self._obj = obj\n    self._sync_default = sync\n\n    # Print a warning if sync and undo are both enabled\n    if sync and undo:\n        print(\"Warning: sync=True with undo=True may cause unexpected model mutations during undo/redo.\")\n\n    self._scalars: dict[ProxyFieldKey, Observable[Any]] = {}\n    self._lists: dict[ProxyFieldKey, ObservableList[Any]] = {}\n    self._dicts: dict[ProxyFieldKey, ObservableDict[Any, Any]] = {}\n    self._computeds: dict[str, Observable[Any]] = {}\n    self._dirty_fields: set[str] = set()\n\n    # Validation related fields\n    self._validators: dict[str, list[Callable[[Any], str | None]]] = {}\n    self._validation_errors_dict = ObservableDict[str, list[str]]({})\n    self._validation_for_cache: dict[str, Observable[list[str]]] = {}\n    self._is_valid_obs = Observable[bool](True)\n\n    # Undo/redo related fields\n    self._default_undo_config = UndoConfig(enabled=undo, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n    self._field_undo_configs: dict[str, UndoConfig] = {}\n    self._undo_stacks: dict[str, list[Callable[[], None]]] = {}\n    self._redo_stacks: dict[str, list[Callable[[], None]]] = {}\n    self._last_change_times: dict[str, float] = {}\n    self._pending_undo_groups: dict[str, Callable[[], None] | None] = {}\n    self._initial_values: dict[str, Any] = {}  # Store initial values for undo\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.add_validator","title":"<code>add_validator(attr, validator)</code>","text":"<p>Add a validator function for a field.</p> <p>Validators are functions that check if a field value is valid. Multiple validators can be added for the same field. Validation errors are tracked and can be observed.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to validate.</p> required <code>validator</code> <code>Callable[[Any], str | None]</code> <p>A function that takes the field value and returns an error message        if invalid, or None if valid.</p> required <p>Examples:</p> <pre><code># Create a proxy for a user object\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user)\n\n# Add validators for the name field\nproxy.add_validator(\n    \"name\",\n    lambda name: \"Name cannot be empty\" if not name else None\n)\nproxy.add_validator(\n    \"name\",\n    lambda name: \"Name too long\" if len(name) &gt; 50 else None\n)\n\n# Add a validator for the age field\nproxy.add_validator(\n    \"age\",\n    lambda age: \"Age must be positive\" if age &lt; 0 else None\n)\n\n# Check if all fields are valid\nis_valid = proxy.is_valid()\nprint(is_valid.get())  # Prints: True\n\n# Set an invalid value\nproxy.observable(str, \"name\").set(\"\")\nprint(is_valid.get())  # Prints: False\n\n# Get validation errors for a specific field\nname_errors = proxy.validation_for(\"name\")\nprint(name_errors.get())  # Prints: [\"Name cannot be empty\"]\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef add_validator(\n    self,\n    attr: str,\n    validator: Callable[[Any], str | None],\n) -&gt; None:\n    \"\"\"\n    Add a validator function for a field.\n\n    Validators are functions that check if a field value is valid.\n    Multiple validators can be added for the same field.\n    Validation errors are tracked and can be observed.\n\n    Args:\n        attr: The field name to validate.\n        validator: A function that takes the field value and returns an error message\n                   if invalid, or None if valid.\n\n    Examples:\n        ```python\n        # Create a proxy for a user object\n        user = User(name=\"Alice\", age=30)\n        proxy = ObservableProxy(user)\n\n        # Add validators for the name field\n        proxy.add_validator(\n            \"name\",\n            lambda name: \"Name cannot be empty\" if not name else None\n        )\n        proxy.add_validator(\n            \"name\",\n            lambda name: \"Name too long\" if len(name) &gt; 50 else None\n        )\n\n        # Add a validator for the age field\n        proxy.add_validator(\n            \"age\",\n            lambda age: \"Age must be positive\" if age &lt; 0 else None\n        )\n\n        # Check if all fields are valid\n        is_valid = proxy.is_valid()\n        print(is_valid.get())  # Prints: True\n\n        # Set an invalid value\n        proxy.observable(str, \"name\").set(\"\")\n        print(is_valid.get())  # Prints: False\n\n        # Get validation errors for a specific field\n        name_errors = proxy.validation_for(\"name\")\n        print(name_errors.get())  # Prints: [\"Name cannot be empty\"]\n        ```\n    \"\"\"\n    if attr not in self._validators:\n        self._validators[attr] = []\n\n    self._validators[attr].append(validator)\n\n    # Validate the current value if it exists\n    self._validate_field_if_exists(attr)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.can_redo","title":"<code>can_redo(attr)</code>","text":"<p>Check if there are changes that can be redone for a field.</p> <p>This method returns True if there are changes in the redo stack for the specified field, and False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there are changes that can be redone, False otherwise.</p> <p>Examples:</p> <pre><code># Create a proxy with undo enabled\ndocument = Document(title=\"Draft\", content=\"Hello\")\nproxy = ObservableProxy(document, undo=True)\n\n# Make a change\nproxy.observable(str, \"content\").set(\"Hello world\")\n\n# Check if we can redo initially\nprint(proxy.can_redo(\"content\"))  # Prints: False\n\n# Undo the change\nproxy.undo(\"content\")\n\n# Check if we can redo after undoing\nprint(proxy.can_redo(\"content\"))  # Prints: True\n\n# Redo the change\nproxy.redo(\"content\")\n\n# Check if we can redo after redoing\nprint(proxy.can_redo(\"content\"))  # Prints: False\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef can_redo(self, attr: str) -&gt; bool:\n    \"\"\"\n    Check if there are changes that can be redone for a field.\n\n    This method returns True if there are changes in the redo stack for the\n    specified field, and False otherwise.\n\n    Args:\n        attr: The field name to check.\n\n    Returns:\n        True if there are changes that can be redone, False otherwise.\n\n    Examples:\n        ```python\n        # Create a proxy with undo enabled\n        document = Document(title=\"Draft\", content=\"Hello\")\n        proxy = ObservableProxy(document, undo=True)\n\n        # Make a change\n        proxy.observable(str, \"content\").set(\"Hello world\")\n\n        # Check if we can redo initially\n        print(proxy.can_redo(\"content\"))  # Prints: False\n\n        # Undo the change\n        proxy.undo(\"content\")\n\n        # Check if we can redo after undoing\n        print(proxy.can_redo(\"content\"))  # Prints: True\n\n        # Redo the change\n        proxy.redo(\"content\")\n\n        # Check if we can redo after redoing\n        print(proxy.can_redo(\"content\"))  # Prints: False\n        ```\n    \"\"\"\n    return attr in self._redo_stacks and bool(self._redo_stacks[attr])\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.can_undo","title":"<code>can_undo(attr)</code>","text":"<p>Check if there are changes that can be undone for a field.</p> <p>This method returns True if there are changes in the undo stack for the specified field, and False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there are changes that can be undone, False otherwise.</p> <p>Examples:</p> <pre><code># Create a proxy with undo enabled\ndocument = Document(title=\"Draft\", content=\"Hello\")\nproxy = ObservableProxy(document, undo=True)\n\n# Check if we can undo initially\nprint(proxy.can_undo(\"content\"))  # Prints: False\n\n# Make a change\nproxy.observable(str, \"content\").set(\"Hello world\")\n\n# Check if we can undo after change\nprint(proxy.can_undo(\"content\"))  # Prints: True\n\n# Undo the change\nproxy.undo(\"content\")\n\n# Check if we can undo after undoing\nprint(proxy.can_undo(\"content\"))  # Prints: False\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef can_undo(self, attr: str) -&gt; bool:\n    \"\"\"\n    Check if there are changes that can be undone for a field.\n\n    This method returns True if there are changes in the undo stack for the\n    specified field, and False otherwise.\n\n    Args:\n        attr: The field name to check.\n\n    Returns:\n        True if there are changes that can be undone, False otherwise.\n\n    Examples:\n        ```python\n        # Create a proxy with undo enabled\n        document = Document(title=\"Draft\", content=\"Hello\")\n        proxy = ObservableProxy(document, undo=True)\n\n        # Check if we can undo initially\n        print(proxy.can_undo(\"content\"))  # Prints: False\n\n        # Make a change\n        proxy.observable(str, \"content\").set(\"Hello world\")\n\n        # Check if we can undo after change\n        print(proxy.can_undo(\"content\"))  # Prints: True\n\n        # Undo the change\n        proxy.undo(\"content\")\n\n        # Check if we can undo after undoing\n        print(proxy.can_undo(\"content\"))  # Prints: False\n        ```\n    \"\"\"\n    return attr in self._undo_stacks and bool(self._undo_stacks[attr])\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.computed","title":"<code>computed(typ, name)</code>","text":"<p>Get a computed property by name.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>type[TValue]</code> <p>The type of the computed property.</p> required <code>name</code> <code>str</code> <p>The name of the computed property.</p> required <p>Returns:</p> Type Description <code>IObservable[TValue]</code> <p>An observable containing the computed value.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef computed(\n    self,\n    typ: type[TValue],\n    name: str,\n) -&gt; IObservable[TValue]:\n    \"\"\"\n    Get a computed property by name.\n\n    Args:\n        typ: The type of the computed property.\n        name: The name of the computed property.\n\n    Returns:\n        An observable containing the computed value.\n    \"\"\"\n    if name not in self._computeds:\n        raise KeyError(f\"Computed property '{name}' not found\")\n\n    return self._computeds[name]\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.dirty_fields","title":"<code>dirty_fields()</code>","text":"<p>Get the set of field names that have been modified.</p> <p>This method returns a set containing the names of all fields that have been modified since the proxy was created or since the last call to reset_dirty().</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of field names that have been modified.</p> <p>Examples:</p> <pre><code># Create a proxy\nuser = User(name=\"Alice\", age=30, active=True)\nproxy = ObservableProxy(user)\n\n# Make some changes\nproxy.observable(str, \"name\").set(\"Bob\")\nproxy.observable(int, \"age\").set(31)\n\n# Get the dirty fields\ndirty = proxy.dirty_fields()\nprint(dirty)  # Prints: {'name', 'age'}\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef dirty_fields(self) -&gt; set[str]:\n    \"\"\"\n    Get the set of field names that have been modified.\n\n    This method returns a set containing the names of all fields that have been\n    modified since the proxy was created or since the last call to reset_dirty().\n\n    Returns:\n        A set of field names that have been modified.\n\n    Examples:\n        ```python\n        # Create a proxy\n        user = User(name=\"Alice\", age=30, active=True)\n        proxy = ObservableProxy(user)\n\n        # Make some changes\n        proxy.observable(str, \"name\").set(\"Bob\")\n        proxy.observable(int, \"age\").set(31)\n\n        # Get the dirty fields\n        dirty = proxy.dirty_fields()\n        print(dirty)  # Prints: {'name', 'age'}\n        ```\n    \"\"\"\n    return set(self._dirty_fields)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.get","title":"<code>get()</code>","text":"<p>Get the original object being proxied.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef get(self) -&gt; T:\n    \"\"\"\n    Get the original object being proxied.\n    \"\"\"\n    return self._obj\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.is_dirty","title":"<code>is_dirty()</code>","text":"<p>Check if any fields have been modified since initialization or last reset.</p> <p>This method returns True if any observable field has been modified since the proxy was created or since the last call to reset_dirty().</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if any fields have been modified, False otherwise.</p> <p>Examples:</p> <pre><code># Create a proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user)\n\n# Check if dirty initially\nprint(proxy.is_dirty())  # Prints: False\n\n# Make a change\nproxy.observable(str, \"name\").set(\"Bob\")\n\n# Check if dirty after change\nprint(proxy.is_dirty())  # Prints: True\n\n# Reset dirty state\nproxy.reset_dirty()\n\n# Check if dirty after reset\nprint(proxy.is_dirty())  # Prints: False\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef is_dirty(self) -&gt; bool:\n    \"\"\"\n    Check if any fields have been modified since initialization or last reset.\n\n    This method returns True if any observable field has been modified since\n    the proxy was created or since the last call to reset_dirty().\n\n    Returns:\n        True if any fields have been modified, False otherwise.\n\n    Examples:\n        ```python\n        # Create a proxy\n        user = User(name=\"Alice\", age=30)\n        proxy = ObservableProxy(user)\n\n        # Check if dirty initially\n        print(proxy.is_dirty())  # Prints: False\n\n        # Make a change\n        proxy.observable(str, \"name\").set(\"Bob\")\n\n        # Check if dirty after change\n        print(proxy.is_dirty())  # Prints: True\n\n        # Reset dirty state\n        proxy.reset_dirty()\n\n        # Check if dirty after reset\n        print(proxy.is_dirty())  # Prints: False\n        ```\n    \"\"\"\n    return bool(self._dirty_fields)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.is_valid","title":"<code>is_valid()</code>","text":"<p>Get an observable that indicates whether all fields are valid.</p> <p>This method returns an observable that emits True if all fields are valid according to their validators, and False if any field has validation errors. The observable updates automatically when field values change.</p> <p>Returns:</p> Type Description <code>IObservable[bool]</code> <p>An observable that emits True if all fields are valid, False otherwise.</p> <p>Examples:</p> <pre><code># Create a proxy with validation\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user)\n\n# Add a validator\nproxy.add_validator(\"age\", lambda age: \"Age must be positive\" if age &lt; 0 else None)\n\n# Get the is_valid observable\nis_valid = proxy.is_valid()\n\n# Register a callback\nis_valid.on_change(lambda valid: print(f\"Form is valid: {valid}\"))\n\n# Initially valid\nprint(is_valid.get())  # Prints: True\n\n# Make an invalid change\nproxy.observable(int, \"age\").set(-5)  # Prints: \"Form is valid: False\"\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef is_valid(self) -&gt; IObservable[bool]:\n    \"\"\"\n    Get an observable that indicates whether all fields are valid.\n\n    This method returns an observable that emits True if all fields are valid\n    according to their validators, and False if any field has validation errors.\n    The observable updates automatically when field values change.\n\n    Returns:\n        An observable that emits True if all fields are valid, False otherwise.\n\n    Examples:\n        ```python\n        # Create a proxy with validation\n        user = User(name=\"Alice\", age=30)\n        proxy = ObservableProxy(user)\n\n        # Add a validator\n        proxy.add_validator(\"age\", lambda age: \"Age must be positive\" if age &lt; 0 else None)\n\n        # Get the is_valid observable\n        is_valid = proxy.is_valid()\n\n        # Register a callback\n        is_valid.on_change(lambda valid: print(f\"Form is valid: {valid}\"))\n\n        # Initially valid\n        print(is_valid.get())  # Prints: True\n\n        # Make an invalid change\n        proxy.observable(int, \"age\").set(-5)  # Prints: \"Form is valid: False\"\n        ```\n    \"\"\"\n    return self._is_valid_obs\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.load_dict","title":"<code>load_dict(values)</code>","text":"<p>Set multiple scalar observable values from a dict.</p> <p>This is similar to update(), but takes a dictionary instead of keyword arguments. It creates observables for any fields that don't already have them.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, Any]</code> <p>A dictionary where each key is a field name and each value    is the new value to set for that field.</p> required <p>Examples:</p> <pre><code># Load values from a dictionary\ndata = {\"name\": \"Alice\", \"age\": 30, \"active\": True}\nproxy.load_dict(data)\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef load_dict(self, values: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Set multiple scalar observable values from a dict.\n\n    This is similar to update(), but takes a dictionary instead of keyword arguments.\n    It creates observables for any fields that don't already have them.\n\n    Args:\n        values: A dictionary where each key is a field name and each value\n               is the new value to set for that field.\n\n    Examples:\n        ```python\n        # Load values from a dictionary\n        data = {\"name\": \"Alice\", \"age\": 30, \"active\": True}\n        proxy.load_dict(data)\n        ```\n    \"\"\"\n    for attr, value in values.items():\n        self.observable(object, attr).set(value)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.observable","title":"<code>observable(typ, attr, *, sync=None, undo_max=None, undo_debounce_ms=None)</code>","text":"<p>Get or create an Observable[T] for a scalar field.</p> <p>Creates or returns an existing Observable for a scalar field of the proxied object. The Observable allows watching for changes to the field value and modifying it.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>type[TValue]</code> <p>The type of the field.</p> required <code>attr</code> <code>str</code> <p>The field name.</p> required <code>sync</code> <code>bool | None</code> <p>Whether to sync changes back to the model immediately.  If None, uses the default sync setting from the proxy.</p> <code>None</code> <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means use the default.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means use the default.</p> <code>None</code> <p>Returns:</p> Type Description <code>IObservable[TValue]</code> <p>An Observable containing the field value.</p> <p>Examples:</p> <pre><code># Get an observable for a string field\nname_obs = proxy.observable(str, \"name\")\n\n# Register a callback\nname_obs.on_change(lambda value: print(f\"Name changed to {value}\"))\n\n# Get the current value\ncurrent_name = name_obs.get()\n\n# Set a new value\nname_obs.set(\"New Name\")\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef observable(\n    self,\n    typ: type[TValue],\n    attr: str,\n    *,\n    sync: bool | None = None,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; IObservable[TValue]:\n    \"\"\"\n    Get or create an Observable[T] for a scalar field.\n\n    Creates or returns an existing Observable for a scalar field of the proxied object.\n    The Observable allows watching for changes to the field value and modifying it.\n\n    Args:\n        typ: The type of the field.\n        attr: The field name.\n        sync: Whether to sync changes back to the model immediately.\n             If None, uses the default sync setting from the proxy.\n        undo_max: Maximum number of undo steps to store. None means use the default.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n\n    Returns:\n        An Observable containing the field value.\n\n    Examples:\n        ```python\n        # Get an observable for a string field\n        name_obs = proxy.observable(str, \"name\")\n\n        # Register a callback\n        name_obs.on_change(lambda value: print(f\"Name changed to {value}\"))\n\n        # Get the current value\n        current_name = name_obs.get()\n\n        # Set a new value\n        name_obs.set(\"New Name\")\n        ```\n    \"\"\"\n    sync = self._sync_default if sync is None else sync\n    key = ProxyFieldKey(attr, sync)\n\n    # Set up undo config if provided\n    if undo_max is not None or undo_debounce_ms is not None:\n        self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n    # Get the initial value\n    val = getattr(self._obj, attr)\n\n    if key not in self._scalars:\n        # Create observable with callbacks disabled to prevent premature tracking\n        # obs = Observable(val, on_change_enabled=False)\n        obs = UndoableObservable(val, attr, self, on_change_enabled=False)\n\n        # Store the observable first so it can be found by _track_scalar_change\n        self._scalars[key] = obs\n\n        if sync:\n            obs.on_change(lambda v: setattr(self._obj, attr, v))\n        # Register dirty tracking callback\n        obs.on_change(lambda _: self._dirty_fields.add(attr))\n        # Register validation callback\n        obs.on_change(lambda v: self._validate_field(attr, v))\n        # Undo tracking is now handled by UndoableObservable\n\n        # Initial value tracking is now handled by UndoableObservable\n\n        # Now enable callbacks for future changes\n        obs.enable()\n    else:\n        # Get the existing observable\n        obs = self._scalars[key]\n\n    return self._scalars[key]\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.observable_dict","title":"<code>observable_dict(typ, attr, *, sync=None, undo_max=None, undo_debounce_ms=None)</code>","text":"<p>Get or create an ObservableDict for a dict field.</p> <p>Creates or returns an existing ObservableDict for a dictionary field of the proxied object. The ObservableDict provides the same interface as a regular Python dictionary, but with change notification capabilities.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>tuple[type[TDictKey], type[TDictValue]]</code> <p>A tuple of (key_type, value_type) for the dictionary.</p> required <code>attr</code> <code>str</code> <p>The field name.</p> required <code>sync</code> <code>bool | None</code> <p>Whether to sync changes back to the model immediately.  If None, uses the default sync setting from the proxy.</p> <code>None</code> <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means use the default.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means use the default.</p> <code>None</code> <p>Returns:</p> Type Description <code>IObservableDict[TDictKey, TDictValue]</code> <p>An ObservableDict containing the field value.</p> <p>Examples:</p> <pre><code># Get an observable dict for a metadata field\nmetadata_obs = proxy.observable_dict((str, str), \"metadata\")\n\n# Register a callback\nmetadata_obs.on_change(lambda change: print(f\"Metadata changed: {change.type}\"))\n\n# Modify the dictionary\nmetadata_obs[\"author\"] = \"Alice\"\ndel metadata_obs[\"draft\"]\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef observable_dict(\n    self,\n    typ: tuple[type[TDictKey], type[TDictValue]],\n    attr: str,\n    *,\n    sync: bool | None = None,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; IObservableDict[TDictKey, TDictValue]:\n    \"\"\"\n    Get or create an ObservableDict for a dict field.\n\n    Creates or returns an existing ObservableDict for a dictionary field of the proxied object.\n    The ObservableDict provides the same interface as a regular Python dictionary, but with\n    change notification capabilities.\n\n    Args:\n        typ: A tuple of (key_type, value_type) for the dictionary.\n        attr: The field name.\n        sync: Whether to sync changes back to the model immediately.\n             If None, uses the default sync setting from the proxy.\n        undo_max: Maximum number of undo steps to store. None means use the default.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n\n    Returns:\n        An ObservableDict containing the field value.\n\n    Examples:\n        ```python\n        # Get an observable dict for a metadata field\n        metadata_obs = proxy.observable_dict((str, str), \"metadata\")\n\n        # Register a callback\n        metadata_obs.on_change(lambda change: print(f\"Metadata changed: {change.type}\"))\n\n        # Modify the dictionary\n        metadata_obs[\"author\"] = \"Alice\"\n        del metadata_obs[\"draft\"]\n        ```\n    \"\"\"\n    sync = self._sync_default if sync is None else sync\n    key = ProxyFieldKey(attr, sync)\n\n    # Set up undo config if provided\n    if undo_max is not None or undo_debounce_ms is not None:\n        self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n    if key not in self._dicts:\n        val_raw = getattr(self._obj, attr)\n        val: dict[Any, Any] = cast(dict[Any, Any], val_raw)\n        obs = ObservableDict(val, copy=not sync)\n        if sync:\n            obs.on_change(lambda _: setattr(self._obj, attr, obs.copy()))\n        # Register dirty tracking callback\n        obs.on_change(lambda _: self._dirty_fields.add(attr))\n        # Register validation callback\n        obs.on_change(lambda _: self._validate_field(attr, obs.copy()))\n        # Register undo tracking callback\n        obs.on_change(lambda c: self._track_dict_change(attr, c))\n        self._dicts[key] = obs\n\n    return self._dicts[key]\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.observable_list","title":"<code>observable_list(typ, attr, *, sync=None, undo_max=None, undo_debounce_ms=None)</code>","text":"<p>Get or create an ObservableList[T] for a list field.</p> <p>Creates or returns an existing ObservableList for a list field of the proxied object. The ObservableList provides the same interface as a regular Python list, but with change notification capabilities.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>type[TValue]</code> <p>The type of the list elements.</p> required <code>attr</code> <code>str</code> <p>The field name.</p> required <code>sync</code> <code>bool | None</code> <p>Whether to sync changes back to the model immediately.  If None, uses the default sync setting from the proxy.</p> <code>None</code> <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means use the default.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means use the default.</p> <code>None</code> <p>Returns:</p> Type Description <code>IObservableList[TValue]</code> <p>An ObservableList containing the field value.</p> <p>Examples:</p> <pre><code># Get an observable list for a tags field\ntags_obs = proxy.observable_list(str, \"tags\")\n\n# Register a callback\ntags_obs.on_change(lambda change: print(f\"Tags changed: {change.type}\"))\n\n# Modify the list\ntags_obs.append(\"new_tag\")\ntags_obs.remove(\"old_tag\")\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef observable_list(\n    self,\n    typ: type[TValue],\n    attr: str,\n    *,\n    sync: bool | None = None,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; IObservableList[TValue]:\n    \"\"\"\n    Get or create an ObservableList[T] for a list field.\n\n    Creates or returns an existing ObservableList for a list field of the proxied object.\n    The ObservableList provides the same interface as a regular Python list, but with\n    change notification capabilities.\n\n    Args:\n        typ: The type of the list elements.\n        attr: The field name.\n        sync: Whether to sync changes back to the model immediately.\n             If None, uses the default sync setting from the proxy.\n        undo_max: Maximum number of undo steps to store. None means use the default.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n\n    Returns:\n        An ObservableList containing the field value.\n\n    Examples:\n        ```python\n        # Get an observable list for a tags field\n        tags_obs = proxy.observable_list(str, \"tags\")\n\n        # Register a callback\n        tags_obs.on_change(lambda change: print(f\"Tags changed: {change.type}\"))\n\n        # Modify the list\n        tags_obs.append(\"new_tag\")\n        tags_obs.remove(\"old_tag\")\n        ```\n    \"\"\"\n    sync = self._sync_default if sync is None else sync\n    key = ProxyFieldKey(attr, sync)\n\n    # Set up undo config if provided\n    if undo_max is not None or undo_debounce_ms is not None:\n        self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n    if key not in self._lists:\n        val_raw = getattr(self._obj, attr)\n        val: list[T] = cast(list[T], val_raw)\n        obs = ObservableList(val, copy=not sync)\n        if sync:\n            obs.on_change(lambda _: setattr(self._obj, attr, obs.copy()))\n        # Register dirty tracking callback\n        obs.on_change(lambda _: self._dirty_fields.add(attr))\n        # Register validation callback\n        obs.on_change(lambda _: self._validate_field(attr, obs.copy()))\n        # Register undo tracking callback\n        obs.on_change(lambda c: self._track_list_change(attr, c))\n        self._lists[key] = obs\n\n    return self._lists[key]\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.redo","title":"<code>redo(attr)</code>","text":"<p>Redo the most recently undone change to a field.</p> <p>This method reapplies the most recently undone change to the specified field by popping the top function from the redo stack and executing it. If the field has no changes to redo, this method does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to redo changes for.</p> required <p>Examples:</p> <pre><code># Create a proxy with undo enabled\ndocument = Document(title=\"Draft\", content=\"Hello\")\nproxy = ObservableProxy(document, undo=True)\n\n# Make a change\nproxy.observable(str, \"content\").set(\"Hello world\")\n\n# Undo the change\nproxy.undo(\"content\")  # Content is now \"Hello\"\n\n# Redo the change\nproxy.redo(\"content\")  # Content is now \"Hello world\" again\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef redo(self, attr: str) -&gt; None:\n    \"\"\"\n    Redo the most recently undone change to a field.\n\n    This method reapplies the most recently undone change to the specified field\n    by popping the top function from the redo stack and executing it. If the\n    field has no changes to redo, this method does nothing.\n\n    Args:\n        attr: The field name to redo changes for.\n\n    Examples:\n        ```python\n        # Create a proxy with undo enabled\n        document = Document(title=\"Draft\", content=\"Hello\")\n        proxy = ObservableProxy(document, undo=True)\n\n        # Make a change\n        proxy.observable(str, \"content\").set(\"Hello world\")\n\n        # Undo the change\n        proxy.undo(\"content\")  # Content is now \"Hello\"\n\n        # Redo the change\n        proxy.redo(\"content\")  # Content is now \"Hello world\" again\n        ```\n    \"\"\"\n    print(f\"DEBUG: redo called for {attr}\")\n    if attr not in self._redo_stacks or not self._redo_stacks[attr]:\n        print(f\"DEBUG: redo - Nothing to redo for {attr}\")\n        return  # Nothing to redo\n\n    # Pop the most recent redo function\n    redo_func = self._redo_stacks[attr].pop()\n    print(f\"DEBUG: redo - Popped redo function from stack for {attr}, remaining: {len(self._redo_stacks[attr])}\")\n\n    # Get the undo function that will undo this redo operation\n    # This is the function that was popped from the undo stack when undo was called\n    undo_func = None\n    if attr in self._pending_undo_groups:\n        undo_func = self._pending_undo_groups[attr]\n        print(f\"DEBUG: redo - Got pending undo function for {attr}: {undo_func is not None}\")\n\n    # Find the observable for this field to manually track changes\n    # We need to do this because the redo function disables tracking\n    obs_list = None\n    obs_dict = None\n\n    # Check if this is a list field\n    for key, o in self._lists.items():\n        if key.attr == attr:\n            obs_list = o\n            print(f\"DEBUG: redo - Found list observable for {attr}\")\n            break\n\n    # Check if this is a dict field\n    if obs_list is None:\n        for key, o in self._dicts.items():\n            if key.attr == attr:\n                obs_dict = o\n                print(f\"DEBUG: redo - Found dict observable for {attr}\")\n                break\n\n    # We don't need to simulate change objects anymore\n\n    # Find the scalar observable for this field to set the undoing flag\n    obs_scalar = None\n    for key, o in self._scalars.items():\n        if key.attr == attr:\n            obs_scalar = o\n            break\n\n    # Execute the redo function with undoing flag set\n    print(f\"DEBUG: redo - Executing redo function for {attr}\")\n\n    # Set the undoing flag if we found the observable and it's a UndoableObservable\n    from observant.undoable_observable import UndoableObservable\n\n    if obs_scalar is not None and isinstance(obs_scalar, UndoableObservable):\n        obs_scalar.set_undoing(True)\n\n    try:\n        redo_func()\n    finally:\n        # Reset the undoing flag\n        if obs_scalar is not None and isinstance(obs_scalar, UndoableObservable):\n            obs_scalar.set_undoing(False)\n\n    print(f\"DEBUG: redo - Redo function executed for {attr}\")\n\n    # Add the undo function back to the undo stack\n    # This is necessary because the redo function disables tracking\n    if undo_func is not None:\n        self._undo_stacks.setdefault(attr, []).append(undo_func)\n        print(f\"DEBUG: redo - Added undo function back to stack for {attr}, stack size: {len(self._undo_stacks[attr])}\")\n        # Clear the pending undo group since we've used it\n        self._pending_undo_groups[attr] = None\n        print(f\"DEBUG: redo - Cleared pending undo group for {attr}\")\n    else:\n        # If we don't have an undo function from the pending group,\n        # we need to create one based on the current state\n        print(\"DEBUG: redo - No pending undo function, creating one\")\n\n        # For scalar fields\n        for key, o in self._scalars.items():\n            if key.attr == attr:\n                # Create an undo function that will restore the current value\n                current_value = o.get()\n\n                def new_undo_func() -&gt; None:\n                    print(f\"DEBUG: new_undo_func called for {attr}\")\n                    o.set(current_value, notify=False)\n                    print(f\"DEBUG: new_undo_func completed for {attr}\")\n\n                # Add it to the undo stack\n                self._undo_stacks.setdefault(attr, []).append(new_undo_func)\n                print(f\"DEBUG: redo - Created and added new undo function for scalar {attr}\")\n                break\n\n        # For list fields\n        if obs_list is not None:\n            # Create an undo function that will restore the current list state\n            current_list = obs_list.copy()\n\n            def new_list_undo_func() -&gt; None:\n                print(f\"DEBUG: new_list_undo_func called for {attr}\")\n                # Clear the list and add all items back\n                obs_list.clear()\n                obs_list.extend(current_list)\n                print(f\"DEBUG: new_list_undo_func completed for {attr}\")\n\n            # Add it to the undo stack\n            self._undo_stacks.setdefault(attr, []).append(new_list_undo_func)\n            print(f\"DEBUG: redo - Created and added new undo function for list {attr}\")\n\n        # For dict fields\n        if obs_dict is not None:\n            # Create an undo function that will restore the current dict state\n            current_dict = obs_dict.copy()\n\n            def new_dict_undo_func() -&gt; None:\n                print(f\"DEBUG: new_dict_undo_func called for {attr}\")\n                # Clear the dict and add all items back\n                obs_dict.clear()\n                obs_dict.update(current_dict)\n                print(f\"DEBUG: new_dict_undo_func completed for {attr}\")\n\n            # Add it to the undo stack\n            self._undo_stacks.setdefault(attr, []).append(new_dict_undo_func)\n            print(f\"DEBUG: redo - Created and added new undo function for dict {attr}\")\n\n    print(f\"DEBUG: redo - Completed for {attr}\")\n\n    # If sync is enabled for this field, update the model\n    for key in self._scalars:\n        if key.attr == attr and key.sync:\n            value = self._scalars[key].get()\n            setattr(self._obj, attr, value)\n            print(f\"DEBUG: redo - Synced {attr} to model with value {value}\")\n            break\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.register_computed","title":"<code>register_computed(name, compute, dependencies)</code>","text":"<p>Register a computed property that depends on other observables.</p> <p>Computed properties are read-only observables that automatically update when their dependencies change. They can depend on scalar fields, list fields, dictionary fields, or other computed properties.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the computed property.</p> required <code>compute</code> <code>Callable[[], TValue]</code> <p>A function that returns the computed value.</p> required <code>dependencies</code> <code>list[str]</code> <p>List of field names that this computed property depends on.</p> required <p>Examples:</p> <pre><code># Create a proxy for a user object\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user)\n\n# Register a computed property for the user's greeting\nproxy.register_computed(\n    name=\"greeting\",\n    compute=lambda: f\"Hello, {proxy.observable(str, 'name').get()}!\",\n    dependencies=[\"name\"]\n)\n\n# Get the computed property\ngreeting_obs = proxy.computed(str, \"greeting\")\nprint(greeting_obs.get())  # Prints: \"Hello, Alice!\"\n\n# When the name changes, the greeting updates automatically\nproxy.observable(str, \"name\").set(\"Bob\")\nprint(greeting_obs.get())  # Prints: \"Hello, Bob!\"\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef register_computed(\n    self,\n    name: str,\n    compute: Callable[[], TValue],\n    dependencies: list[str],\n) -&gt; None:\n    \"\"\"\n    Register a computed property that depends on other observables.\n\n    Computed properties are read-only observables that automatically update\n    when their dependencies change. They can depend on scalar fields, list fields,\n    dictionary fields, or other computed properties.\n\n    Args:\n        name: The name of the computed property.\n        compute: A function that returns the computed value.\n        dependencies: List of field names that this computed property depends on.\n\n    Examples:\n        ```python\n        # Create a proxy for a user object\n        user = User(name=\"Alice\", age=30)\n        proxy = ObservableProxy(user)\n\n        # Register a computed property for the user's greeting\n        proxy.register_computed(\n            name=\"greeting\",\n            compute=lambda: f\"Hello, {proxy.observable(str, 'name').get()}!\",\n            dependencies=[\"name\"]\n        )\n\n        # Get the computed property\n        greeting_obs = proxy.computed(str, \"greeting\")\n        print(greeting_obs.get())  # Prints: \"Hello, Alice!\"\n\n        # When the name changes, the greeting updates automatically\n        proxy.observable(str, \"name\").set(\"Bob\")\n        print(greeting_obs.get())  # Prints: \"Hello, Bob!\"\n        ```\n    \"\"\"\n    # Create an observable for the computed property\n    initial_value = compute()\n    obs = Observable(initial_value)\n    self._computeds[name] = obs\n\n    # Register callbacks for each dependency\n    for dep in dependencies:\n        # For scalar dependencies\n        def update_computed(_: Any) -&gt; None:\n            new_value = compute()\n            current = obs.get()\n            if new_value != current:\n                obs.set(new_value)\n\n        # Try to find the dependency in scalars, lists, or dicts\n        for sync in [True, False]:\n            key = ProxyFieldKey(dep, sync)\n\n            if key in self._scalars:\n                self._scalars[key].on_change(update_computed)\n                break\n\n            if key in self._lists:\n                self._lists[key].on_change(update_computed)\n                break\n\n            if key in self._dicts:\n                self._dicts[key].on_change(update_computed)\n                break\n\n        # Check if the dependency is another computed property\n        if dep in self._computeds:\n            self._computeds[dep].on_change(update_computed)\n\n    # Validate the computed property when it changes\n    def validate_computed(_: Any) -&gt; None:\n        value = compute()\n        self._validate_field(name, value)\n\n    obs.on_change(validate_computed)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.reset_dirty","title":"<code>reset_dirty()</code>","text":"<p>Reset the dirty state of all fields.</p> <p>This method clears the dirty state of all fields, marking them as clean. It's typically called after saving changes back to the model.</p> <p>Examples:</p> <pre><code># Create a proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user)\n\n# Make a change\nproxy.observable(str, \"name\").set(\"Bob\")\nprint(proxy.is_dirty())  # Prints: True\n\n# Reset dirty state\nproxy.reset_dirty()\nprint(proxy.is_dirty())  # Prints: False\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef reset_dirty(self) -&gt; None:\n    \"\"\"\n    Reset the dirty state of all fields.\n\n    This method clears the dirty state of all fields, marking them as clean.\n    It's typically called after saving changes back to the model.\n\n    Examples:\n        ```python\n        # Create a proxy\n        user = User(name=\"Alice\", age=30)\n        proxy = ObservableProxy(user)\n\n        # Make a change\n        proxy.observable(str, \"name\").set(\"Bob\")\n        print(proxy.is_dirty())  # Prints: True\n\n        # Reset dirty state\n        proxy.reset_dirty()\n        print(proxy.is_dirty())  # Prints: False\n        ```\n    \"\"\"\n    self._dirty_fields.clear()\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.reset_validation","title":"<code>reset_validation(attr=None, *, revalidate=False)</code>","text":"<p>Reset validation errors for a specific field or all fields.</p> <p>This method clears validation errors for the specified field or all fields. It can optionally re-run validators after clearing errors.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str | None</code> <p>The field name to reset validation for. If None, reset all fields.</p> <code>None</code> <code>revalidate</code> <code>bool</code> <p>Whether to re-run validators after clearing errors.        If True, validators will be run on the current field values.        If False, fields will be marked as valid until the next change.</p> <code>False</code> <p>Examples:</p> <pre><code># Create a proxy with validation\nuser = User(name=\"\", age=-5)\nproxy = ObservableProxy(user)\n\n# Add validators\nproxy.add_validator(\"name\", lambda name: \"Name cannot be empty\" if not name else None)\nproxy.add_validator(\"age\", lambda age: \"Age must be positive\" if age &lt; 0 else None)\n\n# Check validation initially\nprint(proxy.is_valid().get())  # Prints: False\n\n# Reset validation for all fields without revalidating\nproxy.reset_validation()\nprint(proxy.is_valid().get())  # Prints: True\n\n# Reset validation for all fields with revalidation\nproxy.reset_validation(revalidate=True)\nprint(proxy.is_valid().get())  # Prints: False\n\n# Reset validation for just the name field\nproxy.reset_validation(\"name\")\nprint(proxy.validation_for(\"name\").get())  # Prints: []\nprint(proxy.validation_for(\"age\").get())   # Prints: ['Age must be positive']\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef reset_validation(self, attr: str | None = None, *, revalidate: bool = False) -&gt; None:\n    \"\"\"\n    Reset validation errors for a specific field or all fields.\n\n    This method clears validation errors for the specified field or all fields.\n    It can optionally re-run validators after clearing errors.\n\n    Args:\n        attr: The field name to reset validation for. If None, reset all fields.\n        revalidate: Whether to re-run validators after clearing errors.\n                   If True, validators will be run on the current field values.\n                   If False, fields will be marked as valid until the next change.\n\n    Examples:\n        ```python\n        # Create a proxy with validation\n        user = User(name=\"\", age=-5)\n        proxy = ObservableProxy(user)\n\n        # Add validators\n        proxy.add_validator(\"name\", lambda name: \"Name cannot be empty\" if not name else None)\n        proxy.add_validator(\"age\", lambda age: \"Age must be positive\" if age &lt; 0 else None)\n\n        # Check validation initially\n        print(proxy.is_valid().get())  # Prints: False\n\n        # Reset validation for all fields without revalidating\n        proxy.reset_validation()\n        print(proxy.is_valid().get())  # Prints: True\n\n        # Reset validation for all fields with revalidation\n        proxy.reset_validation(revalidate=True)\n        print(proxy.is_valid().get())  # Prints: False\n\n        # Reset validation for just the name field\n        proxy.reset_validation(\"name\")\n        print(proxy.validation_for(\"name\").get())  # Prints: []\n        print(proxy.validation_for(\"age\").get())   # Prints: ['Age must be positive']\n        ```\n    \"\"\"\n    if attr is None:\n        # Reset all validation errors\n        self._validation_errors_dict.clear()\n        # Update the is_valid observable\n        self._is_valid_obs.set(True)\n\n        # Re-run all validators if requested\n        if revalidate:\n            for field_name in self._validators.keys():\n                self._validate_field_if_exists(field_name)\n    else:\n        # Reset validation errors for a specific field\n        if attr in self._validation_errors_dict:\n            del self._validation_errors_dict[attr]\n            # Update the is_valid observable\n            self._is_valid_obs.set(len(self._validation_errors_dict) == 0)\n\n        # Re-run validator for this field if requested\n        if revalidate:\n            self._validate_field_if_exists(attr)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.save_to","title":"<code>save_to(obj)</code>","text":"<p>Write all observable values back into the given object.</p> <p>This method copies all values from the observables back to the target object. It's useful when sync=False and you want to explicitly save changes.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>T</code> <p>The object to write values to. This can be the original object  or a different object of the same type.</p> required <p>Examples:</p> <pre><code># Create a proxy with no automatic sync\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user)\n\n# Make changes through the proxy\nproxy.observable(str, \"name\").set(\"Bob\")\n\n# At this point, user.name is still \"Alice\"\nprint(user.name)  # Prints: \"Alice\"\n\n# Save changes back to the original object\nproxy.save_to(user)\nprint(user.name)  # Prints: \"Bob\"\n\n# Or save to a new object\nnew_user = User(name=\"\", age=0)\nproxy.save_to(new_user)\nprint(new_user.name)  # Prints: \"Bob\"\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef save_to(self, obj: T) -&gt; None:\n    \"\"\"\n    Write all observable values back into the given object.\n\n    This method copies all values from the observables back to the target object.\n    It's useful when sync=False and you want to explicitly save changes.\n\n    Args:\n        obj: The object to write values to. This can be the original object\n             or a different object of the same type.\n\n    Examples:\n        ```python\n        # Create a proxy with no automatic sync\n        user = User(name=\"Alice\", age=30)\n        proxy = ObservableProxy(user)\n\n        # Make changes through the proxy\n        proxy.observable(str, \"name\").set(\"Bob\")\n\n        # At this point, user.name is still \"Alice\"\n        print(user.name)  # Prints: \"Alice\"\n\n        # Save changes back to the original object\n        proxy.save_to(user)\n        print(user.name)  # Prints: \"Bob\"\n\n        # Or save to a new object\n        new_user = User(name=\"\", age=0)\n        proxy.save_to(new_user)\n        print(new_user.name)  # Prints: \"Bob\"\n        ```\n    \"\"\"\n    for key, obs in self._scalars.items():\n        setattr(obj, key.attr, obs.get())\n\n    for key, obs in self._lists.items():\n        setattr(obj, key.attr, obs.copy())\n\n    for key, obs in self._dicts.items():\n        setattr(obj, key.attr, obs.copy())\n\n    # Save computed fields that shadow real fields\n    for name, obs in self._computeds.items():\n        try:\n            # Check if the target object has this field\n            getattr(obj, name)\n            # If we get here, the field exists, so save the computed value\n            setattr(obj, name, obs.get())\n        except (AttributeError, TypeError):\n            # Field doesn't exist in the target object, skip it\n            pass\n\n    # Reset dirty state after saving\n    self.reset_dirty()\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.set_undo_config","title":"<code>set_undo_config(attr, *, enabled=None, undo_max=None, undo_debounce_ms=None)</code>","text":"<p>Set the undo configuration for a specific field.</p> <p>This method allows configuring undo/redo behavior for individual fields. Each field can have its own undo history size and debounce timing.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to configure.</p> required <code>enabled</code> <code>bool | None</code> <p>Whether undo/redo functionality is enabled for this field.     If None, uses the default from the proxy.</p> <code>None</code> <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means use the default.      A value of 0 means no limit.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes into a single undo step.              None means use the default. A value of 0 means no debouncing.</p> <code>None</code> <p>Examples:</p> <pre><code># Create a proxy with undo enabled\ndocument = Document(title=\"Draft\", content=\"Hello world\")\nproxy = ObservableProxy(document, undo=True)\n\n# Configure undo for the content field\nproxy.set_undo_config(\n    \"content\",\n    undo_max=100,       # Store up to 100 undo steps\n    undo_debounce_ms=500  # Group changes within 500ms\n)\n\n# Disable undo for the title field\nproxy.set_undo_config(\"title\", enabled=False)\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef set_undo_config(\n    self,\n    attr: str,\n    *,\n    enabled: bool | None = None,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Set the undo configuration for a specific field.\n\n    This method allows configuring undo/redo behavior for individual fields.\n    Each field can have its own undo history size and debounce timing.\n\n    Args:\n        attr: The field name to configure.\n        enabled: Whether undo/redo functionality is enabled for this field.\n                If None, uses the default from the proxy.\n        undo_max: Maximum number of undo steps to store. None means use the default.\n                 A value of 0 means no limit.\n        undo_debounce_ms: Time window in milliseconds to group changes into a single undo step.\n                         None means use the default. A value of 0 means no debouncing.\n\n    Examples:\n        ```python\n        # Create a proxy with undo enabled\n        document = Document(title=\"Draft\", content=\"Hello world\")\n        proxy = ObservableProxy(document, undo=True)\n\n        # Configure undo for the content field\n        proxy.set_undo_config(\n            \"content\",\n            undo_max=100,       # Store up to 100 undo steps\n            undo_debounce_ms=500  # Group changes within 500ms\n        )\n\n        # Disable undo for the title field\n        proxy.set_undo_config(\"title\", enabled=False)\n        ```\n    \"\"\"\n    # Get the current config or create a new one\n    config = self._field_undo_configs.get(attr, UndoConfig())\n\n    # Update the config with the provided values\n    if enabled is not None:\n        config.enabled = enabled\n    elif attr not in self._field_undo_configs:\n        # If this is a new config and enabled wasn't specified, inherit from default\n        config.enabled = self._default_undo_config.enabled\n\n    if undo_max is not None:\n        config.undo_max = undo_max\n    if undo_debounce_ms is not None:\n        config.undo_debounce_ms = undo_debounce_ms\n\n    # Store the updated config\n    self._field_undo_configs[attr] = config\n\n    # Enforce the max size if it's been reduced\n    if attr in self._undo_stacks and config.undo_max is not None:\n        while len(self._undo_stacks[attr]) &gt; config.undo_max:\n            self._undo_stacks[attr].pop(0)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.track_scalar_change","title":"<code>track_scalar_change(attr, old_value, new_value)</code>","text":"<p>Track a scalar change for undo/redo functionality.</p> <p>This method is called by UndoableObservable when a scalar field value changes. It creates undo and redo functions and adds them to the undo stack.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name that changed.</p> required <code>old_value</code> <code>Any</code> <p>The old value before the change.</p> required <code>new_value</code> <code>Any</code> <p>The new value after the change.</p> required Note <p>This method is primarily used internally by the ObservableProxy class. Users typically don't need to call this method directly.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef track_scalar_change(self, attr: str, old_value: Any, new_value: Any) -&gt; None:\n    \"\"\"\n    Track a scalar change for undo/redo functionality.\n\n    This method is called by UndoableObservable when a scalar field value changes.\n    It creates undo and redo functions and adds them to the undo stack.\n\n    Args:\n        attr: The field name that changed.\n        old_value: The old value before the change.\n        new_value: The new value after the change.\n\n    Note:\n        This method is primarily used internally by the ObservableProxy class.\n        Users typically don't need to call this method directly.\n    \"\"\"\n    print(f\"DEBUG: track_scalar_change called for {attr} with old={old_value}, new={new_value}\")\n    if old_value == new_value:\n        print(\"DEBUG: values are the same, skipping\")\n        return\n\n    # Check if undo is enabled for this field\n    config = self._get_undo_config(attr)\n    if not config.enabled:\n        print(f\"DEBUG: undo is disabled for {attr}, skipping\")\n        return\n\n    # Get the observable for this field\n    obs = None\n    for key, o in self._scalars.items():\n        if key.attr == attr:\n            obs = o\n            break\n\n    if obs is None:\n        print(f\"DEBUG: track_scalar_change - Field {attr} not found\")\n        return  # Field not found\n\n    # Create undo/redo functions\n    def undo_func() -&gt; None:\n        print(f\"DEBUG: undo_func called for {attr}, setting value to {old_value}\")\n        # Set the old value with triggering callbacks to ensure computed properties update\n        obs.set(old_value)\n\n        # If we're undoing to the original value, clear the dirty state\n        if old_value == self._initial_values.get(attr):\n            self._dirty_fields.discard(attr)\n\n        print(f\"DEBUG: undo_func completed for {attr}\")\n\n    def redo_func() -&gt; None:\n        print(f\"DEBUG: redo_func called for {attr}, setting value to {new_value}\")\n        # Set the new value with triggering callbacks to ensure computed properties update\n        obs.set(new_value)\n\n        # If we're redoing to a non-original value, mark as dirty\n        if new_value != self._initial_values.get(attr):\n            self._dirty_fields.add(attr)\n\n        print(f\"DEBUG: redo_func completed for {attr}\")\n\n    # Add to the undo stack\n    print(f\"DEBUG: track_scalar_change - Calling _add_to_undo_stack for {attr}\")\n    self._add_to_undo_stack(attr, undo_func, redo_func)\n    print(f\"DEBUG: track_scalar_change - Completed for {attr}\")\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.undo","title":"<code>undo(attr)</code>","text":"<p>Undo the most recent change to a field.</p> <p>This method reverts the most recent change to the specified field by popping the top function from the undo stack and executing it. If the field has no changes to undo, this method does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to undo changes for.</p> required <p>Examples:</p> <pre><code># Create a proxy with undo enabled\ndocument = Document(title=\"Draft\", content=\"Hello\")\nproxy = ObservableProxy(document, undo=True)\n\n# Make some changes\nproxy.observable(str, \"content\").set(\"Hello world\")\nproxy.observable(str, \"content\").set(\"Hello world!\")\n\n# Undo the last change\nproxy.undo(\"content\")  # Content is now \"Hello world\"\n\n# Undo again\nproxy.undo(\"content\")  # Content is now \"Hello\"\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef undo(self, attr: str) -&gt; None:\n    \"\"\"\n    Undo the most recent change to a field.\n\n    This method reverts the most recent change to the specified field by\n    popping the top function from the undo stack and executing it. If the\n    field has no changes to undo, this method does nothing.\n\n    Args:\n        attr: The field name to undo changes for.\n\n    Examples:\n        ```python\n        # Create a proxy with undo enabled\n        document = Document(title=\"Draft\", content=\"Hello\")\n        proxy = ObservableProxy(document, undo=True)\n\n        # Make some changes\n        proxy.observable(str, \"content\").set(\"Hello world\")\n        proxy.observable(str, \"content\").set(\"Hello world!\")\n\n        # Undo the last change\n        proxy.undo(\"content\")  # Content is now \"Hello world\"\n\n        # Undo again\n        proxy.undo(\"content\")  # Content is now \"Hello\"\n        ```\n    \"\"\"\n    print(f\"DEBUG: undo called for {attr}\")\n\n    if attr not in self._undo_stacks or not self._undo_stacks[attr]:\n        print(f\"DEBUG: undo - Nothing to undo for {attr}\")\n        return  # Nothing to undo\n\n    # Pop the most recent undo function\n    undo_func = self._undo_stacks[attr].pop()\n    print(f\"DEBUG: undo - Popped undo function from stack for {attr}, remaining: {len(self._undo_stacks[attr])}\")\n\n    # Get the pending redo function\n    redo_func = self._pending_undo_groups.get(attr)\n    print(f\"DEBUG: undo - Got pending redo function for {attr}: {redo_func is not None}\")\n\n    # Add to the redo stack if it exists\n    if redo_func is not None:\n        self._redo_stacks[attr].append(redo_func)\n        print(f\"DEBUG: undo - Added redo function to stack for {attr}\")\n        self._pending_undo_groups[attr] = None\n        print(f\"DEBUG: undo - Cleared pending undo group for {attr}\")\n\n    # Find the observable for this field to set the undoing flag\n    obs = None\n    for key, o in self._scalars.items():\n        if key.attr == attr:\n            obs = o\n            break\n\n    # Execute the undo function with undoing flag set\n    print(f\"DEBUG: undo - Executing undo function for {attr}\")\n    print(f\"DEBUG: undo - undo_func: {undo_func}\")\n\n    # Set the undoing flag if we found the observable and it's a UndoableObservable\n    from observant.undoable_observable import UndoableObservable\n\n    if obs is not None and isinstance(obs, UndoableObservable):\n        obs.set_undoing(True)\n\n    try:\n        undo_func()\n    finally:\n        # Reset the undoing flag\n        if obs is not None and isinstance(obs, UndoableObservable):\n            obs.set_undoing(False)\n\n    print(f\"DEBUG: undo - Completed for {attr}\")\n\n    # If sync is enabled for this field, update the model\n    for key in self._scalars:\n        if key.attr == attr and key.sync:\n            value = self._scalars[key].get()\n            setattr(self._obj, attr, value)\n            print(f\"DEBUG: undo - Synced {attr} to model with value {value}\")\n            break\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.update","title":"<code>update(**kwargs)</code>","text":"<p>Set one or more scalar observable values.</p> <p>This is a convenience method for setting multiple scalar values at once. It creates observables for any fields that don't already have them.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Keyword arguments where each key is a field name and each value      is the new value to set for that field.</p> <code>{}</code> <p>Examples:</p> <pre><code># Update multiple fields at once\nproxy.update(name=\"Alice\", age=30, active=True)\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef update(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Set one or more scalar observable values.\n\n    This is a convenience method for setting multiple scalar values at once.\n    It creates observables for any fields that don't already have them.\n\n    Args:\n        **kwargs: Keyword arguments where each key is a field name and each value\n                 is the new value to set for that field.\n\n    Examples:\n        ```python\n        # Update multiple fields at once\n        proxy.update(name=\"Alice\", age=30, active=True)\n        ```\n    \"\"\"\n    for attr, value in kwargs.items():\n        self.observable(object, attr).set(value)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.validation_errors","title":"<code>validation_errors()</code>","text":"<p>Get an observable dictionary of validation errors.</p> <p>This method returns an observable dictionary that maps field names to lists of error messages. The dictionary is updated automatically when field values change and validation is performed.</p> <p>Returns:</p> Type Description <code>IObservableDict[str, list[str]]</code> <p>An observable dictionary mapping field names to lists of error messages.</p> <code>IObservableDict[str, list[str]]</code> <p>Fields with no errors are not included in the dictionary.</p> <p>Examples:</p> <pre><code># Create a proxy with validation\nuser = User(name=\"\", age=-5)\nproxy = ObservableProxy(user)\n\n# Add validators\nproxy.add_validator(\"name\", lambda name: \"Name cannot be empty\" if not name else None)\nproxy.add_validator(\"age\", lambda age: \"Age must be positive\" if age &lt; 0 else None)\n\n# Get validation errors\nerrors = proxy.validation_errors()\nprint(dict(errors))  # Prints: {'name': ['Name cannot be empty'], 'age': ['Age must be positive']}\n\n# Fix one error\nproxy.observable(str, \"name\").set(\"Alice\")\nprint(dict(errors))  # Prints: {'age': ['Age must be positive']}\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef validation_errors(self) -&gt; IObservableDict[str, list[str]]:\n    \"\"\"\n    Get an observable dictionary of validation errors.\n\n    This method returns an observable dictionary that maps field names to lists\n    of error messages. The dictionary is updated automatically when field values\n    change and validation is performed.\n\n    Returns:\n        An observable dictionary mapping field names to lists of error messages.\n        Fields with no errors are not included in the dictionary.\n\n    Examples:\n        ```python\n        # Create a proxy with validation\n        user = User(name=\"\", age=-5)\n        proxy = ObservableProxy(user)\n\n        # Add validators\n        proxy.add_validator(\"name\", lambda name: \"Name cannot be empty\" if not name else None)\n        proxy.add_validator(\"age\", lambda age: \"Age must be positive\" if age &lt; 0 else None)\n\n        # Get validation errors\n        errors = proxy.validation_errors()\n        print(dict(errors))  # Prints: {'name': ['Name cannot be empty'], 'age': ['Age must be positive']}\n\n        # Fix one error\n        proxy.observable(str, \"name\").set(\"Alice\")\n        print(dict(errors))  # Prints: {'age': ['Age must be positive']}\n        ```\n    \"\"\"\n    return self._validation_errors_dict\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.validation_for","title":"<code>validation_for(attr)</code>","text":"<p>Get an observable list of validation errors for a specific field.</p> <p>This method returns an observable that emits a list of error messages for the specified field. The observable updates automatically when the field value changes and validation is performed.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to get validation errors for.</p> required <p>Returns:</p> Type Description <code>IObservable[list[str]]</code> <p>An observable that emits a list of error messages for the field.</p> <code>IObservable[list[str]]</code> <p>An empty list means the field is valid.</p> <p>Examples:</p> <pre><code># Create a proxy with validation\nuser = User(name=\"\", age=30)\nproxy = ObservableProxy(user)\n\n# Add validators for the name field\nproxy.add_validator(\"name\", lambda name: \"Name cannot be empty\" if not name else None)\nproxy.add_validator(\"name\", lambda name: \"Name too long\" if len(name) &gt; 50 else None)\n\n# Get validation errors for the name field\nname_errors = proxy.validation_for(\"name\")\nprint(name_errors.get())  # Prints: ['Name cannot be empty']\n\n# Fix the error\nproxy.observable(str, \"name\").set(\"Alice\")\nprint(name_errors.get())  # Prints: []\n</code></pre> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef validation_for(self, attr: str) -&gt; IObservable[list[str]]:\n    \"\"\"\n    Get an observable list of validation errors for a specific field.\n\n    This method returns an observable that emits a list of error messages for\n    the specified field. The observable updates automatically when the field\n    value changes and validation is performed.\n\n    Args:\n        attr: The field name to get validation errors for.\n\n    Returns:\n        An observable that emits a list of error messages for the field.\n        An empty list means the field is valid.\n\n    Examples:\n        ```python\n        # Create a proxy with validation\n        user = User(name=\"\", age=30)\n        proxy = ObservableProxy(user)\n\n        # Add validators for the name field\n        proxy.add_validator(\"name\", lambda name: \"Name cannot be empty\" if not name else None)\n        proxy.add_validator(\"name\", lambda name: \"Name too long\" if len(name) &gt; 50 else None)\n\n        # Get validation errors for the name field\n        name_errors = proxy.validation_for(\"name\")\n        print(name_errors.get())  # Prints: ['Name cannot be empty']\n\n        # Fix the error\n        proxy.observable(str, \"name\").set(\"Alice\")\n        print(name_errors.get())  # Prints: []\n        ```\n    \"\"\"\n    if attr not in self._validation_for_cache:\n        # Create a computed observable that depends on the validation errors dict\n        initial_value = self._validation_errors_dict.get(attr) or []\n        obs = Observable[list[str]](initial_value)\n\n        # Update the observable when the validation errors dict changes\n        def update_validation(_: Any) -&gt; None:\n            new_value = self._validation_errors_dict.get(attr) or []\n            current = obs.get()\n            if new_value != current:\n                obs.set(new_value)\n\n        self._validation_errors_dict.on_change(update_validation)\n        self._validation_for_cache[attr] = obs\n\n    return self._validation_for_cache[attr]\n</code></pre>"},{"location":"api_reference/interfaces/","title":"Interfaces","text":""},{"location":"api_reference/interfaces/#observant.interfaces.observable.IObservable","title":"<code>observant.interfaces.observable.IObservable</code>","text":"<p>               Bases: <code>Generic[T]</code></p> Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>class IObservable(Generic[T]):\n    def get(self) -&gt; T:\n        \"\"\"\n        Get the current value of the observable.\n\n        Returns:\n            The current value.\n        \"\"\"\n        ...\n\n    def set(self, value: T, notify: bool = True) -&gt; None:\n        \"\"\"\n        Set a new value for the observable and notify all registered callbacks.\n\n        Args:\n            value: The new value to set.\n            notify: Whether to notify the callbacks after setting the value.\n        \"\"\"\n        ...\n\n    def on_change(self, callback: Callable[[T], None]) -&gt; None:\n        \"\"\"\n        Register a callback function to be called when the value changes.\n\n        Args:\n            callback: A function that takes the new value as its argument.\n        \"\"\"\n        ...\n\n    def enable(self) -&gt; None:\n        \"\"\"\n        Enable the observable to notify changes.\n        \"\"\"\n        ...\n\n    def disable(self) -&gt; None:\n        \"\"\"\n        Disable the observable from notifying changes.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.observable.IObservable.disable","title":"<code>disable()</code>","text":"<p>Disable the observable from notifying changes.</p> Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>def disable(self) -&gt; None:\n    \"\"\"\n    Disable the observable from notifying changes.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.observable.IObservable.enable","title":"<code>enable()</code>","text":"<p>Enable the observable to notify changes.</p> Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>def enable(self) -&gt; None:\n    \"\"\"\n    Enable the observable to notify changes.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.observable.IObservable.get","title":"<code>get()</code>","text":"<p>Get the current value of the observable.</p> <p>Returns:</p> Type Description <code>T</code> <p>The current value.</p> Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>def get(self) -&gt; T:\n    \"\"\"\n    Get the current value of the observable.\n\n    Returns:\n        The current value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.observable.IObservable.on_change","title":"<code>on_change(callback)</code>","text":"<p>Register a callback function to be called when the value changes.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[T], None]</code> <p>A function that takes the new value as its argument.</p> required Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>def on_change(self, callback: Callable[[T], None]) -&gt; None:\n    \"\"\"\n    Register a callback function to be called when the value changes.\n\n    Args:\n        callback: A function that takes the new value as its argument.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.observable.IObservable.set","title":"<code>set(value, notify=True)</code>","text":"<p>Set a new value for the observable and notify all registered callbacks.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The new value to set.</p> required <code>notify</code> <code>bool</code> <p>Whether to notify the callbacks after setting the value.</p> <code>True</code> Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>def set(self, value: T, notify: bool = True) -&gt; None:\n    \"\"\"\n    Set a new value for the observable and notify all registered callbacks.\n\n    Args:\n        value: The new value to set.\n        notify: Whether to notify the callbacks after setting the value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList","title":"<code>observant.interfaces.list.IObservableList</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Interface for observable lists with specific event types.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>class IObservableList(Generic[T], ABC):\n    \"\"\"Interface for observable lists with specific event types.\"\"\"\n\n    @abstractmethod\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of items in the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def __getitem__(self, index: int | slice) -&gt; T | list[T]:\n        \"\"\"Get an item or slice of items from the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def __setitem__(self, index: int | slice, value: T | list[T]) -&gt; None:\n        \"\"\"Set an item or slice of items in the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def __delitem__(self, index: int | slice) -&gt; None:\n        \"\"\"Delete an item or slice of items from the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def __iter__(self) -&gt; Iterator[T]:\n        \"\"\"Return an iterator over the items in the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def __contains__(self, item: T) -&gt; bool:\n        \"\"\"Check if an item is in the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def append(self, item: T) -&gt; None:\n        \"\"\"Add an item to the end of the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def extend(self, items: list[T]) -&gt; None:\n        \"\"\"Extend the list by appending all items from the iterable.\"\"\"\n        ...\n\n    @abstractmethod\n    def insert(self, index: int, item: T) -&gt; None:\n        \"\"\"Insert an item at a given position.\"\"\"\n        ...\n\n    @abstractmethod\n    def remove(self, item: T) -&gt; None:\n        \"\"\"Remove the first occurrence of an item from the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def pop(self, index: int = -1) -&gt; T:\n        \"\"\"Remove and return an item at a given position.\"\"\"\n        ...\n\n    @abstractmethod\n    def clear(self) -&gt; None:\n        \"\"\"Remove all items from the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def index(self, item: T, start: int = 0, end: int | None = None) -&gt; int:\n        \"\"\"Return the index of the first occurrence of an item.\"\"\"\n        ...\n\n    @abstractmethod\n    def count(self, item: T) -&gt; int:\n        \"\"\"Return the number of occurrences of an item in the list.\"\"\"\n        ...\n\n    @overload\n    def sort(self, *, key: None = None, reverse: bool = False) -&gt; None: ...\n\n    @overload\n    def sort(self, *, key: Callable[[T], Any], reverse: bool = False) -&gt; None: ...\n\n    @abstractmethod\n    def sort(\n        self,\n        *,\n        key: Callable[[T], Any] | None = None,\n        reverse: bool = False,\n    ) -&gt; None: ...\n\n    @abstractmethod\n    def reverse(self) -&gt; None:\n        \"\"\"Reverse the list in place.\"\"\"\n        ...\n\n    @abstractmethod\n    def copy(self) -&gt; list[T]:\n        \"\"\"Return a shallow copy of the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_change(self, callback: Callable[[ObservableListChange[T]], None]) -&gt; None:\n        \"\"\"Register for all change events with detailed information.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_add(self, callback: Callable[[T, int], None]) -&gt; None:\n        \"\"\"Register for add events with item and index.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_remove(self, callback: Callable[[T, int], None]) -&gt; None:\n        \"\"\"Register for remove events with item and index.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_clear(self, callback: Callable[[list[T]], None]) -&gt; None:\n        \"\"\"Register for clear events with the cleared items.\"\"\"\n        ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.__contains__","title":"<code>__contains__(item)</code>  <code>abstractmethod</code>","text":"<p>Check if an item is in the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __contains__(self, item: T) -&gt; bool:\n    \"\"\"Check if an item is in the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.__delitem__","title":"<code>__delitem__(index)</code>  <code>abstractmethod</code>","text":"<p>Delete an item or slice of items from the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __delitem__(self, index: int | slice) -&gt; None:\n    \"\"\"Delete an item or slice of items from the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.__getitem__","title":"<code>__getitem__(index)</code>  <code>abstractmethod</code>","text":"<p>Get an item or slice of items from the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __getitem__(self, index: int | slice) -&gt; T | list[T]:\n    \"\"\"Get an item or slice of items from the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.__iter__","title":"<code>__iter__()</code>  <code>abstractmethod</code>","text":"<p>Return an iterator over the items in the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __iter__(self) -&gt; Iterator[T]:\n    \"\"\"Return an iterator over the items in the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.__len__","title":"<code>__len__()</code>  <code>abstractmethod</code>","text":"<p>Return the number of items in the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __len__(self) -&gt; int:\n    \"\"\"Return the number of items in the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.__setitem__","title":"<code>__setitem__(index, value)</code>  <code>abstractmethod</code>","text":"<p>Set an item or slice of items in the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __setitem__(self, index: int | slice, value: T | list[T]) -&gt; None:\n    \"\"\"Set an item or slice of items in the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.append","title":"<code>append(item)</code>  <code>abstractmethod</code>","text":"<p>Add an item to the end of the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef append(self, item: T) -&gt; None:\n    \"\"\"Add an item to the end of the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.clear","title":"<code>clear()</code>  <code>abstractmethod</code>","text":"<p>Remove all items from the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef clear(self) -&gt; None:\n    \"\"\"Remove all items from the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.copy","title":"<code>copy()</code>  <code>abstractmethod</code>","text":"<p>Return a shallow copy of the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef copy(self) -&gt; list[T]:\n    \"\"\"Return a shallow copy of the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.count","title":"<code>count(item)</code>  <code>abstractmethod</code>","text":"<p>Return the number of occurrences of an item in the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef count(self, item: T) -&gt; int:\n    \"\"\"Return the number of occurrences of an item in the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.extend","title":"<code>extend(items)</code>  <code>abstractmethod</code>","text":"<p>Extend the list by appending all items from the iterable.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef extend(self, items: list[T]) -&gt; None:\n    \"\"\"Extend the list by appending all items from the iterable.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.index","title":"<code>index(item, start=0, end=None)</code>  <code>abstractmethod</code>","text":"<p>Return the index of the first occurrence of an item.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef index(self, item: T, start: int = 0, end: int | None = None) -&gt; int:\n    \"\"\"Return the index of the first occurrence of an item.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.insert","title":"<code>insert(index, item)</code>  <code>abstractmethod</code>","text":"<p>Insert an item at a given position.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef insert(self, index: int, item: T) -&gt; None:\n    \"\"\"Insert an item at a given position.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.on_add","title":"<code>on_add(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for add events with item and index.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef on_add(self, callback: Callable[[T, int], None]) -&gt; None:\n    \"\"\"Register for add events with item and index.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.on_change","title":"<code>on_change(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for all change events with detailed information.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef on_change(self, callback: Callable[[ObservableListChange[T]], None]) -&gt; None:\n    \"\"\"Register for all change events with detailed information.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.on_clear","title":"<code>on_clear(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for clear events with the cleared items.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef on_clear(self, callback: Callable[[list[T]], None]) -&gt; None:\n    \"\"\"Register for clear events with the cleared items.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.on_remove","title":"<code>on_remove(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for remove events with item and index.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef on_remove(self, callback: Callable[[T, int], None]) -&gt; None:\n    \"\"\"Register for remove events with item and index.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.pop","title":"<code>pop(index=-1)</code>  <code>abstractmethod</code>","text":"<p>Remove and return an item at a given position.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef pop(self, index: int = -1) -&gt; T:\n    \"\"\"Remove and return an item at a given position.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.remove","title":"<code>remove(item)</code>  <code>abstractmethod</code>","text":"<p>Remove the first occurrence of an item from the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef remove(self, item: T) -&gt; None:\n    \"\"\"Remove the first occurrence of an item from the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.reverse","title":"<code>reverse()</code>  <code>abstractmethod</code>","text":"<p>Reverse the list in place.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef reverse(self) -&gt; None:\n    \"\"\"Reverse the list in place.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict","title":"<code>observant.interfaces.dict.IObservableDict</code>","text":"<p>               Bases: <code>Generic[TKey, TValue]</code>, <code>ABC</code></p> <p>Interface for observable dictionaries with specific event types.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>class IObservableDict(Generic[TKey, TValue], ABC):\n    \"\"\"Interface for observable dictionaries with specific event types.\"\"\"\n\n    @abstractmethod\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of items in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def __getitem__(self, key: TKey) -&gt; TValue:\n        \"\"\"Get an item from the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def __setitem__(self, key: TKey, value: TValue) -&gt; None:\n        \"\"\"Set an item in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def __delitem__(self, key: TKey) -&gt; None:\n        \"\"\"Delete an item from the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def __iter__(self) -&gt; Iterator[TKey]:\n        \"\"\"Return an iterator over the keys in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def __contains__(self, key: TKey) -&gt; bool:\n        \"\"\"Check if a key is in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def get(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"Return the value for a key if it exists, otherwise return a default value.\"\"\"\n        ...\n\n    @abstractmethod\n    def setdefault(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"Return the value for a key if it exists, otherwise set and return the default value.\"\"\"\n        ...\n\n    @abstractmethod\n    def pop(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"Remove and return the value for a key if it exists, otherwise return a default value.\"\"\"\n        ...\n\n    @abstractmethod\n    def popitem(self) -&gt; tuple[TKey, TValue]:\n        \"\"\"Remove and return a (key, value) pair from the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def clear(self) -&gt; None:\n        \"\"\"Remove all items from the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def update(self, other: dict[TKey, TValue]) -&gt; None:\n        \"\"\"Update the dictionary with the key/value pairs from another dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def keys(self) -&gt; list[TKey]:\n        \"\"\"Return a list of all keys in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def values(self) -&gt; list[TValue]:\n        \"\"\"Return a list of all values in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def items(self) -&gt; list[tuple[TKey, TValue]]:\n        \"\"\"Return a list of all (key, value) pairs in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def copy(self) -&gt; dict[TKey, TValue]:\n        \"\"\"Return a shallow copy of the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_change(\n        self, callback: Callable[[ObservableDictChange[TKey, TValue]], None]\n    ) -&gt; None:\n        \"\"\"Register for all change events with detailed information.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_add(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"Register for add events with key and value.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_remove(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"Register for remove events with key and value.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_update(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"Register for update events with key and new value.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_clear(self, callback: Callable[[dict[TKey, TValue]], None]) -&gt; None:\n        \"\"\"Register for clear events with the cleared items.\"\"\"\n        ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.__contains__","title":"<code>__contains__(key)</code>  <code>abstractmethod</code>","text":"<p>Check if a key is in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __contains__(self, key: TKey) -&gt; bool:\n    \"\"\"Check if a key is in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.__delitem__","title":"<code>__delitem__(key)</code>  <code>abstractmethod</code>","text":"<p>Delete an item from the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __delitem__(self, key: TKey) -&gt; None:\n    \"\"\"Delete an item from the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.__getitem__","title":"<code>__getitem__(key)</code>  <code>abstractmethod</code>","text":"<p>Get an item from the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __getitem__(self, key: TKey) -&gt; TValue:\n    \"\"\"Get an item from the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.__iter__","title":"<code>__iter__()</code>  <code>abstractmethod</code>","text":"<p>Return an iterator over the keys in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __iter__(self) -&gt; Iterator[TKey]:\n    \"\"\"Return an iterator over the keys in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.__len__","title":"<code>__len__()</code>  <code>abstractmethod</code>","text":"<p>Return the number of items in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __len__(self) -&gt; int:\n    \"\"\"Return the number of items in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.__setitem__","title":"<code>__setitem__(key, value)</code>  <code>abstractmethod</code>","text":"<p>Set an item in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __setitem__(self, key: TKey, value: TValue) -&gt; None:\n    \"\"\"Set an item in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.clear","title":"<code>clear()</code>  <code>abstractmethod</code>","text":"<p>Remove all items from the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef clear(self) -&gt; None:\n    \"\"\"Remove all items from the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.copy","title":"<code>copy()</code>  <code>abstractmethod</code>","text":"<p>Return a shallow copy of the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef copy(self) -&gt; dict[TKey, TValue]:\n    \"\"\"Return a shallow copy of the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.get","title":"<code>get(key, default=None)</code>  <code>abstractmethod</code>","text":"<p>Return the value for a key if it exists, otherwise return a default value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef get(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"Return the value for a key if it exists, otherwise return a default value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.items","title":"<code>items()</code>  <code>abstractmethod</code>","text":"<p>Return a list of all (key, value) pairs in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef items(self) -&gt; list[tuple[TKey, TValue]]:\n    \"\"\"Return a list of all (key, value) pairs in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.keys","title":"<code>keys()</code>  <code>abstractmethod</code>","text":"<p>Return a list of all keys in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef keys(self) -&gt; list[TKey]:\n    \"\"\"Return a list of all keys in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.on_add","title":"<code>on_add(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for add events with key and value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef on_add(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"Register for add events with key and value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.on_change","title":"<code>on_change(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for all change events with detailed information.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef on_change(\n    self, callback: Callable[[ObservableDictChange[TKey, TValue]], None]\n) -&gt; None:\n    \"\"\"Register for all change events with detailed information.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.on_clear","title":"<code>on_clear(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for clear events with the cleared items.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef on_clear(self, callback: Callable[[dict[TKey, TValue]], None]) -&gt; None:\n    \"\"\"Register for clear events with the cleared items.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.on_remove","title":"<code>on_remove(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for remove events with key and value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef on_remove(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"Register for remove events with key and value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.on_update","title":"<code>on_update(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for update events with key and new value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef on_update(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"Register for update events with key and new value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.pop","title":"<code>pop(key, default=None)</code>  <code>abstractmethod</code>","text":"<p>Remove and return the value for a key if it exists, otherwise return a default value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef pop(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"Remove and return the value for a key if it exists, otherwise return a default value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.popitem","title":"<code>popitem()</code>  <code>abstractmethod</code>","text":"<p>Remove and return a (key, value) pair from the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef popitem(self) -&gt; tuple[TKey, TValue]:\n    \"\"\"Remove and return a (key, value) pair from the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.setdefault","title":"<code>setdefault(key, default=None)</code>  <code>abstractmethod</code>","text":"<p>Return the value for a key if it exists, otherwise set and return the default value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef setdefault(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"Return the value for a key if it exists, otherwise set and return the default value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.update","title":"<code>update(other)</code>  <code>abstractmethod</code>","text":"<p>Update the dictionary with the key/value pairs from another dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef update(self, other: dict[TKey, TValue]) -&gt; None:\n    \"\"\"Update the dictionary with the key/value pairs from another dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.values","title":"<code>values()</code>  <code>abstractmethod</code>","text":"<p>Return a list of all values in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef values(self) -&gt; list[TValue]:\n    \"\"\"Return a list of all values in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy","title":"<code>observant.interfaces.proxy.IObservableProxy</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Proxy for a data object that exposes its fields as Observable, ObservableList, or ObservableDict. Provides optional sync behavior to automatically write back to the source model.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>class IObservableProxy(Generic[T], ABC):\n    \"\"\"\n    Proxy for a data object that exposes its fields as Observable, ObservableList, or ObservableDict.\n    Provides optional sync behavior to automatically write back to the source model.\n    \"\"\"\n\n    @abstractmethod\n    def observable(\n        self,\n        typ: type[T],\n        attr: str,\n        *,\n        sync: bool | None = None,\n    ) -&gt; IObservable[T]:\n        \"\"\"\n        Get or create an Observable[T] for a scalar field.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def observable_list(\n        self,\n        typ: type[T],\n        attr: str,\n        *,\n        sync: bool | None = None,\n    ) -&gt; IObservableList[T]:\n        \"\"\"\n        Get or create an ObservableList[T] for a list field.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def observable_dict(\n        self,\n        typ: tuple[type[TKey], type[TValue]],\n        attr: str,\n        *,\n        sync: bool | None = None,\n    ) -&gt; IObservableDict[TKey, TValue]:\n        \"\"\"\n        Get or create an ObservableDict for a dict field.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get(self) -&gt; T:\n        \"\"\"\n        Get the original object being proxied.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Set one or more scalar observable values.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def load_dict(self, values: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Set multiple scalar observable values from a dict.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def save_to(self, obj: T) -&gt; None:\n        \"\"\"\n        Write all observable values back into the given object.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def is_dirty(self) -&gt; bool:\n        \"\"\"\n        Check if any fields have been modified since initialization or last reset.\n\n        Returns:\n            True if any fields have been modified, False otherwise.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def dirty_fields(self) -&gt; set[str]:\n        \"\"\"\n        Get the set of field names that have been modified.\n\n        Returns:\n            A set of field names that have been modified.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def reset_dirty(self) -&gt; None:\n        \"\"\"\n        Reset the dirty state of all fields.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def register_computed(\n        self,\n        name: str,\n        compute: Callable[[], T],\n        dependencies: list[str],\n    ) -&gt; None:\n        \"\"\"\n        Register a computed property that depends on other observables.\n\n        Args:\n            name: The name of the computed property.\n            compute: A function that returns the computed value.\n            dependencies: List of field names that this computed property depends on.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def computed(\n        self,\n        typ: type[T],\n        name: str,\n    ) -&gt; IObservable[T]:\n        \"\"\"\n        Get a computed property by name.\n\n        Args:\n            typ: The type of the computed property.\n            name: The name of the computed property.\n\n        Returns:\n            An observable containing the computed value.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def add_validator(\n        self,\n        attr: str,\n        validator: Callable[[Any], str | None],\n    ) -&gt; None:\n        \"\"\"\n        Add a validator function for a field.\n\n        Args:\n            attr: The field name to validate.\n            validator: A function that takes the field value and returns an error message\n                       if invalid, or None if valid.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def is_valid(self) -&gt; IObservable[bool]:\n        \"\"\"\n        Get an observable that indicates whether all fields are valid.\n\n        Returns:\n            An observable that emits True if all fields are valid, False otherwise.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def validation_errors(self) -&gt; IObservableDict[str, list[str]]:\n        \"\"\"\n        Get an observable dictionary of validation errors.\n\n        Returns:\n            An observable dictionary mapping field names to lists of error messages.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def validation_for(self, attr: str) -&gt; IObservable[list[str]]:\n        \"\"\"\n        Get an observable list of validation errors for a specific field.\n\n        Args:\n            attr: The field name to get validation errors for.\n\n        Returns:\n            An observable that emits a list of error messages for the field.\n            An empty list means the field is valid.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def reset_validation(self, attr: str | None = None, *, revalidate: bool = False) -&gt; None:\n        \"\"\"\n        Reset validation errors for a specific field or all fields.\n\n        Args:\n            attr: The field name to reset validation for. If None, reset all fields.\n            revalidate: Whether to re-run validators after clearing errors.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def set_undo_config(\n        self,\n        attr: str,\n        *,\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Set the undo configuration for a specific field.\n\n        Args:\n            attr: The field name to configure.\n            undo_max: Maximum number of undo steps to store. None means unlimited.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def undo(self, attr: str) -&gt; None:\n        \"\"\"\n        Undo the most recent change to a field.\n\n        Args:\n            attr: The field name to undo changes for.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def redo(self, attr: str) -&gt; None:\n        \"\"\"\n        Redo the most recently undone change to a field.\n\n        Args:\n            attr: The field name to redo changes for.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def can_undo(self, attr: str) -&gt; bool:\n        \"\"\"\n        Check if there are changes that can be undone for a field.\n\n        Args:\n            attr: The field name to check.\n\n        Returns:\n            True if there are changes that can be undone, False otherwise.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def can_redo(self, attr: str) -&gt; bool:\n        \"\"\"\n        Check if there are changes that can be redone for a field.\n\n        Args:\n            attr: The field name to check.\n\n        Returns:\n            True if there are changes that can be redone, False otherwise.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def track_scalar_change(self, attr: str, old_value: Any, new_value: Any) -&gt; None:\n        \"\"\"\n        Track a scalar change for undo/redo functionality.\n\n        Args:\n            attr: The field name that changed.\n            old_value: The old value before the change.\n            new_value: The new value after the change.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.add_validator","title":"<code>add_validator(attr, validator)</code>  <code>abstractmethod</code>","text":"<p>Add a validator function for a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to validate.</p> required <code>validator</code> <code>Callable[[Any], str | None]</code> <p>A function that takes the field value and returns an error message        if invalid, or None if valid.</p> required Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef add_validator(\n    self,\n    attr: str,\n    validator: Callable[[Any], str | None],\n) -&gt; None:\n    \"\"\"\n    Add a validator function for a field.\n\n    Args:\n        attr: The field name to validate.\n        validator: A function that takes the field value and returns an error message\n                   if invalid, or None if valid.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.can_redo","title":"<code>can_redo(attr)</code>  <code>abstractmethod</code>","text":"<p>Check if there are changes that can be redone for a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there are changes that can be redone, False otherwise.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef can_redo(self, attr: str) -&gt; bool:\n    \"\"\"\n    Check if there are changes that can be redone for a field.\n\n    Args:\n        attr: The field name to check.\n\n    Returns:\n        True if there are changes that can be redone, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.can_undo","title":"<code>can_undo(attr)</code>  <code>abstractmethod</code>","text":"<p>Check if there are changes that can be undone for a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there are changes that can be undone, False otherwise.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef can_undo(self, attr: str) -&gt; bool:\n    \"\"\"\n    Check if there are changes that can be undone for a field.\n\n    Args:\n        attr: The field name to check.\n\n    Returns:\n        True if there are changes that can be undone, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.computed","title":"<code>computed(typ, name)</code>  <code>abstractmethod</code>","text":"<p>Get a computed property by name.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>type[T]</code> <p>The type of the computed property.</p> required <code>name</code> <code>str</code> <p>The name of the computed property.</p> required <p>Returns:</p> Type Description <code>IObservable[T]</code> <p>An observable containing the computed value.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef computed(\n    self,\n    typ: type[T],\n    name: str,\n) -&gt; IObservable[T]:\n    \"\"\"\n    Get a computed property by name.\n\n    Args:\n        typ: The type of the computed property.\n        name: The name of the computed property.\n\n    Returns:\n        An observable containing the computed value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.dirty_fields","title":"<code>dirty_fields()</code>  <code>abstractmethod</code>","text":"<p>Get the set of field names that have been modified.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of field names that have been modified.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef dirty_fields(self) -&gt; set[str]:\n    \"\"\"\n    Get the set of field names that have been modified.\n\n    Returns:\n        A set of field names that have been modified.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.get","title":"<code>get()</code>  <code>abstractmethod</code>","text":"<p>Get the original object being proxied.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef get(self) -&gt; T:\n    \"\"\"\n    Get the original object being proxied.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.is_dirty","title":"<code>is_dirty()</code>  <code>abstractmethod</code>","text":"<p>Check if any fields have been modified since initialization or last reset.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if any fields have been modified, False otherwise.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef is_dirty(self) -&gt; bool:\n    \"\"\"\n    Check if any fields have been modified since initialization or last reset.\n\n    Returns:\n        True if any fields have been modified, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.is_valid","title":"<code>is_valid()</code>  <code>abstractmethod</code>","text":"<p>Get an observable that indicates whether all fields are valid.</p> <p>Returns:</p> Type Description <code>IObservable[bool]</code> <p>An observable that emits True if all fields are valid, False otherwise.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef is_valid(self) -&gt; IObservable[bool]:\n    \"\"\"\n    Get an observable that indicates whether all fields are valid.\n\n    Returns:\n        An observable that emits True if all fields are valid, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.load_dict","title":"<code>load_dict(values)</code>  <code>abstractmethod</code>","text":"<p>Set multiple scalar observable values from a dict.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef load_dict(self, values: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Set multiple scalar observable values from a dict.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.observable","title":"<code>observable(typ, attr, *, sync=None)</code>  <code>abstractmethod</code>","text":"<p>Get or create an Observable[T] for a scalar field.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef observable(\n    self,\n    typ: type[T],\n    attr: str,\n    *,\n    sync: bool | None = None,\n) -&gt; IObservable[T]:\n    \"\"\"\n    Get or create an Observable[T] for a scalar field.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.observable_dict","title":"<code>observable_dict(typ, attr, *, sync=None)</code>  <code>abstractmethod</code>","text":"<p>Get or create an ObservableDict for a dict field.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef observable_dict(\n    self,\n    typ: tuple[type[TKey], type[TValue]],\n    attr: str,\n    *,\n    sync: bool | None = None,\n) -&gt; IObservableDict[TKey, TValue]:\n    \"\"\"\n    Get or create an ObservableDict for a dict field.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.observable_list","title":"<code>observable_list(typ, attr, *, sync=None)</code>  <code>abstractmethod</code>","text":"<p>Get or create an ObservableList[T] for a list field.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef observable_list(\n    self,\n    typ: type[T],\n    attr: str,\n    *,\n    sync: bool | None = None,\n) -&gt; IObservableList[T]:\n    \"\"\"\n    Get or create an ObservableList[T] for a list field.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.redo","title":"<code>redo(attr)</code>  <code>abstractmethod</code>","text":"<p>Redo the most recently undone change to a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to redo changes for.</p> required Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef redo(self, attr: str) -&gt; None:\n    \"\"\"\n    Redo the most recently undone change to a field.\n\n    Args:\n        attr: The field name to redo changes for.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.register_computed","title":"<code>register_computed(name, compute, dependencies)</code>  <code>abstractmethod</code>","text":"<p>Register a computed property that depends on other observables.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the computed property.</p> required <code>compute</code> <code>Callable[[], T]</code> <p>A function that returns the computed value.</p> required <code>dependencies</code> <code>list[str]</code> <p>List of field names that this computed property depends on.</p> required Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef register_computed(\n    self,\n    name: str,\n    compute: Callable[[], T],\n    dependencies: list[str],\n) -&gt; None:\n    \"\"\"\n    Register a computed property that depends on other observables.\n\n    Args:\n        name: The name of the computed property.\n        compute: A function that returns the computed value.\n        dependencies: List of field names that this computed property depends on.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.reset_dirty","title":"<code>reset_dirty()</code>  <code>abstractmethod</code>","text":"<p>Reset the dirty state of all fields.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef reset_dirty(self) -&gt; None:\n    \"\"\"\n    Reset the dirty state of all fields.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.reset_validation","title":"<code>reset_validation(attr=None, *, revalidate=False)</code>  <code>abstractmethod</code>","text":"<p>Reset validation errors for a specific field or all fields.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str | None</code> <p>The field name to reset validation for. If None, reset all fields.</p> <code>None</code> <code>revalidate</code> <code>bool</code> <p>Whether to re-run validators after clearing errors.</p> <code>False</code> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef reset_validation(self, attr: str | None = None, *, revalidate: bool = False) -&gt; None:\n    \"\"\"\n    Reset validation errors for a specific field or all fields.\n\n    Args:\n        attr: The field name to reset validation for. If None, reset all fields.\n        revalidate: Whether to re-run validators after clearing errors.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.save_to","title":"<code>save_to(obj)</code>  <code>abstractmethod</code>","text":"<p>Write all observable values back into the given object.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef save_to(self, obj: T) -&gt; None:\n    \"\"\"\n    Write all observable values back into the given object.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.set_undo_config","title":"<code>set_undo_config(attr, *, undo_max=None, undo_debounce_ms=None)</code>  <code>abstractmethod</code>","text":"<p>Set the undo configuration for a specific field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to configure.</p> required <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means unlimited.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means no debouncing.</p> <code>None</code> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef set_undo_config(\n    self,\n    attr: str,\n    *,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Set the undo configuration for a specific field.\n\n    Args:\n        attr: The field name to configure.\n        undo_max: Maximum number of undo steps to store. None means unlimited.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.track_scalar_change","title":"<code>track_scalar_change(attr, old_value, new_value)</code>  <code>abstractmethod</code>","text":"<p>Track a scalar change for undo/redo functionality.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name that changed.</p> required <code>old_value</code> <code>Any</code> <p>The old value before the change.</p> required <code>new_value</code> <code>Any</code> <p>The new value after the change.</p> required Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef track_scalar_change(self, attr: str, old_value: Any, new_value: Any) -&gt; None:\n    \"\"\"\n    Track a scalar change for undo/redo functionality.\n\n    Args:\n        attr: The field name that changed.\n        old_value: The old value before the change.\n        new_value: The new value after the change.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.undo","title":"<code>undo(attr)</code>  <code>abstractmethod</code>","text":"<p>Undo the most recent change to a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to undo changes for.</p> required Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef undo(self, attr: str) -&gt; None:\n    \"\"\"\n    Undo the most recent change to a field.\n\n    Args:\n        attr: The field name to undo changes for.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.update","title":"<code>update(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Set one or more scalar observable values.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef update(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Set one or more scalar observable values.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.validation_errors","title":"<code>validation_errors()</code>  <code>abstractmethod</code>","text":"<p>Get an observable dictionary of validation errors.</p> <p>Returns:</p> Type Description <code>IObservableDict[str, list[str]]</code> <p>An observable dictionary mapping field names to lists of error messages.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef validation_errors(self) -&gt; IObservableDict[str, list[str]]:\n    \"\"\"\n    Get an observable dictionary of validation errors.\n\n    Returns:\n        An observable dictionary mapping field names to lists of error messages.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.validation_for","title":"<code>validation_for(attr)</code>  <code>abstractmethod</code>","text":"<p>Get an observable list of validation errors for a specific field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to get validation errors for.</p> required <p>Returns:</p> Type Description <code>IObservable[list[str]]</code> <p>An observable that emits a list of error messages for the field.</p> <code>IObservable[list[str]]</code> <p>An empty list means the field is valid.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef validation_for(self, attr: str) -&gt; IObservable[list[str]]:\n    \"\"\"\n    Get an observable list of validation errors for a specific field.\n\n    Args:\n        attr: The field name to get validation errors for.\n\n    Returns:\n        An observable that emits a list of error messages for the field.\n        An empty list means the field is valid.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/types/","title":"Types","text":""},{"location":"api_reference/types/#observant.types.collection_change_type.ObservableCollectionChangeType","title":"<code>observant.types.collection_change_type.ObservableCollectionChangeType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Type of change that occurred in a collection.</p> Source code in <code>observant\\types\\collection_change_type.py</code> <pre><code>class ObservableCollectionChangeType(Enum):\n    \"\"\"Type of change that occurred in a collection.\"\"\"\n\n    ADD = auto()\n    REMOVE = auto()\n    CLEAR = auto()\n    UPDATE = auto()  # For dictionaries, when a value is updated\n</code></pre>"},{"location":"api_reference/types/#observant.types.list_change.ObservableListChange","title":"<code>observant.types.list_change.ObservableListChange</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Information about a change to an ObservableList.</p> Source code in <code>observant\\types\\list_change.py</code> <pre><code>@dataclass(frozen=True)\nclass ObservableListChange(Generic[T]):\n    \"\"\"Information about a change to an ObservableList.\"\"\"\n\n    type: ObservableCollectionChangeType\n    index: int | None = None  # Index where the change occurred, if applicable\n    item: T | None = None  # Item that was added or removed, if applicable\n    items: list[T] | None = None  # Multiple items that were added or removed, if applicable\n</code></pre>"},{"location":"api_reference/types/#observant.types.dict_change.ObservableDictChange","title":"<code>observant.types.dict_change.ObservableDictChange</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[TKey, TValue]</code></p> <p>Information about a change to an ObservableDict.</p> Source code in <code>observant\\types\\dict_change.py</code> <pre><code>@dataclass(frozen=True)\nclass ObservableDictChange(Generic[TKey, TValue]):\n    \"\"\"Information about a change to an ObservableDict.\"\"\"\n\n    type: ObservableCollectionChangeType\n    key: TKey | None = None  # Key where the change occurred, if applicable\n    value: TValue | None = (\n        None  # Value that was added, removed, or updated, if applicable\n    )\n    items: dict[TKey, TValue] | None = (\n        None  # Multiple items that were added, removed, or updated, if applicable\n    )\n</code></pre>"},{"location":"api_reference/types/#observant.types.proxy_field_key.ProxyFieldKey","title":"<code>observant.types.proxy_field_key.ProxyFieldKey</code>  <code>dataclass</code>","text":"Source code in <code>observant\\types\\proxy_field_key.py</code> <pre><code>@dataclass(frozen=True)\nclass ProxyFieldKey:\n    attr: str\n    sync: bool\n</code></pre>"},{"location":"api_reference/types/#observant.types.undo_config.UndoConfig","title":"<code>observant.types.undo_config.UndoConfig</code>  <code>dataclass</code>","text":"<p>Configuration for undo/redo behavior of an observable field.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>Whether undo/redo functionality is enabled for this field.</p> <code>undo_max</code> <code>Optional[int]</code> <p>Maximum number of undo steps to store. None means unlimited.</p> <code>undo_debounce_ms</code> <code>Optional[int]</code> <p>Time window in milliseconds to group changes. None means no debouncing.</p> Source code in <code>observant\\types\\undo_config.py</code> <pre><code>@dataclass\nclass UndoConfig:\n    \"\"\"\n    Configuration for undo/redo behavior of an observable field.\n\n    Attributes:\n        enabled: Whether undo/redo functionality is enabled for this field.\n        undo_max: Maximum number of undo steps to store. None means unlimited.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n    \"\"\"\n\n    enabled: bool = False\n    undo_max: Optional[int] = 50\n    undo_debounce_ms: Optional[int] = None\n</code></pre>"},{"location":"features/change_tracking/","title":"Change Tracking","text":"<p>At the core of Observant is the ability to track changes to your data and react to those changes. This page explains how change tracking works in Observant.</p>"},{"location":"features/change_tracking/#overview","title":"Overview","text":"<p>Observant provides three main types of observable objects:</p> <ol> <li>Observable: For tracking changes to scalar values (strings, numbers, booleans, etc.)</li> <li>ObservableList: For tracking changes to lists</li> <li>ObservableDict: For tracking changes to dictionaries</li> </ol> <p>Each of these objects allows you to register callbacks that are called when the value changes.</p>"},{"location":"features/change_tracking/#scalar-observables","title":"Scalar Observables","text":"<p>The <code>Observable</code> class is the simplest form of change tracking in Observant. It wraps a single value and notifies listeners when that value changes.</p> <pre><code>from observant import Observable\n\n# Create an observable with an initial value\ncounter = Observable[int](0)\n\n# Register a callback to be notified when the value changes\ncounter.on_change(lambda value: print(f\"Counter changed to: {value}\"))\n\n# Change the value\ncounter.set(1)  # Prints: \"Counter changed to: 1\"\n\n# Get the current value\ncurrent_value = counter.get()  # Returns: 1\n</code></pre>"},{"location":"features/change_tracking/#multiple-callbacks","title":"Multiple Callbacks","text":"<p>You can register multiple callbacks for the same observable:</p> <pre><code>counter = Observable[int](0)\n\n# Register multiple callbacks\ncounter.on_change(lambda value: print(f\"Callback 1: {value}\"))\ncounter.on_change(lambda value: print(f\"Callback 2: {value}\"))\n\n# Change the value\ncounter.set(1)  # Prints both callback messages\n</code></pre>"},{"location":"features/change_tracking/#suppressing-notifications","title":"Suppressing Notifications","text":"<p>Sometimes you may want to update a value without triggering callbacks. You can do this by setting <code>notify=False</code>:</p> <pre><code>counter = Observable[int](0)\ncounter.on_change(lambda value: print(f\"Counter changed to: {value}\"))\n\n# Update without notification\ncounter.set(1, notify=False)  # No callback is triggered\n\n# The value is still updated\nprint(counter.get())  # Prints: 1\n</code></pre>"},{"location":"features/change_tracking/#list-observables","title":"List Observables","text":"<p>The <code>ObservableList</code> class tracks changes to a list, including additions, removals, and modifications.</p> <pre><code>from observant import ObservableList, ObservableCollectionChangeType\n\n# Create an observable list\ntasks = ObservableList[str]([\"Task 1\"])\n\n# Register a callback\ndef on_tasks_change(change):\n    if change.type == ObservableCollectionChangeType.ADD:\n        if hasattr(change, \"item\"):\n            print(f\"Added task: {change.item}\")\n        else:\n            print(f\"Added tasks: {change.items}\")\n    elif change.type == ObservableCollectionChangeType.REMOVE:\n        if hasattr(change, \"item\"):\n            print(f\"Removed task: {change.item}\")\n        else:\n            print(f\"Removed tasks: {change.items}\")\n    elif change.type == ObservableCollectionChangeType.CLEAR:\n        print(f\"Cleared tasks: {change.items}\")\n\ntasks.on_change(on_tasks_change)\n\n# Add an item\ntasks.append(\"Task 2\")  # Prints: \"Added task: Task 2\"\n\n# Add multiple items\ntasks.extend([\"Task 3\", \"Task 4\"])  # Prints: \"Added tasks: ['Task 3', 'Task 4']\"\n\n# Remove an item\ntasks.remove(\"Task 1\")  # Prints: \"Removed task: Task 1\"\n\n# Clear the list\ntasks.clear()  # Prints: \"Cleared tasks: ['Task 2', 'Task 3', 'Task 4']\"\n</code></pre>"},{"location":"features/change_tracking/#list-change-information","title":"List Change Information","text":"<p>When a list changes, the callback receives a <code>ObservableListChange</code> object with the following properties:</p> <ul> <li><code>type</code>: The type of change (ADD, REMOVE, CLEAR)</li> <li><code>index</code>: The index where the change occurred (for ADD and REMOVE)</li> <li><code>item</code>: The item that was added or removed (for single-item changes)</li> <li><code>items</code>: The items that were added or removed (for multi-item changes)</li> </ul>"},{"location":"features/change_tracking/#list-operations","title":"List Operations","text":"<p><code>ObservableList</code> supports all standard Python list operations, including:</p> <ul> <li><code>append(item)</code>: Add an item to the end of the list</li> <li><code>extend(items)</code>: Add multiple items to the end of the list</li> <li><code>insert(index, item)</code>: Insert an item at a specific index</li> <li><code>remove(item)</code>: Remove an item from the list</li> <li><code>pop([index])</code>: Remove and return an item at a specific index (or the last item if no index is provided)</li> <li><code>clear()</code>: Remove all items from the list</li> <li><code>sort()</code>: Sort the list in place</li> <li><code>reverse()</code>: Reverse the list in place</li> <li><code>__getitem__(index)</code>: Access an item by index (<code>list[index]</code>)</li> <li><code>__setitem__(index, value)</code>: Set an item by index (<code>list[index] = value</code>)</li> <li><code>__delitem__(index)</code>: Delete an item by index (<code>del list[index]</code>)</li> </ul>"},{"location":"features/change_tracking/#dict-observables","title":"Dict Observables","text":"<p>The <code>ObservableDict</code> class tracks changes to a dictionary, including additions, updates, and removals.</p> <pre><code>from observant import ObservableDict, ObservableCollectionChangeType\n\n# Create an observable dictionary\nsettings = ObservableDict[str, str]({\"theme\": \"dark\"})\n\n# Register a callback\ndef on_settings_change(change):\n    if change.type == ObservableCollectionChangeType.ADD:\n        if hasattr(change, \"key\"):\n            print(f\"Added setting: {change.key} = {change.value}\")\n        else:\n            print(f\"Added settings: {change.items}\")\n    elif change.type == ObservableCollectionChangeType.UPDATE:\n        if hasattr(change, \"key\"):\n            print(f\"Updated setting: {change.key} = {change.value}\")\n        else:\n            print(f\"Updated settings: {change.items}\")\n    elif change.type == ObservableCollectionChangeType.REMOVE:\n        if hasattr(change, \"key\"):\n            print(f\"Removed setting: {change.key}\")\n        else:\n            print(f\"Removed settings: {change.items}\")\n    elif change.type == ObservableCollectionChangeType.CLEAR:\n        print(f\"Cleared settings: {change.items}\")\n\nsettings.on_change(on_settings_change)\n\n# Add a new key\nsettings[\"language\"] = \"en\"  # Prints: \"Added setting: language = en\"\n\n# Update an existing key\nsettings[\"theme\"] = \"light\"  # Prints: \"Updated setting: theme = light\"\n\n# Remove a key\ndel settings[\"theme\"]  # Prints: \"Removed setting: theme\"\n\n# Update multiple keys at once\nsettings.update({\"theme\": \"dark\", \"font\": \"Arial\"})  # Prints appropriate messages\n\n# Clear the dictionary\nsettings.clear()  # Prints: \"Cleared settings: {'language': 'en'}\"\n</code></pre>"},{"location":"features/change_tracking/#dict-change-information","title":"Dict Change Information","text":"<p>When a dictionary changes, the callback receives a <code>ObservableDictChange</code> object with the following properties:</p> <ul> <li><code>type</code>: The type of change (ADD, UPDATE, REMOVE, CLEAR)</li> <li><code>key</code>: The key that was added, updated, or removed (for single-item changes)</li> <li><code>value</code>: The value that was added or updated (for single-item changes)</li> <li><code>items</code>: The items that were added, updated, or removed (for multi-item changes)</li> </ul>"},{"location":"features/change_tracking/#dict-operations","title":"Dict Operations","text":"<p><code>ObservableDict</code> supports all standard Python dictionary operations, including:</p> <ul> <li><code>__getitem__(key)</code>: Access a value by key (<code>dict[key]</code>)</li> <li><code>__setitem__(key, value)</code>: Set a value by key (<code>dict[key] = value</code>)</li> <li><code>__delitem__(key)</code>: Delete a key-value pair (<code>del dict[key]</code>)</li> <li><code>get(key, [default])</code>: Get a value by key, with an optional default value</li> <li><code>setdefault(key, [default])</code>: Get a value by key, or set it to a default value if the key doesn't exist</li> <li><code>pop(key, [default])</code>: Remove and return a value by key, with an optional default value</li> <li><code>popitem()</code>: Remove and return an arbitrary key-value pair</li> <li><code>clear()</code>: Remove all items from the dictionary</li> <li><code>update(other)</code>: Update the dictionary with key-value pairs from another dictionary</li> </ul>"},{"location":"features/change_tracking/#on_change-callbacks","title":"on_change Callbacks","text":"<p>The <code>on_change</code> method is used to register callbacks that are called when the value changes. The callback function receives different arguments depending on the type of observable:</p> <ul> <li>For <code>Observable</code>, the callback receives the new value.</li> <li>For <code>ObservableList</code>, the callback receives a <code>ObservableListChange</code> object.</li> <li>For <code>ObservableDict</code>, the callback receives a <code>ObservableDictChange</code> object.</li> </ul>"},{"location":"features/change_tracking/#callback-behavior","title":"Callback Behavior","text":"<p>Callbacks are called immediately after the value changes. If multiple callbacks are registered, they are called in the order they were registered.</p> <pre><code>counter = Observable[int](0)\n\n# Register callbacks\ncounter.on_change(lambda value: print(f\"First callback: {value}\"))\ncounter.on_change(lambda value: print(f\"Second callback: {value}\"))\n\n# Change the value\ncounter.set(1)\n# Prints:\n# First callback: 1\n# Second callback: 1\n</code></pre>"},{"location":"features/change_tracking/#reentrant-callbacks","title":"Reentrant Callbacks","text":"<p>Callbacks can trigger other changes, which can in turn trigger other callbacks. This is known as \"reentrant\" behavior.</p> <pre><code>name = Observable[str](\"Alice\")\ngreeting = Observable[str](\"Hello, Alice!\")\n\n# Update greeting when name changes\nname.on_change(lambda value: greeting.set(f\"Hello, {value}!\"))\n\n# Register callbacks\nname.on_change(lambda value: print(f\"Name changed to: {value}\"))\ngreeting.on_change(lambda value: print(f\"Greeting changed to: {value}\"))\n\n# Change the name\nname.set(\"Bob\")\n# Prints:\n# Name changed to: Bob\n# Greeting changed to: Hello, Bob!\n</code></pre>"},{"location":"features/change_tracking/#notes-on-performance","title":"Notes on Performance","text":"<p>While observables are powerful, they do come with some overhead. Here are some tips for optimizing performance:</p> <ul> <li>Minimize the number of observables: Create observables only for values that need to be tracked.</li> <li>Use batch updates: When making multiple changes, consider using batch operations like <code>extend()</code> for lists or <code>update()</code> for dictionaries, rather than individual operations.</li> <li>Be careful with reentrant callbacks: Complex chains of callbacks can lead to performance issues and hard-to-debug behavior.</li> <li>Use <code>notify=False</code> when appropriate: If you're making multiple changes and only care about the final state, consider using <code>notify=False</code> for intermediate changes.</li> </ul> <pre><code># Instead of this:\ntasks.append(\"Task 1\")\ntasks.append(\"Task 2\")\ntasks.append(\"Task 3\")\n\n# Consider this:\ntasks.extend([\"Task 1\", \"Task 2\", \"Task 3\"])\n</code></pre>"},{"location":"features/change_tracking/#next-steps","title":"Next Steps","text":"<p>Now that you understand how change tracking works in Observant, you might want to explore:</p> <ul> <li>Validation: Add validation to your models</li> <li>Computed Properties: Create properties that depend on other fields</li> <li>Undo and Redo: Implement undo/redo functionality</li> </ul> <p>\u2190 Back to Overview</p>"},{"location":"features/computed/","title":"Computed Properties","text":"<p>Observant provides a powerful computed properties system that allows you to define properties that depend on other fields and automatically update when those fields change. This page explains how computed properties work in Observant.</p>"},{"location":"features/computed/#overview","title":"Overview","text":"<p>Computed properties are virtual fields that derive their values from other fields. They are useful for:</p> <ul> <li>Combining multiple fields (e.g., full name from first and last name)</li> <li>Formatting data (e.g., formatted date from a timestamp)</li> <li>Calculating derived values (e.g., total price from quantity and unit price)</li> <li>Implementing complex business logic</li> </ul> <p>Key features of computed properties in Observant:</p> <ul> <li>Automatic dependency tracking</li> <li>Observable access to computed values</li> <li>Support for validation</li> <li>Integration with the undo system</li> </ul> <p>Important: Computed properties are read-only. You cannot directly set their values, as they are derived from their dependencies. To change a computed property's value, you must modify its dependencies.</p>"},{"location":"features/computed/#registering-computed-fields","title":"Registering Computed Fields","text":"<p>You can register a computed property using the <code>register_computed</code> method of <code>ObservableProxy</code>. This method takes:</p> <ul> <li>The name of the computed property</li> <li>A function that calculates the value</li> <li>A list of field names that the computed property depends on</li> </ul> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\n# Create a user and proxy\nuser = User(first_name=\"Alice\", last_name=\"Smith\")\nproxy = ObservableProxy(user)\n\n# Register a computed property for full name\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\n\n# Access the computed value\nfull_name = proxy.computed(str, \"full_name\").get()\nprint(full_name)  # \"Alice Smith\"\n</code></pre>"},{"location":"features/computed/#accessing-computed-values","title":"Accessing Computed Values","text":"<p>You can access a computed value using the <code>computed</code> method, which returns an observable:</p> <pre><code># Get the computed value as an observable\nfull_name_obs = proxy.computed(str, \"full_name\")\n\n# Register a callback to be notified when the computed value changes\nfull_name_obs.on_change(lambda value: print(f\"Full name changed to: {value}\"))\n\n# Get the current value\ncurrent_full_name = full_name_obs.get()\n</code></pre>"},{"location":"features/computed/#updating-dependencies","title":"Updating Dependencies","text":"<p>When a dependency of a computed property changes, the computed property is automatically recalculated:</p> <pre><code># Change a dependency\nproxy.observable(str, \"first_name\").set(\"Bob\")\n\n# The computed property is automatically updated\nprint(proxy.computed(str, \"full_name\").get())  # \"Bob Smith\"\n</code></pre>"},{"location":"features/computed/#dependency-tracking","title":"Dependency Tracking","text":"<p>Observant tracks dependencies between computed properties and their source fields. When a source field changes, all computed properties that depend on it are automatically recalculated.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass Product:\n    name: str\n    price: float\n    quantity: int\n\n# Create a product and proxy\nproduct = Product(name=\"Widget\", price=10.0, quantity=2)\nproxy = ObservableProxy(product)\n\n# Register a computed property for total price\nproxy.register_computed(\n    \"total_price\",\n    lambda: proxy.observable(float, \"price\").get() * proxy.observable(int, \"quantity\").get(),\n    dependencies=[\"price\", \"quantity\"]\n)\n\n# Access the computed value\nprint(proxy.computed(float, \"total_price\").get())  # 20.0\n\n# Update a dependency\nproxy.observable(int, \"quantity\").set(3)\n\n# The computed property is automatically updated\nprint(proxy.computed(float, \"total_price\").get())  # 30.0\n</code></pre>"},{"location":"features/computed/#explicit-vs-implicit-dependencies","title":"Explicit vs. Implicit Dependencies","text":"<p>In the examples above, we explicitly listed the dependencies of each computed property. Observant also supports implicit dependency detection, where the dependencies are inferred from the fields accessed in the computation function.</p> <p>However, it's generally recommended to explicitly list dependencies for clarity and to avoid potential issues with complex computations.</p>"},{"location":"features/computed/#chained-computed-fields","title":"Chained Computed Fields","text":"<p>Computed properties can depend on other computed properties, creating a chain of dependencies:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass Order:\n    price: float\n    quantity: int\n    tax_rate: float\n\n# Create an order and proxy\norder = Order(price=10.0, quantity=2, tax_rate=0.1)\nproxy = ObservableProxy(order)\n\n# Register a computed property for subtotal\nproxy.register_computed(\n    \"subtotal\",\n    lambda: proxy.observable(float, \"price\").get() * proxy.observable(int, \"quantity\").get(),\n    dependencies=[\"price\", \"quantity\"]\n)\n\n# Register a computed property for tax amount, which depends on subtotal\nproxy.register_computed(\n    \"tax_amount\",\n    lambda: proxy.computed(float, \"subtotal\").get() * proxy.observable(float, \"tax_rate\").get(),\n    dependencies=[\"subtotal\", \"tax_rate\"]\n)\n\n# Register a computed property for total, which depends on subtotal and tax amount\nproxy.register_computed(\n    \"total\",\n    lambda: proxy.computed(float, \"subtotal\").get() + proxy.computed(float, \"tax_amount\").get(),\n    dependencies=[\"subtotal\", \"tax_amount\"]\n)\n\n# Access the computed values\nprint(proxy.computed(float, \"subtotal\").get())    # 20.0\nprint(proxy.computed(float, \"tax_amount\").get())  # 2.0\nprint(proxy.computed(float, \"total\").get())       # 22.0\n\n# Update a dependency\nproxy.observable(int, \"quantity\").set(3)\n\n# All computed properties are automatically updated\nprint(proxy.computed(float, \"subtotal\").get())    # 30.0\nprint(proxy.computed(float, \"tax_amount\").get())  # 3.0\nprint(proxy.computed(float, \"total\").get())       # 33.0\n</code></pre> <p>In this example, changing the <code>quantity</code> field triggers updates to <code>subtotal</code>, which in turn triggers updates to <code>tax_amount</code> and <code>total</code>.</p>"},{"location":"features/computed/#dependency-graph","title":"Dependency Graph","text":"<p>The dependencies in the example above form a directed acyclic graph (DAG):</p> <pre><code>graph TD\n    price --&gt; subtotal\n    quantity --&gt; subtotal\n    subtotal --&gt; tax_amount\n    tax_rate --&gt; tax_amount\n    subtotal --&gt; total\n    tax_amount --&gt; total\n</code></pre> <p>This visualization helps understand how changes propagate through the system:</p> <ol> <li>When <code>price</code> or <code>quantity</code> changes, <code>subtotal</code> is recalculated</li> <li>When <code>subtotal</code> or <code>tax_rate</code> changes, <code>tax_amount</code> is recalculated</li> <li>When <code>subtotal</code> or <code>tax_amount</code> changes, <code>total</code> is recalculated</li> </ol> <p>So a change to <code>quantity</code> triggers a cascade of updates through the entire graph.</p>"},{"location":"features/computed/#shadowing-real-fields","title":"Shadowing Real Fields","text":"<p>Computed properties can shadow real fields, meaning they can have the same name as a field in the underlying model. This can be useful for adding formatting or validation to existing fields.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user and proxy\nuser = User(name=\"alice\", age=30)\nproxy = ObservableProxy(user)\n\n# Register a computed property that shadows the 'name' field\nproxy.register_computed(\n    \"name\",\n    lambda: proxy.observable(str, \"name\").get().capitalize(),\n    dependencies=[\"name\"]\n)\n\n# Access the computed value\nprint(proxy.computed(str, \"name\").get())  # \"Alice\"\n\n# The original field is still accessible\nprint(proxy.observable(str, \"name\").get())  # \"alice\"\n</code></pre> <p>When shadowing a field, you need to be careful to avoid infinite recursion. In the example above, the computed property accesses the original field using <code>proxy.observable(str, \"name\")</code>, not <code>proxy.computed(str, \"name\")</code>.</p>"},{"location":"features/computed/#circular-dependencies","title":"Circular Dependencies","text":"<p>Observant detects circular dependencies between computed properties and raises an error if it finds any:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass Circular:\n    value: int\n\n# Create a model and proxy\ncircular = Circular(value=0)\nproxy = ObservableProxy(circular)\n\n# Register computed properties with a circular dependency\nproxy.register_computed(\n    \"a\",\n    lambda: proxy.computed(int, \"b\").get() + 1,\n    dependencies=[\"b\"]\n)\n\n# This will raise an error because it creates a circular dependency\nproxy.register_computed(\n    \"b\",\n    lambda: proxy.computed(int, \"a\").get() + 1,\n    dependencies=[\"a\"]\n)\n</code></pre> <p>To avoid circular dependencies, make sure that your computed properties form a directed acyclic graph (DAG), where each property only depends on properties that don't depend on it, directly or indirectly.</p>"},{"location":"features/computed/#validation-of-computed-fields","title":"Validation of Computed Fields","text":"<p>Computed properties can be validated just like regular fields:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\n# Create a user and proxy\nuser = User(first_name=\"\", last_name=\"\")\nproxy = ObservableProxy(user)\n\n# Register a computed property for full name\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\n\n# Add a validator to the computed field\nproxy.add_validator(\"full_name\", lambda v: \"Full name too short\" if len(v.strip()) &lt; 5 else None)\n\n# Check validation\nprint(proxy.is_valid())  # False\nprint(proxy.validation_for(\"full_name\").get())  # [\"Full name too short\"]\n\n# Update the dependencies\nproxy.observable(str, \"first_name\").set(\"Alice\")\nproxy.observable(str, \"last_name\").set(\"Smith\")\n\n# Validation is automatically updated\nprint(proxy.is_valid())  # True\nprint(proxy.validation_for(\"full_name\").get())  # []\n</code></pre> <p>When a dependency of a computed property changes, the computed property is recalculated and its validators are re-run.</p>"},{"location":"features/computed/#computed-fields-and-undo","title":"Computed Fields and Undo","text":"<p>Computed properties are not directly undoable, since their values are derived from other fields. However, when you undo changes to a field that a computed property depends on, the computed property will update accordingly:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\n# Create a user and proxy\nuser = User(first_name=\"Alice\", last_name=\"Smith\")\nproxy = ObservableProxy(user, undo=True)\n\n# Register a computed property for full name\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\n\n# Make a change\nproxy.observable(str, \"first_name\").set(\"Bob\")\nprint(proxy.computed(str, \"full_name\").get())  # \"Bob Smith\"\n\n# Undo the change\nproxy.undo(\"first_name\")\nprint(proxy.computed(str, \"full_name\").get())  # \"Alice Smith\"\n</code></pre>"},{"location":"features/computed/#next-steps","title":"Next Steps","text":"<p>Now that you understand how computed properties work in Observant, you might want to explore:</p> <ul> <li>Dirty Tracking: Track unsaved changes</li> <li>Sync vs Non-Sync: Understand immediate vs. deferred updates</li> <li>Saving and Loading: Save changes and load data</li> </ul> <p>\u2190 Back to Overview</p>"},{"location":"features/dirty/","title":"Dirty Tracking","text":"<p>Observant provides a dirty tracking system that allows you to track which fields have been modified since the last save or reset. This page explains how dirty tracking works in Observant.</p>"},{"location":"features/dirty/#overview","title":"Overview","text":"<p>Dirty tracking is useful for:</p> <ul> <li>Knowing which fields have been modified</li> <li>Enabling/disabling save buttons based on whether there are unsaved changes</li> <li>Prompting users to save changes before navigating away</li> <li>Optimizing save operations by only saving modified fields</li> </ul> <p>Key features of dirty tracking in Observant:</p> <ul> <li>Field-level dirty tracking</li> <li>Observable dirty state</li> <li>Integration with undo/redo</li> <li>Exclusion of computed fields</li> </ul>"},{"location":"features/dirty/#what-is-dirty","title":"What is Dirty?","text":"<p>In Observant, a field is considered \"dirty\" if its value has been changed since the last save or reset. The dirty state is tracked at the field level, so you can see exactly which fields have been modified.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user and proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user)\n\n# Initially, no fields are dirty\nprint(proxy.is_dirty())  # False\nprint(proxy.dirty_fields())  # []\n\n# Modify a field\nproxy.observable(str, \"name\").set(\"Bob\")\n\n# Now the field is dirty\nprint(proxy.is_dirty())  # True\nprint(proxy.dirty_fields())  # [\"name\"]\n\n# Modify another field\nproxy.observable(int, \"age\").set(31)\n\n# Now both fields are dirty\nprint(proxy.is_dirty())  # True\nprint(proxy.dirty_fields())  # [\"name\", \"age\"]\n</code></pre>"},{"location":"features/dirty/#tracking-dirty-fields","title":"Tracking Dirty Fields","text":"<p>Observant provides several methods for tracking dirty fields:</p> <ul> <li><code>is_dirty()</code>: Returns whether any field is dirty</li> <li><code>dirty_fields()</code>: Returns a list of dirty field names</li> <li><code>is_field_dirty(field)</code>: Returns whether a specific field is dirty</li> </ul>"},{"location":"features/dirty/#is_dirty","title":"is_dirty()","text":"<p>The <code>is_dirty()</code> method returns an observable boolean indicating whether any field is dirty:</p> <pre><code># Check if any field is dirty\nis_dirty = proxy.is_dirty()\nprint(is_dirty.get())  # True or False\n\n# Listen for changes to the dirty state\nis_dirty.on_change(lambda dirty: print(f\"Dirty state changed: {dirty}\"))\n</code></pre>"},{"location":"features/dirty/#dirty_fields","title":"dirty_fields()","text":"<p>The <code>dirty_fields()</code> method returns an observable list of dirty field names:</p> <pre><code># Get a list of dirty fields\ndirty_fields = proxy.dirty_fields()\nprint(dirty_fields.get())  # [\"name\", \"age\"]\n\n# Listen for changes to the dirty fields\ndirty_fields.on_change(lambda fields: print(f\"Dirty fields changed: {fields}\"))\n</code></pre>"},{"location":"features/dirty/#is_field_dirtyfield","title":"is_field_dirty(field)","text":"<p>The <code>is_field_dirty(field)</code> method returns an observable boolean indicating whether a specific field is dirty:</p> <pre><code># Check if a specific field is dirty\nis_name_dirty = proxy.is_field_dirty(\"name\")\nprint(is_name_dirty.get())  # True or False\n\n# Listen for changes to the field's dirty state\nis_name_dirty.on_change(lambda dirty: print(f\"Name dirty state changed: {dirty}\"))\n</code></pre>"},{"location":"features/dirty/#reset_dirty","title":"reset_dirty()","text":"<p>The <code>reset_dirty()</code> method resets the dirty state for all fields or for a specific field:</p> <pre><code># Reset dirty state for all fields\nproxy.reset_dirty()\n\n# Reset dirty state for a specific field\nproxy.reset_dirty(\"name\")\n</code></pre> <p>After resetting the dirty state, the current values become the new baseline for dirty tracking. Any subsequent changes will mark the fields as dirty again.</p> <pre><code># Initially, no fields are dirty\nprint(proxy.is_dirty())  # False\n\n# Modify a field\nproxy.observable(str, \"name\").set(\"Bob\")\n\n# Now the field is dirty\nprint(proxy.is_dirty())  # True\n\n# Reset dirty state\nproxy.reset_dirty()\n\n# Now no fields are dirty again\nprint(proxy.is_dirty())  # False\n\n# Modify the field again\nproxy.observable(str, \"name\").set(\"Charlie\")\n\n# Now the field is dirty again\nprint(proxy.is_dirty())  # True\n</code></pre>"},{"location":"features/dirty/#interaction-with-undo","title":"Interaction with Undo","text":"<p>The dirty tracking system integrates with the undo system. When you undo or redo a change, the dirty state is updated accordingly:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user and proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, undo=True)\n\n# Initially, no fields are dirty\nprint(proxy.is_dirty())  # False\n\n# Modify a field\nproxy.observable(str, \"name\").set(\"Bob\")\n\n# Now the field is dirty\nprint(proxy.is_dirty())  # True\nprint(proxy.dirty_fields())  # [\"name\"]\n\n# Undo the change\nproxy.undo(\"name\")\n\n# The field is no longer dirty\nprint(proxy.is_dirty())  # False\nprint(proxy.dirty_fields())  # []\n\n# Redo the change\nproxy.redo(\"name\")\n\n# The field is dirty again\nprint(proxy.is_dirty())  # True\nprint(proxy.dirty_fields())  # [\"name\"]\n</code></pre>"},{"location":"features/dirty/#undo-to-original-value","title":"Undo to Original Value","text":"<p>If you make multiple changes to a field and then undo back to the original value, the field is no longer considered dirty:</p> <pre><code># Initially, no fields are dirty\nprint(proxy.is_dirty())  # False\n\n# Modify a field multiple times\nproxy.observable(str, \"name\").set(\"Bob\")\nproxy.observable(str, \"name\").set(\"Charlie\")\nproxy.observable(str, \"name\").set(\"Dave\")\n\n# Now the field is dirty\nprint(proxy.is_dirty())  # True\n\n# Undo all changes\nproxy.undo(\"name\")  # Reverts to \"Charlie\"\nproxy.undo(\"name\")  # Reverts to \"Bob\"\nproxy.undo(\"name\")  # Reverts to \"Alice\" (original value)\n\n# The field is no longer dirty\nprint(proxy.is_dirty())  # False\n</code></pre>"},{"location":"features/dirty/#computed-fields-and-dirty-state","title":"Computed Fields and Dirty State","text":"<p>Computed fields are not included in dirty tracking, since their values are derived from other fields. When a dependency of a computed field changes, the computed field itself is not marked as dirty.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\n# Create a user and proxy\nuser = User(first_name=\"Alice\", last_name=\"Smith\")\nproxy = ObservableProxy(user)\n\n# Register a computed property for full name\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\n\n# Initially, no fields are dirty\nprint(proxy.is_dirty())  # False\nprint(proxy.dirty_fields())  # []\n\n# Modify a dependency\nproxy.observable(str, \"first_name\").set(\"Bob\")\n\n# Only the dependency is marked as dirty, not the computed field\nprint(proxy.is_dirty())  # True\nprint(proxy.dirty_fields())  # [\"first_name\"]\n</code></pre>"},{"location":"features/dirty/#practical-use-cases","title":"Practical Use Cases","text":""},{"location":"features/dirty/#enablingdisabling-save-buttons","title":"Enabling/Disabling Save Buttons","text":"<p>You can use the dirty state to enable or disable save buttons in a UI:</p> <pre><code># In a UI framework\nsave_button.disabled = not proxy.is_dirty().get()\n\n# Listen for changes to the dirty state\nproxy.is_dirty().on_change(lambda dirty: save_button.disabled = not dirty)\n</code></pre>"},{"location":"features/dirty/#prompting-to-save-changes","title":"Prompting to Save Changes","text":"<p>You can use the dirty state to prompt users to save changes before navigating away:</p> <pre><code>def on_navigate_away():\n    if proxy.is_dirty().get():\n        # Show a confirmation dialog\n        if confirm(\"You have unsaved changes. Save before leaving?\"):\n            save_changes()\n    # Navigate away\n    navigate_to_next_page()\n</code></pre>"},{"location":"features/dirty/#optimizing-save-operations","title":"Optimizing Save Operations","text":"<p>You can use the dirty fields to optimize save operations by only saving modified fields:</p> <pre><code>def save_changes():\n    dirty = proxy.dirty_fields().get()\n    if not dirty:\n        return  # Nothing to save\n\n    # Create a dictionary with only the dirty fields\n    data = {}\n    for field in dirty:\n        if field == \"name\":\n            data[field] = proxy.observable(str, field).get()\n        elif field == \"age\":\n            data[field] = proxy.observable(int, field).get()\n\n    # Save only the dirty fields\n    api.update_user(user_id, data)\n\n    # Reset dirty state\n    proxy.reset_dirty()\n</code></pre>"},{"location":"features/dirty/#next-steps","title":"Next Steps","text":"<p>Now that you understand how dirty tracking works in Observant, you might want to explore:</p> <ul> <li>Sync vs Non-Sync: Understand immediate vs. deferred updates</li> <li>Saving and Loading: Save changes and load data</li> <li>API Reference: Detailed API documentation</li> </ul> <p>\u2190 Back to Overview</p>"},{"location":"features/save_load/","title":"Saving and Loading","text":"<p>Observant provides methods for saving changes back to the model and loading data from external sources. This page explains how saving and loading work in Observant.</p>"},{"location":"features/save_load/#overview","title":"Overview","text":"<p>When working with <code>ObservableProxy</code>, you often need to:</p> <ul> <li>Save changes back to the original model</li> <li>Load data from external sources (e.g., API responses, user input)</li> <li>Update multiple fields at once</li> </ul> <p>Observant provides several methods for these operations:</p> <ul> <li><code>save_to()</code>: Save changes back to a model</li> <li><code>load_dict()</code>: Load data from a dictionary</li> <li><code>update()</code>: Update specific fields</li> </ul>"},{"location":"features/save_load/#save_to","title":"save_to()","text":"<p>The <code>save_to()</code> method saves the current state of the proxy back to a model:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user and proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=False)\n\n# Make changes\nname_obs = proxy.observable(str, \"name\")\nage_obs = proxy.observable(int, \"age\")\nname_obs.set(\"Bob\")\nage_obs.set(31)\n\n# Save changes back to the model\nproxy.save_to(user)\n\n# The model is updated\nprint(user.name)  # \"Bob\"\nprint(user.age)   # 31\n</code></pre>"},{"location":"features/save_load/#saving-to-a-different-model","title":"Saving to a Different Model","text":"<p>You can save changes to a different model instance, as long as it has the same structure:</p> <pre><code># Create two user instances\nuser1 = User(name=\"Alice\", age=30)\nuser2 = User(name=\"Charlie\", age=32)\n\n# Create a proxy for user1\nproxy = ObservableProxy(user1, sync=False)\n\n# Make changes\nname_obs = proxy.observable(str, \"name\")\nage_obs = proxy.observable(int, \"age\")\nname_obs.set(\"Bob\")\nage_obs.set(31)\n\n# Save changes to user2\nproxy.save_to(user2)\n\n# user2 is updated\nprint(user2.name)  # \"Bob\"\nprint(user2.age)   # 31\n\n# user1 is unchanged\nprint(user1.name)  # \"Alice\"\nprint(user1.age)   # 30\n</code></pre> <p>This can be useful when you want to:</p> <ul> <li>Create a copy of a model with modifications</li> <li>Apply changes to multiple models</li> <li>Implement a \"reset to original\" feature</li> </ul>"},{"location":"features/save_load/#saving-and-dirty-state","title":"Saving and Dirty State","text":"<p>When you call <code>save_to()</code>, the dirty state is not automatically reset. If you want to reset the dirty state, you need to call <code>reset_dirty()</code> explicitly:</p> <pre><code># Make changes\nname_obs = proxy.observable(str, \"name\")\nname_obs.set(\"Bob\")\n\n# The field is dirty\nprint(proxy.is_dirty().get())  # True\n\n# Save changes\nproxy.save_to(user)\n\n# The field is still dirty\nprint(proxy.is_dirty().get())  # True\n\n# Reset dirty state\nproxy.reset_dirty()\n\n# Now the field is not dirty\nprint(proxy.is_dirty().get())  # False\n</code></pre> <p>This behavior allows you to track whether changes have been saved to a specific model, even if you save to multiple models.</p>"},{"location":"features/save_load/#load_dict","title":"load_dict()","text":"<p>The <code>load_dict()</code> method loads data from a dictionary into the proxy:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user and proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=False)\n\n# Load data from a dictionary\nproxy.load_dict({\n    \"name\": \"Bob\",\n    \"age\": 31\n})\n\n# The proxy is updated\nname_obs = proxy.observable(str, \"name\")\nage_obs = proxy.observable(int, \"age\")\nprint(name_obs.get())  # \"Bob\"\nprint(age_obs.get())  # 31\n\n# The model is not updated yet\nprint(user.name)  # \"Alice\"\nprint(user.age)   # 30\n\n# Save changes to the model\nproxy.save_to(user)\n\n# Now the model is updated\nprint(user.name)  # \"Bob\"\nprint(user.age)   # 31\n</code></pre>"},{"location":"features/save_load/#nested-data","title":"Nested Data","text":"<p>Note that <code>load_dict()</code> does not automatically handle nested objects. If your model contains nested objects, you'll need to manually create proxies for them:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass Address:\n    street: str\n    city: str\n\n@dataclass\nclass User:\n    name: str\n    address: Address\n\n# Create a user with an address\nuser = User(name=\"Alice\", address=Address(street=\"123 Main St\", city=\"Anytown\"))\nproxy = ObservableProxy(user, sync=False)\n\n# This will NOT work for nested objects:\nproxy.load_dict({\n    \"name\": \"Bob\",\n    \"address\": {\"street\": \"456 Oak St\", \"city\": \"Othertown\"}  # Not automatically proxied\n})\n\n# Instead, you need to handle nested objects manually:\nproxy.observable(str, \"name\").set(\"Bob\")\naddress_proxy = ObservableProxy(user.address, sync=False)\naddress_proxy.load_dict({\n    \"street\": \"456 Oak St\",\n    \"city\": \"Othertown\"\n})\nproxy.save_to(user)\naddress_proxy.save_to(user.address)\n</code></pre>"},{"location":"features/save_load/#reset_missing","title":"reset_missing","text":"<p>The <code>load_dict()</code> method has an optional <code>reset_missing</code> parameter. When set to <code>True</code>, fields that are not in the dictionary are reset to their default values:</p> <pre><code># Load data with reset_missing=True\nproxy.load_dict({\n    \"name\": \"Charlie\"\n}, reset_missing=True)\n\n# Fields not in the dictionary are reset\nname_obs = proxy.observable(str, \"name\")\nage_obs = proxy.observable(int, \"age\")\nprint(name_obs.get())  # \"Charlie\"\nprint(age_obs.get())  # 0 (default value for int)\n</code></pre> <p>When <code>reset_missing=False</code> (the default), fields not in the dictionary are left unchanged:</p> <pre><code># Load data with reset_missing=False\nproxy.load_dict({\n    \"name\": \"Dave\"\n}, reset_missing=False)\n\n# Fields not in the dictionary are unchanged\nname_obs = proxy.observable(str, \"name\")\nage_obs = proxy.observable(int, \"age\")\nprint(name_obs.get())  # \"Dave\"\nprint(age_obs.get())  # 31 (unchanged)\n</code></pre>"},{"location":"features/save_load/#validation-and-load_dict","title":"Validation and load_dict()","text":"<p>When you call <code>load_dict()</code>, validation is automatically triggered for the fields that are updated:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user and proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=False)\n\n# Add validators\nproxy.add_validator(\"name\", lambda v: \"Name required\" if not v else None)\nproxy.add_validator(\"age\", lambda v: \"Age must be positive\" if v &lt;= 0 else None)\n\n# Load valid data\nproxy.load_dict({\n    \"name\": \"Bob\",\n    \"age\": 31\n})\n\n# Validation passes\nprint(proxy.is_valid().get())  # True\n\n# Load invalid data\nproxy.load_dict({\n    \"name\": \"\",\n    \"age\": -1\n})\n\n# Validation fails\nprint(proxy.is_valid().get())  # False\nprint(proxy.validation_errors().get())  # {\"name\": [\"Name required\"], \"age\": [\"Age must be positive\"]}\n</code></pre>"},{"location":"features/save_load/#update","title":"update()","text":"<p>The <code>update()</code> method updates specific fields in the proxy:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n    email: str\n\n# Create a user and proxy\nuser = User(name=\"Alice\", age=30, email=\"alice@example.com\")\nproxy = ObservableProxy(user, sync=False)\n\n# Update specific fields\nproxy.update({\n    \"name\": \"Bob\",\n    \"age\": 31\n})\n\n# Only the specified fields are updated\nname_obs = proxy.observable(str, \"name\")\nage_obs = proxy.observable(int, \"age\")\nemail_obs = proxy.observable(str, \"email\")\nprint(name_obs.get())  # \"Bob\"\nprint(age_obs.get())  # 31\nprint(email_obs.get())  # \"alice@example.com\" (unchanged)\n</code></pre>"},{"location":"features/save_load/#update-vs-load_dict","title":"update() vs load_dict()","text":"<p>The main differences between <code>update()</code> and <code>load_dict()</code> are:</p> <ol> <li><code>update()</code> only updates the fields that are provided in the dictionary</li> <li><code>load_dict()</code> can optionally reset fields that are not in the dictionary</li> <li><code>update()</code> does not have a <code>reset_missing</code> parameter</li> </ol> <pre><code># update() only updates the specified fields\nproxy.update({\n    \"name\": \"Charlie\"\n})\nname_obs = proxy.observable(str, \"name\")\nage_obs = proxy.observable(int, \"age\")\nprint(name_obs.get())  # \"Charlie\"\nprint(age_obs.get())  # 31 (unchanged)\n\n# load_dict() with reset_missing=True resets unspecified fields\nproxy.load_dict({\n    \"name\": \"Dave\"\n}, reset_missing=True)\nprint(name_obs.get())  # \"Dave\"\nprint(age_obs.get())  # 0 (reset to default)\n</code></pre>"},{"location":"features/save_load/#saving-to-different-models","title":"Saving to Different Models","text":"<p>One powerful feature of Observant is the ability to save changes to different models. This can be useful for:</p> <ul> <li>Creating copies of a model with modifications</li> <li>Applying changes to multiple models</li> <li>Implementing a \"reset to original\" feature</li> </ul> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create original user\noriginal_user = User(name=\"Alice\", age=30)\n\n# Create a proxy\nproxy = ObservableProxy(original_user, sync=False)\n\n# Make changes\nname_obs = proxy.observable(str, \"name\")\nage_obs = proxy.observable(int, \"age\")\nname_obs.set(\"Bob\")\nage_obs.set(31)\n\n# Create a modified copy\nmodified_user = User(name=\"\", age=0)\nproxy.save_to(modified_user)\n\n# original_user is unchanged\nprint(original_user.name)  # \"Alice\"\nprint(original_user.age)   # 30\n\n# modified_user has the changes\nprint(modified_user.name)  # \"Bob\"\nprint(modified_user.age)   # 31\n</code></pre>"},{"location":"features/save_load/#saving-to-models-with-different-fields","title":"Saving to Models with Different Fields","text":"<p>When saving to a model with a different structure, only the fields that exist in both the proxy and the target model are updated:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n    email: str\n\n@dataclass\nclass SimpleUser:\n    name: str\n    age: int\n\n# Create a user and proxy\nuser = User(name=\"Alice\", age=30, email=\"alice@example.com\")\nproxy = ObservableProxy(user, sync=False)\n\n# Make changes\nname_obs = proxy.observable(str, \"name\")\nage_obs = proxy.observable(int, \"age\")\nemail_obs = proxy.observable(str, \"email\")\nname_obs.set(\"Bob\")\nage_obs.set(31)\nemail_obs.set(\"bob@example.com\")\n\n# Create a simple user\nsimple_user = SimpleUser(name=\"\", age=0)\n\n# Save changes to the simple user\nproxy.save_to(simple_user)\n\n# Only the fields that exist in SimpleUser are updated\nprint(simple_user.name)  # \"Bob\"\nprint(simple_user.age)   # 31\n# simple_user doesn't have an email field\n</code></pre>"},{"location":"features/save_load/#reusing-a-single-proxy","title":"Reusing a Single Proxy","text":"<p>A powerful feature of Observant is the ability to reuse a single proxy instance across multiple data loads. This preserves observers, computed properties, and other state:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user and proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=False)\n\n# Register an observer\nname_obs = proxy.observable(str, \"name\")\nname_obs.on_change(lambda value: print(f\"Name changed to: {value}\"))\n\n# Make a change\nname_obs.set(\"Bob\")  # Prints: \"Name changed to: Bob\"\n\n# Later, load new data into the SAME proxy\nnew_data = User(name=\"Charlie\", age=25)\nproxy.load_from(new_data)  # Loads data from new_data into the existing proxy\n\n# The observer is still active\nname_obs.set(\"Dave\")  # Prints: \"Name changed to: Dave\"\n\n# Save changes to the original user\nproxy.save_to(user)\nprint(user.name)  # \"Dave\"\n</code></pre> <p>This approach is particularly useful when:</p> <ol> <li>You have UI elements bound to observables and want to update the data without rebinding</li> <li>You have complex observer setups that you want to preserve</li> <li>You're implementing undo/redo and want to maintain the history</li> </ol>"},{"location":"features/save_load/#next-steps","title":"Next Steps","text":"<p>Now that you understand how saving and loading work in Observant, you might want to explore:</p> <ul> <li>API Reference: Detailed API documentation</li> <li>Sync vs Non-Sync: Understand immediate vs. deferred updates</li> <li>Dirty Tracking: Track unsaved changes</li> </ul> <p>\u2190 Back to Overview</p>"},{"location":"features/sync/","title":"Sync vs Non-Sync","text":"<p>Observant provides two modes of operation for <code>ObservableProxy</code>: sync mode and non-sync mode. This page explains the differences between these modes and when to use each.</p>"},{"location":"features/sync/#overview","title":"Overview","text":"<p>When you create an <code>ObservableProxy</code>, you can specify whether changes to the proxy should be immediately synchronized with the underlying model:</p> <ul> <li><code>sync=True</code>: Changes to the proxy are immediately applied to the underlying model</li> <li><code>sync=False</code>: Changes to the proxy are only applied to the underlying model when you call <code>save_to()</code></li> </ul> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user\nuser = User(name=\"Alice\", age=30)\n\n# Create a proxy with sync=True\nproxy_sync = ObservableProxy(user, sync=True)\n\n# Create a proxy with sync=False\nproxy_non_sync = ObservableProxy(user, sync=False)\n</code></pre>"},{"location":"features/sync/#synctrue-vs-syncfalse","title":"sync=True vs sync=False","text":""},{"location":"features/sync/#synctrue","title":"sync=True","text":"<p>When <code>sync=True</code>, any changes you make to the proxy are immediately applied to the underlying model:</p> <pre><code># Create a user and proxy with sync=True\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=True)\n\n# Change a field\nproxy.observable(str, \"name\").set(\"Bob\")\n\n# The change is immediately applied to the user object\nprint(user.name)  # \"Bob\"\n</code></pre> <p>This mode is useful when:</p> <ul> <li>You want to keep the model and proxy in sync at all times</li> <li>You're working with a model that needs to reflect changes immediately</li> <li>You don't need to validate or review changes before applying them</li> </ul>"},{"location":"features/sync/#syncfalse","title":"sync=False","text":"<p>When <code>sync=False</code>, changes to the proxy are not automatically applied to the underlying model. You need to explicitly call <code>save_to()</code> to apply the changes:</p> <pre><code># Create a user and proxy with sync=False\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=False)\n\n# Change a field\nproxy.observable(str, \"name\").set(\"Bob\")\n\n# The change is not applied to the user object yet\nprint(user.name)  # \"Alice\"\n\n# Apply the changes\nproxy.save_to(user)\n\n# Now the change is applied\nprint(user.name)  # \"Bob\"\n</code></pre> <p>This mode is useful when:</p> <ul> <li>You want to validate changes before applying them</li> <li>You need to support undo/redo functionality</li> <li>You want to track dirty state</li> <li>You need to review or confirm changes before saving</li> </ul>"},{"location":"features/sync/#when-to-use-each","title":"When to Use Each","text":""},{"location":"features/sync/#use-synctrue-when","title":"Use sync=True When","text":"<ul> <li>You need immediate synchronization between the proxy and the model</li> <li>You're working with a model that needs to reflect changes in real-time</li> <li>You don't need undo/redo functionality</li> <li>You don't need to track dirty state</li> </ul>"},{"location":"features/sync/#use-syncfalse-when","title":"Use sync=False When","text":"<ul> <li>You need to validate changes before applying them</li> <li>You want to support undo/redo functionality</li> <li>You want to track dirty state</li> <li>You need to review or confirm changes before saving</li> <li>You want to optimize performance by batching updates</li> </ul>"},{"location":"features/sync/#save_to-and-load_dict","title":"save_to() and load_dict()","text":"<p>When using <code>sync=False</code>, you need to explicitly apply changes to the model using <code>save_to()</code>:</p> <pre><code># Create a user and proxy with sync=False\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=False)\n\n# Make changes\nproxy.observable(str, \"name\").set(\"Bob\")\nproxy.observable(int, \"age\").set(31)\n\n# Validate changes\nif proxy.is_valid():\n    # Apply changes\n    proxy.save_to(user)\nelse:\n    # Show validation errors\n    print(\"Validation errors:\", proxy.validation_errors())\n</code></pre> <p>You can also load data into the proxy from a dictionary using <code>load_dict()</code>:</p> <pre><code># Load data from a dictionary\nproxy.load_dict({\n    \"name\": \"Charlie\",\n    \"age\": 32\n})\n\n# The changes are not applied to the user object yet\nprint(user.name)  # \"Bob\" (or \"Alice\" if save_to() wasn't called)\n\n# Apply the changes\nproxy.save_to(user)\n\n# Now the changes are applied\nprint(user.name)  # \"Charlie\"\n</code></pre>"},{"location":"features/sync/#update-vs-load_dict","title":"update() vs load_dict()","text":"<p>Observant provides two methods for updating multiple fields at once: <code>update()</code> and <code>load_dict()</code>. The main difference is that <code>update()</code> only updates the fields that are provided, while <code>load_dict()</code> updates all fields in the dictionary.</p>"},{"location":"features/sync/#update","title":"update()","text":"<p>The <code>update()</code> method updates only the fields that are provided in the dictionary:</p> <pre><code># Create a user and proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=False)\n\n# Update specific fields\nproxy.update({\n    \"name\": \"Bob\"\n})\n\n# Only the specified fields are updated\nprint(proxy.observable(str, \"name\").get())  # \"Bob\"\nprint(proxy.observable(int, \"age\").get())  # 30 (unchanged)\n</code></pre>"},{"location":"features/sync/#load_dict","title":"load_dict()","text":"<p>The <code>load_dict()</code> method updates all fields in the dictionary, and can optionally reset fields that are not in the dictionary:</p> <pre><code># Create a user and proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=False)\n\n# Load a dictionary\nproxy.load_dict({\n    \"name\": \"Bob\"\n}, reset_missing=False)\n\n# Only the specified fields are updated\nprint(proxy.observable(str, \"name\").get())  # \"Bob\"\nprint(proxy.observable(int, \"age\").get())  # 30 (unchanged)\n\n# Load a dictionary with reset_missing=True\nproxy.load_dict({\n    \"name\": \"Charlie\"\n}, reset_missing=True)\n\n# Fields not in the dictionary are reset to their default values\nprint(proxy.observable(str, \"name\").get())  # \"Charlie\"\nprint(proxy.observable(int, \"age\").get())  # 0 (reset to default)\n</code></pre>"},{"location":"features/sync/#performance-considerations","title":"Performance Considerations","text":"<p>The choice between <code>sync=True</code> and <code>sync=False</code> can affect performance:</p> <ul> <li><code>sync=True</code> may be slower if you're making many changes, since each change triggers an update to the model</li> <li><code>sync=False</code> may be faster for bulk updates, since you can batch changes and apply them all at once</li> </ul> <pre><code># sync=True: Each change triggers an update\nproxy_sync = ObservableProxy(user, sync=True)\nfor i in range(1000):\n    proxy_sync.observable(int, \"age\").set(i)  # 1000 updates to the model\n\n# sync=False: Changes are batched\nproxy_non_sync = ObservableProxy(user, sync=False)\nfor i in range(1000):\n    proxy_non_sync.observable(int, \"age\").set(i)  # No updates to the model yet\nproxy_non_sync.save_to(user)  # 1 update to the model\n</code></pre>"},{"location":"features/sync/#sync-and-undo","title":"Sync and Undo","text":"<p>The <code>sync</code> and <code>undo</code> options can be used together, but this can lead to unexpected behavior. When <code>sync=True</code>, changes are immediately applied to the underlying model, which means that undo operations will not affect the model until you call <code>save_to</code>.</p> <pre><code>user = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=True, undo=True)\n\n# Make a change\nproxy.observable(str, \"name\").set(\"Bob\")\nprint(user.name)  # \"Bob\" (sync=True applies changes immediately)\n\n# Undo the change\nproxy.undo(\"name\")\nprint(proxy.observable(str, \"name\").get())  # \"Alice\"\nprint(user.name)  # Still \"Bob\" until save_to is called\n\n# Save changes back to the model\nproxy.save_to(user)\nprint(user.name)  # Now \"Alice\"\n</code></pre> <p>For this reason, it's generally recommended to use <code>sync=False</code> when using undo functionality.</p>"},{"location":"features/sync/#next-steps","title":"Next Steps","text":"<p>Now that you understand the difference between sync and non-sync modes in Observant, you might want to explore:</p> <ul> <li>Saving and Loading: Learn more about saving changes and loading data</li> <li>Dirty Tracking: Track unsaved changes</li> <li>Undo and Redo: Implement undo/redo functionality</li> </ul> <p>\u2190 Back to Overview</p>"},{"location":"features/undo/","title":"Undo and Redo","text":"<p>Observant provides built-in undo and redo functionality, allowing you to track changes to your data and revert them if needed. This page explains how the undo/redo system works in Observant.</p>"},{"location":"features/undo/#overview","title":"Overview","text":"<p>The undo/redo system in Observant is field-based, meaning you can undo changes to individual fields independently. This gives you fine-grained control over which changes to revert.</p> <p>Key features of the undo/redo system:</p> <ul> <li>Per-field undo/redo</li> <li>Configurable undo stack size</li> <li>Debounce support for rapid changes</li> <li>Integration with validation and dirty tracking</li> </ul>"},{"location":"features/undo/#enabling-undo","title":"Enabling Undo","text":"<p>To enable undo functionality, you can either:</p> <ol> <li>Enable it globally when creating the proxy</li> <li>Enable it for specific fields after creating the proxy</li> </ol>"},{"location":"features/undo/#global-undo","title":"Global Undo","text":"<p>To enable undo globally, set <code>undo=True</code> when creating the proxy:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, undo=True)  # Enable undo for all fields\n</code></pre>"},{"location":"features/undo/#per-field-undo","title":"Per-Field Undo","text":"<p>To enable undo for specific fields, use the <code>set_undo_config</code> method:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n    email: str\n\nuser = User(name=\"Alice\", age=30, email=\"alice@example.com\")\nproxy = ObservableProxy(user)  # Undo disabled by default\n\n# Enable undo for specific fields\nproxy.set_undo_config(\"name\", enabled=True)\nproxy.set_undo_config(\"age\", enabled=True)\n# email field will not have undo enabled\n</code></pre>"},{"location":"features/undo/#undo-configuration","title":"Undo Configuration","text":"<p>The undo system can be configured with several options:</p> <ul> <li><code>enabled</code>: Whether undo is enabled for a field</li> <li><code>undo_max</code>: Maximum number of undo steps to store</li> <li><code>undo_debounce_ms</code>: Time in milliseconds to wait before recording a new undo step</li> </ul>"},{"location":"features/undo/#undo_max","title":"undo_max","text":"<p>The <code>undo_max</code> option limits the number of undo steps that are stored for a field. This prevents the undo stack from growing too large and consuming too much memory.</p> <pre><code># Limit to 10 undo steps\nproxy.set_undo_config(\"name\", enabled=True, undo_max=10)\n</code></pre>"},{"location":"features/undo/#undo_debounce_ms","title":"undo_debounce_ms","text":"<p>The <code>undo_debounce_ms</code> option adds debounce behavior to the undo system. If multiple changes are made to a field within the debounce time, only the last change is recorded as an undo step.</p> <p>This is useful for fields that change rapidly, such as text fields during typing:</p> <pre><code># Debounce undo steps by 500ms\nproxy.set_undo_config(\"name\", enabled=True, undo_debounce_ms=500)\n\n# These rapid changes will be combined into a single undo step\nname_obs = proxy.observable(str, \"name\")\nname_obs.set(\"A\")\nname_obs.set(\"Al\")\nname_obs.set(\"Ali\")\nname_obs.set(\"Alic\")\nname_obs.set(\"Alice\")\n\n# Only one undo step is created\nproxy.undo(\"name\")  # Reverts directly to the original value\n</code></pre>"},{"location":"features/undo/#undoredo-api","title":"Undo/Redo API","text":"<p>Once undo is enabled, you can use the following methods to undo and redo changes:</p> <ul> <li><code>undo(field)</code>: Undo the last change to a field</li> <li><code>redo(field)</code>: Redo the last undone change to a field</li> <li><code>can_undo(field)</code>: Check if there are any undo steps available for a field</li> <li><code>can_redo(field)</code>: Check if there are any redo steps available for a field</li> </ul>"},{"location":"features/undo/#basic-undoredo","title":"Basic Undo/Redo","text":"<pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, undo=True)\n\n# Make some changes\nname_obs = proxy.observable(str, \"name\")\nage_obs = proxy.observable(int, \"age\")\nname_obs.set(\"Bob\")\nage_obs.set(25)\n\n# Undo changes\nproxy.undo(\"name\")  # Reverts name to \"Alice\"\nproxy.undo(\"age\")   # Reverts age to 30\n\n# Redo changes\nproxy.redo(\"name\")  # Sets name back to \"Bob\"\nproxy.redo(\"age\")   # Sets age back to 25\n</code></pre>"},{"location":"features/undo/#checking-undoredo-availability","title":"Checking Undo/Redo Availability","text":"<p>You can check if undo or redo is available for a field using the <code>can_undo</code> and <code>can_redo</code> methods:</p> <pre><code># Check if undo is available\nif proxy.can_undo(\"name\").get():\n    proxy.undo(\"name\")\n\n# Check if redo is available\nif proxy.can_redo(\"name\").get():\n    proxy.redo(\"name\")\n</code></pre> <p>These methods return observables, so you can also listen for changes:</p> <pre><code># Listen for changes to undo availability\nproxy.can_undo(\"name\").on_change(lambda can_undo: \n    print(f\"Undo available for name: {can_undo}\"))\n\n# Listen for changes to redo availability\nproxy.can_redo(\"name\").on_change(lambda can_redo: \n    print(f\"Redo available for name: {can_redo}\"))\n</code></pre>"},{"location":"features/undo/#per-field-vs-global-undo","title":"Per-Field vs Global Undo","text":"<p>Important: Observant's undo system is field-based, not transaction-based. Each field has its own independent undo stack. There is no concept of a \"global undo\" that reverts multiple fields at once as a single transaction.</p> <p>Observant's field-based undo system allows you to undo changes to one field without affecting others:</p> <pre><code># Make changes to multiple fields\nname_obs = proxy.observable(str, \"name\")\nage_obs = proxy.observable(int, \"age\")\nname_obs.set(\"Bob\")\nage_obs.set(25)\n\n# Undo only the name change\nproxy.undo(\"name\")  # Reverts name to \"Alice\"\n\n# Age remains changed\nprint(age_obs.get())  # 25\n</code></pre> <p>This field-based approach gives you more control over which changes to undo, but it also means you need to undo each field separately if you want to undo all changes.</p>"},{"location":"features/undo/#batch-undo-helper","title":"Batch Undo Helper","text":"<p>If you need to undo all changes at once, you can create a helper function:</p> <pre><code>def undo_all(proxy, fields):\n    \"\"\"Undo all fields that have undo steps available.\"\"\"\n    for field in fields:\n        if proxy.can_undo(field).get():\n            proxy.undo(field)\n\n# Usage:\nundo_all(proxy, [\"name\", \"age\", \"email\"])\n</code></pre> <p>You can extend this pattern for more complex undo scenarios:</p> <pre><code>def undo_to_clean_state(proxy, fields):\n    \"\"\"Undo all fields until none are dirty.\"\"\"\n    while proxy.is_dirty().get():\n        for field in fields:\n            if proxy.is_field_dirty(field).get() and proxy.can_undo(field).get():\n                proxy.undo(field)\n        # Break if we can't undo any more dirty fields\n        if all(not proxy.can_undo(field).get() for field in fields if proxy.is_field_dirty(field).get()):\n            break\n</code></pre>"},{"location":"features/undo/#limitations-and-gotchas","title":"Limitations and Gotchas","text":""},{"location":"features/undo/#sync-and-undo","title":"Sync and Undo","text":"<p>The <code>sync</code> and <code>undo</code> options can be used together, but this can lead to unexpected behavior. When <code>sync=True</code>, changes are immediately applied to the underlying model, which means that undo operations will not affect the model until you call <code>save_to</code>.</p> <pre><code>user = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=True, undo=True)\n\n# Make a change\nname_obs = proxy.observable(str, \"name\")\nname_obs.set(\"Bob\")\nprint(user.name)  # \"Bob\" (sync=True applies changes immediately)\n\n# Undo the change\nproxy.undo(\"name\")\nprint(name_obs.get())  # \"Alice\"\nprint(user.name)  # Still \"Bob\" until save_to is called\n\n# Save changes back to the model\nproxy.save_to(user)\nprint(user.name)  # Now \"Alice\"\n</code></pre> <p>For this reason, it's generally recommended to use <code>sync=False</code> when using undo functionality.</p>"},{"location":"features/undo/#collection-fields","title":"Collection Fields","text":"<p>For list and dictionary fields, undo/redo works on the entire collection, not individual elements. This means that if you make multiple changes to a collection, undoing will revert all of those changes at once.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass TodoList:\n    tasks: list[str]\n\ntodo_list = TodoList(tasks=[\"Buy milk\"])\nproxy = ObservableProxy(todo_list, undo=True)\n\n# Get the observable list\ntasks = proxy.observable_list(str, \"tasks\")\n\n# Make multiple changes\ntasks.append(\"Write docs\")\ntasks.append(\"Fix bugs\")\ntasks.remove(\"Buy milk\")\n\n# Undo all changes at once\nproxy.undo(\"tasks\")  # Reverts to [\"Buy milk\"]\n</code></pre>"},{"location":"features/undo/#computed-fields","title":"Computed Fields","text":"<p>Computed fields are not directly undoable, since their values are derived from other fields. However, when you undo changes to a field that a computed field depends on, the computed field will update accordingly.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\nuser = User(first_name=\"Alice\", last_name=\"Smith\")\nproxy = ObservableProxy(user, undo=True)\n\n# Register a computed property\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\n\n# Make a change\nfirst_name_obs = proxy.observable(str, \"first_name\")\nfirst_name_obs.set(\"Bob\")\nprint(proxy.computed(str, \"full_name\").get())  # \"Bob Smith\"\n\n# Undo the change\nproxy.undo(\"first_name\")\nprint(proxy.computed(str, \"full_name\").get())  # \"Alice Smith\"\n</code></pre>"},{"location":"features/undo/#validation-and-undo","title":"Validation and Undo","text":"<p>When you undo a change, validation is automatically re-run for the affected field. This means that if you undo a change that makes a field invalid, the validation errors will be updated accordingly.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    username: str\n\nuser = User(username=\"\")\nproxy = ObservableProxy(user, undo=True)\n\n# Add a validator\nproxy.add_validator(\"username\", lambda v: \"Username required\" if not v else None)\n\n# Set a valid value\nusername_obs = proxy.observable(str, \"username\")\nusername_obs.set(\"alice\")\nprint(proxy.is_valid().get())  # True\n\n# Undo the change\nproxy.undo(\"username\")\nprint(proxy.is_valid().get())  # False\nprint(proxy.validation_for(\"username\").get())  # [\"Username required\"]\n</code></pre>"},{"location":"features/undo/#next-steps","title":"Next Steps","text":"<p>Now that you understand how undo and redo work in Observant, you might want to explore:</p> <ul> <li>Computed Properties: Create properties that depend on other fields</li> <li>Dirty Tracking: Track unsaved changes</li> <li>Sync vs Non-Sync: Understand immediate vs. deferred updates</li> </ul> <p>\u2190 Back to Overview</p>"},{"location":"features/validation/","title":"Validation","text":"<p>Observant provides a powerful validation system that allows you to validate your data as it changes. This page explains how validation works in Observant.</p>"},{"location":"features/validation/#overview","title":"Overview","text":"<p>Validation in Observant is field-based, meaning you can add validators to individual fields of your model. Validators are functions that check if a field's value is valid and return an error message if it's not.</p> <p>The validation system provides:</p> <ul> <li>Field-level validation</li> <li>Multiple validators per field</li> <li>Observable validation state</li> <li>Validation for computed fields</li> <li>Exception handling in validators</li> </ul>"},{"location":"features/validation/#adding-validators","title":"Adding Validators","text":"<p>You can add validators to a field using the <code>add_validator</code> method of <code>ObservableProxy</code>. A validator is a function that takes the field's value as input and returns either:</p> <ul> <li><code>None</code> if the value is valid</li> <li>A string error message if the value is invalid</li> </ul> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    username: str\n    email: str\n    age: int\n\n# Create a user and proxy\nuser = User(username=\"\", email=\"\", age=0)\nproxy = ObservableProxy(user)\n\n# Add validators\nproxy.add_validator(\"username\", lambda v: \"Username required\" if not v else None)\nproxy.add_validator(\"email\", lambda v: \"Invalid email\" if \"@\" not in v else None)\nproxy.add_validator(\"age\", lambda v: \"Must be positive\" if v &lt;= 0 else None)\n</code></pre>"},{"location":"features/validation/#multiple-validators","title":"Multiple Validators","text":"<p>You can add multiple validators to the same field. All validators will run, and all error messages will be collected.</p> <pre><code># Add multiple validators to the same field\nproxy.add_validator(\"username\", lambda v: \"Username required\" if not v else None)\nproxy.add_validator(\"username\", lambda v: \"Too short\" if len(v) &lt; 3 else None)\nproxy.add_validator(\"username\", lambda v: \"No spaces allowed\" if \" \" in v else None)\n\n# Set an invalid value\nproxy.observable(str, \"username\").set(\"a\")\n\n# Check validation errors\nerrors = proxy.validation_for(\"username\").get()\nprint(errors)  # ['Too short']\n</code></pre>"},{"location":"features/validation/#complex-validators","title":"Complex Validators","text":"<p>Validators can be as simple or complex as needed. Here's an example of a more complex validator:</p> <pre><code>def validate_password(password: str) -&gt; str | None:\n    if len(password) &lt; 8:\n        return \"Password must be at least 8 characters\"\n    if not any(c.isupper() for c in password):\n        return \"Password must contain at least one uppercase letter\"\n    if not any(c.islower() for c in password):\n        return \"Password must contain at least one lowercase letter\"\n    if not any(c.isdigit() for c in password):\n        return \"Password must contain at least one digit\"\n    return None\n\nproxy.add_validator(\"password\", validate_password)\n</code></pre>"},{"location":"features/validation/#validation_errors-and-validation_for","title":"validation_errors() and validation_for()","text":"<p>Observant provides two main methods for checking validation state:</p> <ul> <li><code>validation_errors()</code>: Returns an observable dictionary of all validation errors</li> <li><code>validation_for(field)</code>: Returns an observable list of validation errors for a specific field</li> </ul>"},{"location":"features/validation/#validation_errors","title":"validation_errors()","text":"<p>The <code>validation_errors()</code> method returns an observable dictionary where:</p> <ul> <li>Keys are field names with validation errors</li> <li>Values are lists of error messages for each field</li> </ul> <pre><code># Check all validation errors\nerrors = proxy.validation_errors()\nprint(errors)  # {'username': ['Too short'], 'email': ['Invalid email'], 'age': ['Must be positive']}\n\n# The errors dictionary is observable\nerrors.on_change(lambda change: print(f\"Validation errors changed: {change}\"))\n\n# Fix the username\nproxy.observable(str, \"username\").set(\"alice\")\n# The errors dictionary will update automatically\n</code></pre>"},{"location":"features/validation/#validation_for","title":"validation_for()","text":"<p>The <code>validation_for(field)</code> method returns an observable list of validation errors for a specific field:</p> <pre><code># Check validation errors for a specific field\nusername_errors = proxy.validation_for(\"username\").get()\nprint(username_errors)  # ['Too short']\n\n# The errors list is observable\nproxy.validation_for(\"username\").on_change(lambda errors: print(f\"Username errors: {errors}\"))\n\n# Fix the username\nproxy.observable(str, \"username\").set(\"alice\")\n# Prints: \"Username errors: []\"\n</code></pre>"},{"location":"features/validation/#is_valid","title":"is_valid()","text":"<p>The <code>is_valid()</code> method returns an observable boolean indicating whether the entire model is valid:</p> <pre><code># Check if the model is valid\nis_valid = proxy.is_valid()\nprint(is_valid)  # False\n\n# The is_valid observable updates automatically\nproxy.is_valid().on_change(lambda valid: print(f\"Model is valid: {valid}\"))\n\n# Fix all validation errors\nproxy.observable(str, \"username\").set(\"alice\")\nproxy.observable(str, \"email\").set(\"alice@example.com\")\nproxy.observable(int, \"age\").set(30)\n# Prints: \"Model is valid: True\"\n</code></pre>"},{"location":"features/validation/#when-to-validate","title":"When to Validate","text":"<p>Observant's validation system is flexible and can be used in different ways depending on your needs. Here are three common approaches to validation timing:</p>"},{"location":"features/validation/#immediate-validation","title":"Immediate Validation","text":"<p>With immediate validation, validators run as soon as a field's value changes. This provides instant feedback to users but can be intrusive for fields that are still being edited.</p> <pre><code># Immediate validation is the default behavior\nusername_obs = proxy.observable(str, \"username\")\nusername_obs.set(\"a\")  # Validation runs immediately\n\n# Check validation errors\nprint(proxy.validation_for(\"username\").get())  # ['Too short']\n</code></pre> <p>This approach is good for: - Simple forms where immediate feedback is helpful - Fields with critical validation requirements - When you want to prevent invalid input as early as possible</p>"},{"location":"features/validation/#deferred-validation","title":"Deferred Validation","text":"<p>With deferred validation, you manually trigger validation when needed, such as when a form is submitted. This gives users more freedom to enter data without being interrupted by validation errors.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass LoginForm:\n    username: str\n    password: str\n\n# Create a form and proxy\nform = LoginForm(username=\"\", password=\"\")\nproxy = ObservableProxy(form)\n\n# Add validators but don't run them yet\nproxy.add_validator(\"username\", lambda v: \"Username required\" if not v else None)\nproxy.add_validator(\"password\", lambda v: \"Password required\" if not v else None)\n\n# Disable automatic validation\nusername_obs = proxy.observable(str, \"username\")\nusername_obs.set(\"\", notify=False)  # No validation runs\npassword_obs = proxy.observable(str, \"password\")\npassword_obs.set(\"\", notify=False)  # No validation runs\n\n# Later, when the form is submitted, manually trigger validation\ndef on_submit():\n    # Force validation of all fields\n    proxy.reset_validation()\n\n    if proxy.is_valid().get():\n        # Form is valid, proceed with submission\n        print(\"Form submitted successfully\")\n    else:\n        # Show validation errors\n        print(\"Please fix the following errors:\")\n        for field, errors in proxy.validation_errors().get().items():\n            print(f\"{field}: {', '.join(errors)}\")\n\n# Test the submit function\non_submit()\n# Prints:\n# Please fix the following errors:\n# username: Username required\n# password: Password required\n</code></pre> <p>This approach is good for: - Complex forms where immediate validation would be disruptive - When you want to validate multiple fields at once - When validation should only happen at specific points (e.g., form submission)</p>"},{"location":"features/validation/#hybrid-validation","title":"Hybrid Validation","text":"<p>You can also use a hybrid approach, where some fields are validated immediately and others are validated only when needed:</p> <pre><code># Username is validated immediately\nproxy.add_validator(\"username\", lambda v: \"Username required\" if not v else None)\n\n# Password is not validated until form submission\nproxy.add_validator(\"password\", lambda v: \"Password required\" if not v else None)\npassword_obs = proxy.observable(str, \"password\")\npassword_obs.set(\"\", notify=False)  # No validation runs\n\n# When the form is submitted, validate all fields\ndef on_submit():\n    # Force validation of all fields\n    proxy.reset_validation()\n\n    if proxy.is_valid().get():\n        # Form is valid, proceed with submission\n        print(\"Form submitted successfully\")\n    else:\n        # Show validation errors\n        print(\"Please fix the following errors:\")\n        for field, errors in proxy.validation_errors().get().items():\n            print(f\"{field}: {', '.join(errors)}\")\n</code></pre> <p>This approach is good for: - Forms with a mix of critical and non-critical fields - When you want immediate validation for some fields but not others - When you want to balance user experience with validation requirements</p>"},{"location":"features/validation/#clearing-validation-errors","title":"Clearing Validation Errors","text":"<p>Sometimes you may want to clear validation errors, for example after a successful form submission or when you want to reset the form.</p>"},{"location":"features/validation/#reset_validation","title":"reset_validation()","text":"<p>The <code>reset_validation()</code> method resets the validation state for all fields or for a specific field:</p> <pre><code># Reset validation for all fields\nproxy.reset_validation()\n\n# Reset validation for a specific field\nproxy.reset_validation(\"username\")\n</code></pre> <p>By default, <code>reset_validation()</code> also re-runs the validators. If you want to just clear the validation state without re-running the validators, you can set <code>revalidate=False</code>:</p> <pre><code># Reset validation without re-running validators\nproxy.reset_validation(revalidate=False)\n</code></pre> <p>This is particularly useful when: - You've successfully saved the form and want to clear all validation errors - You're resetting the form to its initial state - You want to temporarily disable validation</p>"},{"location":"features/validation/#practical-example-form-submission","title":"Practical Example: Form Submission","text":"<p>Here's a complete example of a form submission flow with validation:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass RegistrationForm:\n    username: str\n    email: str\n    password: str\n\n# Create a form and proxy\nform = RegistrationForm(username=\"\", email=\"\", password=\"\")\nproxy = ObservableProxy(form)\n\n# Add validators\nproxy.add_validator(\"username\", lambda v: \"Username required\" if not v else None)\nproxy.add_validator(\"email\", lambda v: \"Invalid email\" if \"@\" not in v else None)\nproxy.add_validator(\"password\", lambda v: \"Password too short\" if len(v) &lt; 8 else None)\n\n# Function to handle form submission\ndef submit_form():\n    # Force validation of all fields\n    proxy.reset_validation()\n\n    if proxy.is_valid().get():\n        # Form is valid, proceed with submission\n        print(\"Form submitted successfully\")\n\n        # Save the form data (e.g., to a database)\n        save_to_database(proxy)\n\n        # Clear all validation errors and mark form as clean\n        proxy.reset_validation(revalidate=False)\n        proxy.reset_dirty()\n\n        return True\n    else:\n        # Show validation errors\n        print(\"Please fix the following errors:\")\n        for field, errors in proxy.validation_errors().get().items():\n            print(f\"{field}: {', '.join(errors)}\")\n\n        return False\n\n# Simulate user input\nproxy.observable(str, \"username\").set(\"alice\")\nproxy.observable(str, \"email\").set(\"alice@example.com\")\nproxy.observable(str, \"password\").set(\"password123\")\n\n# Submit the form\nsubmit_form()  # Prints: \"Form submitted successfully\"\n</code></pre>"},{"location":"features/validation/#computed-field-validation","title":"Computed Field Validation","text":"<p>Observant also supports validation for computed fields. When a computed field's dependencies change, the computed field's validators are automatically re-run.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\n# Create a user and proxy\nuser = User(first_name=\"\", last_name=\"\")\nproxy = ObservableProxy(user)\n\n# Register a computed property for full name\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\n\n# Add a validator to the computed field\nproxy.add_validator(\"full_name\", lambda v: \"Full name too short\" if len(v.strip()) &lt; 5 else None)\n\n# Check validation\nprint(proxy.is_valid())  # False\nprint(proxy.validation_for(\"full_name\").get())  # ['Full name too short']\n\n# Update the dependencies\nproxy.observable(str, \"first_name\").set(\"Alice\")\nproxy.observable(str, \"last_name\").set(\"Smith\")\n\n# Validation is automatically updated\nprint(proxy.is_valid())  # True\nprint(proxy.validation_for(\"full_name\").get())  # []\n</code></pre>"},{"location":"features/validation/#exception-handling-in-validators","title":"Exception Handling in Validators","text":"<p>Validators can sometimes raise exceptions, especially if they perform complex operations. Observant catches these exceptions and converts them to validation error messages.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    username: str\n\n# Create a user and proxy\nuser = User(username=\"\")\nproxy = ObservableProxy(user)\n\n# Add a validator that might raise an exception\ndef buggy_validator(value):\n    if not value:\n        raise ValueError(\"Username cannot be empty\")\n    return None\n\nproxy.add_validator(\"username\", buggy_validator)\n\n# Check validation\nprint(proxy.is_valid())  # False\nprint(proxy.validation_for(\"username\").get())  # ['Username cannot be empty']\n\n# Fix the value\nproxy.observable(str, \"username\").set(\"alice\")\nprint(proxy.is_valid())  # True\n</code></pre> <p>This feature is particularly useful when:</p> <ul> <li>You're integrating with external validation libraries that might raise exceptions</li> <li>You want to use assert-style validation that raises exceptions</li> <li>You're performing complex validation that might fail unexpectedly</li> </ul>"},{"location":"features/validation/#different-types-of-exceptions","title":"Different Types of Exceptions","text":"<p>Observant handles all types of exceptions in validators, not just <code>ValueError</code>:</p> <pre><code>def type_error_validator(value):\n    if not isinstance(value, str):\n        raise TypeError(\"Value must be a string\")\n    return None\n\ndef key_error_validator(value):\n    if value not in [\"admin\", \"user\", \"guest\"]:\n        raise KeyError(f\"Unknown role: {value}\")\n    return None\n\nproxy.add_validator(\"role\", type_error_validator)\nproxy.add_validator(\"role\", key_error_validator)\n</code></pre>"},{"location":"features/validation/#next-steps","title":"Next Steps","text":"<p>Now that you understand how validation works in Observant, you might want to explore:</p> <ul> <li>Computed Properties: Create properties that depend on other fields</li> <li>Undo and Redo: Implement undo/redo functionality</li> <li>Dirty Tracking: Track unsaved changes</li> </ul> <p>\u2190 Back to Overview</p>"}]}