{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#observantpy","title":"Observant.py","text":"<p>Reactive state management for Python</p> <p> </p>"},{"location":"#what-is-observantpy","title":"What is Observant.py?","text":"<p>Observant.py is a lightweight, type-safe library for observable state management in Python. It provides a reactive programming model that makes it easy to:</p> <ul> <li>Track changes to data</li> <li>Validate data</li> <li>Implement undo/redo functionality</li> <li>Create computed properties</li> <li>Synchronize state between models</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Type-safe: Full type hints for excellent IDE support and static analysis</li> <li>Observable primitives: Track changes to values, lists, and dictionaries</li> <li>Validation: Add validators to ensure data integrity</li> <li>Undo/Redo: Built-in support for tracking and reverting changes</li> <li>Computed properties: Define properties that automatically update based on dependencies</li> <li>Proxy objects: Wrap existing models with observable behavior</li> <li>Minimal dependencies: Pure Python with no external requirements</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from observant import Observable, ObservableProxy\nfrom dataclasses import dataclass\n\n# Create a simple observable value\ncounter = Observable(0)\ncounter.on_change(lambda value: print(f\"Counter changed to {value}\"))\ncounter.set(1)  # Prints: Counter changed to 1\n\n# Create a model with observable properties\n@dataclass\nclass User:\n    name: str\n    age: int\n\nuser = User(name=\"Ada\", age=36)\nproxy = ObservableProxy(user)\n\n# Add validation\nproxy.add_validator(\"age\", lambda age: \"Age must be positive\" if age &lt;= 0 else None)\n\n# Create a computed property\nproxy.register_computed(\n    \"greeting\", \n    lambda: f\"Hello, {proxy.observable(str, 'name').get()}!\",\n    [\"name\"]\n)\n\n# Listen for changes\nproxy.observable(str, \"name\").on_change(\n    lambda name: print(f\"Name changed to {name}\")\n)\n\n# Update a value\nproxy.observable(str, \"name\").set(\"Grace\")  # Prints: Name changed to Grace\n\n# Access computed property\nprint(proxy.computed(str, \"greeting\").get())  # Prints: Hello, Grace!\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install observant\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Check out the Getting Started guide</li> <li>Explore the Reference documentation</li> <li>See Examples of common patterns</li> </ul>"},{"location":"getting_started/","title":"Getting Started with Observant.py","text":"<p>This guide will walk you through the basics of using Observant.py to manage observable state in your Python applications.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Install Observant.py using pip:</p> <pre><code>pip install observant\n</code></pre>"},{"location":"getting_started/#basic-concepts","title":"Basic Concepts","text":"<p>Observant.py provides several key components:</p> <ul> <li>Observable: A wrapper around a value that notifies listeners when the value changes</li> <li>ObservableList: A list that notifies listeners when items are added, removed, or the list is cleared</li> <li>ObservableDict: A dictionary that notifies listeners when entries are added, updated, or removed</li> <li>ObservableProxy: A proxy for a data object that exposes its fields as observables</li> </ul>"},{"location":"getting_started/#using-observable","title":"Using Observable","text":"<p>The <code>Observable</code> class is the simplest way to track changes to a value:</p> <pre><code>from observant import Observable\n\n# Create an observable with an initial value\nname = Observable(\"Ada\")\n\n# Register a callback to be notified when the value changes\nname.on_change(lambda value: print(f\"Name changed to: {value}\"))\n\n# Change the value\nname.set(\"Grace\")  # Prints: Name changed to: Grace\n\n# Get the current value\ncurrent_name = name.get()  # Returns: \"Grace\"\n</code></pre>"},{"location":"getting_started/#using-observablelist","title":"Using ObservableList","text":"<p><code>ObservableList</code> tracks changes to a list:</p> <pre><code>from observant import ObservableList\n\n# Create an observable list\nfruits = ObservableList([\"apple\", \"banana\"])\n\n# Register a callback\nfruits.on_change(lambda change: print(f\"List changed: {change.type.name} at index {change.index}\"))\n\n# Modify the list\nfruits.append(\"cherry\")  # Prints: List changed: ADD at index 2\nfruits.pop(0)  # Prints: List changed: REMOVE at index 0\n</code></pre>"},{"location":"getting_started/#using-observabledict","title":"Using ObservableDict","text":"<p><code>ObservableDict</code> tracks changes to a dictionary:</p> <pre><code>from observant import ObservableDict\n\n# Create an observable dictionary\nsettings = ObservableDict({\"theme\": \"dark\", \"notifications\": True})\n\n# Register a callback\nsettings.on_change(lambda change: print(f\"Dict changed: {change.key} = {change.value}\"))\n\n# Modify the dictionary\nsettings[\"theme\"] = \"light\"  # Prints: Dict changed: theme = light\nsettings[\"sound\"] = \"on\"  # Prints: Dict changed: sound = on\n</code></pre>"},{"location":"getting_started/#using-observableproxy","title":"Using ObservableProxy","text":"<p><code>ObservableProxy</code> is a powerful way to make an existing object observable:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n    preferences: dict[str, str]\n    friends: list[str]\n\n# Create a user\nuser = User(\n    name=\"Ada\",\n    age=36,\n    preferences={\"theme\": \"dark\"},\n    friends=[\"Charles\", \"Grace\"]\n)\n\n# Create a proxy for the user\nproxy = ObservableProxy(user)\n\n# Access scalar fields as observables\nname_obs = proxy.observable(str, \"name\")\nname_obs.on_change(lambda name: print(f\"Name changed to: {name}\"))\n\n# Access list fields as observable lists\nfriends_obs = proxy.observable_list(str, \"friends\")\nfriends_obs.on_change(lambda change: print(f\"Friends changed: {change.type.name}\"))\n\n# Access dict fields as observable dictionaries\nprefs_obs = proxy.observable_dict((str, str), \"preferences\")\nprefs_obs.on_change(lambda change: print(f\"Preferences changed: {change.key}\"))\n\n# Make changes\nname_obs.set(\"Grace\")  # Prints: Name changed to: Grace\nfriends_obs.append(\"Alan\")  # Prints: Friends changed: ADD\nprefs_obs[\"notifications\"] = \"on\"  # Prints: Preferences changed: notifications\n\n# Save changes back to the original object\nproxy.save_to(user)\n</code></pre>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, you can explore more advanced features:</p> <ul> <li>Validation: Add validators to ensure data integrity</li> <li>Undo/Redo: Track and revert changes</li> <li>Computed Fields: Create properties that automatically update</li> <li>Syncing &amp; Dirty State: Synchronize state between models</li> </ul> <p>Check out the Examples section for more practical use cases.</p>"},{"location":"api_reference/","title":"API Reference","text":"<p>This section provides a comprehensive API reference for all classes and interfaces in Observant.py.</p>"},{"location":"api_reference/#core-classes","title":"Core Classes","text":"<ul> <li>Observable</li> <li>ObservableList</li> <li>ObservableDict</li> <li>ObservableProxy</li> <li>UndoableObservable</li> </ul>"},{"location":"api_reference/#interfaces","title":"Interfaces","text":"<ul> <li>IObservable</li> <li>IObservableList</li> <li>IObservableDict</li> <li>IObservableProxy</li> </ul>"},{"location":"api_reference/#types","title":"Types","text":"<ul> <li>ObservableCollectionChangeType</li> <li>ObservableListChange</li> <li>ObservableDictChange</li> <li>ProxyFieldKey</li> <li>UndoConfig</li> </ul>"},{"location":"api_reference/observable/","title":"Observable","text":""},{"location":"api_reference/observable/#observant.observable.Observable","title":"<code>observant.observable.Observable</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>IObservable[T]</code></p> Source code in <code>observant\\observable.py</code> <pre><code>class Observable(Generic[T], IObservable[T]):\n    _value: T\n    _callbacks: list[Callable[[T], None]]\n    _on_change_enabled: bool = True\n\n    def __init__(self, value: T, *, on_change: Callable[[T], None] | None = None, on_change_enabled: bool = True) -&gt; None:\n        \"\"\"\n        Initialize the Observable with a value.\n\n        Args:\n            value: The initial value of the observable.\n        \"\"\"\n        print(f\"DEBUG: Observable.__init__ called with value {value}\")\n        self._value = value\n        self._callbacks = []\n        self._on_change_enabled = on_change_enabled\n        print(\"DEBUG: Observable.__init__ - Initialized with empty callbacks list\")\n\n    @override\n    def get(self) -&gt; T:\n        \"\"\"\n        Get the current value of the observable.\n\n        Returns:\n            The current value.\n        \"\"\"\n        return self._value\n\n    @override\n    def set(self, value: T, notify: bool = True) -&gt; None:\n        \"\"\"\n        Set a new value for the observable and notify all registered callbacks.\n\n        Args:\n            value: The new value to set.\n            notify: Whether to notify the callbacks after setting the value.\n        \"\"\"\n        print(f\"DEBUG: Observable.set called with value {value}\")\n        self._value = value\n\n        if not notify or not self._on_change_enabled:\n            print(\"DEBUG: Observable.set - on_change is disabled, skipping callbacks\")\n            return\n\n        print(f\"DEBUG: Observable.set - Notifying {len(self._callbacks)} callbacks\")\n        for i, callback in enumerate(self._callbacks):\n            print(f\"DEBUG: Observable.set - Calling callback {i}\")\n            callback(value)\n            print(f\"DEBUG: Observable.set - Callback {i} completed\")\n        print(\"DEBUG: Observable.set - Completed\")\n\n    @override\n    def on_change(self, callback: Callable[[T], None]) -&gt; None:\n        \"\"\"\n        Register a callback function to be called when the value changes.\n\n        Args:\n            callback: A function that takes the new value as its argument.\n        \"\"\"\n        print(f\"DEBUG: Observable.on_change called, current callbacks: {len(self._callbacks)}\")\n        # Check if this callback is already registered to avoid duplicates\n        for existing_cb in self._callbacks:\n            if existing_cb == callback:\n                print(\"DEBUG: Observable.on_change - Callback already registered, skipping\")\n                return\n\n        self._callbacks.append(callback)\n        print(f\"DEBUG: Observable.on_change - Added callback, now have {len(self._callbacks)} callbacks\")\n\n    @override\n    def enable(self) -&gt; None:\n        \"\"\"\n        Enable the observable to notify changes.\n        \"\"\"\n        print(\"DEBUG: Observable.enable called\")\n        self._on_change_enabled = True\n\n    @override\n    def disable(self) -&gt; None:\n        \"\"\"\n        Disable the observable from notifying changes.\n        \"\"\"\n        print(\"DEBUG: Observable.disable called\")\n        self._on_change_enabled = False\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.__init__","title":"<code>__init__(value, *, on_change=None, on_change_enabled=True)</code>","text":"<p>Initialize the Observable with a value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The initial value of the observable.</p> required Source code in <code>observant\\observable.py</code> <pre><code>def __init__(self, value: T, *, on_change: Callable[[T], None] | None = None, on_change_enabled: bool = True) -&gt; None:\n    \"\"\"\n    Initialize the Observable with a value.\n\n    Args:\n        value: The initial value of the observable.\n    \"\"\"\n    print(f\"DEBUG: Observable.__init__ called with value {value}\")\n    self._value = value\n    self._callbacks = []\n    self._on_change_enabled = on_change_enabled\n    print(\"DEBUG: Observable.__init__ - Initialized with empty callbacks list\")\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.disable","title":"<code>disable()</code>","text":"<p>Disable the observable from notifying changes.</p> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef disable(self) -&gt; None:\n    \"\"\"\n    Disable the observable from notifying changes.\n    \"\"\"\n    print(\"DEBUG: Observable.disable called\")\n    self._on_change_enabled = False\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.enable","title":"<code>enable()</code>","text":"<p>Enable the observable to notify changes.</p> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef enable(self) -&gt; None:\n    \"\"\"\n    Enable the observable to notify changes.\n    \"\"\"\n    print(\"DEBUG: Observable.enable called\")\n    self._on_change_enabled = True\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.get","title":"<code>get()</code>","text":"<p>Get the current value of the observable.</p> <p>Returns:</p> Type Description <code>T</code> <p>The current value.</p> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef get(self) -&gt; T:\n    \"\"\"\n    Get the current value of the observable.\n\n    Returns:\n        The current value.\n    \"\"\"\n    return self._value\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.on_change","title":"<code>on_change(callback)</code>","text":"<p>Register a callback function to be called when the value changes.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[T], None]</code> <p>A function that takes the new value as its argument.</p> required Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef on_change(self, callback: Callable[[T], None]) -&gt; None:\n    \"\"\"\n    Register a callback function to be called when the value changes.\n\n    Args:\n        callback: A function that takes the new value as its argument.\n    \"\"\"\n    print(f\"DEBUG: Observable.on_change called, current callbacks: {len(self._callbacks)}\")\n    # Check if this callback is already registered to avoid duplicates\n    for existing_cb in self._callbacks:\n        if existing_cb == callback:\n            print(\"DEBUG: Observable.on_change - Callback already registered, skipping\")\n            return\n\n    self._callbacks.append(callback)\n    print(f\"DEBUG: Observable.on_change - Added callback, now have {len(self._callbacks)} callbacks\")\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.set","title":"<code>set(value, notify=True)</code>","text":"<p>Set a new value for the observable and notify all registered callbacks.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The new value to set.</p> required <code>notify</code> <code>bool</code> <p>Whether to notify the callbacks after setting the value.</p> <code>True</code> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef set(self, value: T, notify: bool = True) -&gt; None:\n    \"\"\"\n    Set a new value for the observable and notify all registered callbacks.\n\n    Args:\n        value: The new value to set.\n        notify: Whether to notify the callbacks after setting the value.\n    \"\"\"\n    print(f\"DEBUG: Observable.set called with value {value}\")\n    self._value = value\n\n    if not notify or not self._on_change_enabled:\n        print(\"DEBUG: Observable.set - on_change is disabled, skipping callbacks\")\n        return\n\n    print(f\"DEBUG: Observable.set - Notifying {len(self._callbacks)} callbacks\")\n    for i, callback in enumerate(self._callbacks):\n        print(f\"DEBUG: Observable.set - Calling callback {i}\")\n        callback(value)\n        print(f\"DEBUG: Observable.set - Callback {i} completed\")\n    print(\"DEBUG: Observable.set - Completed\")\n</code></pre>"},{"location":"api_reference/observable_dict/","title":"ObservableDict","text":""},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict","title":"<code>observant.observable_dict.ObservableDict</code>","text":"<p>               Bases: <code>Generic[TKey, TValue]</code>, <code>IObservableDict[TKey, TValue]</code></p> <p>Base implementation that can work with an external dict or create its own.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>class ObservableDict(Generic[TKey, TValue], IObservableDict[TKey, TValue]):\n    \"\"\"Base implementation that can work with an external dict or create its own.\"\"\"\n\n    def __init__(self, items: dict[TKey, TValue] | None = None, *, copy: bool = False) -&gt; None:\n        \"\"\"\n        Initialize with optional external dict reference.\n\n        Args:\n            items: Optional external dict to observe. If None, creates a new dict.\n        \"\"\"\n        if copy:\n            self._items: dict[TKey, TValue] = dict(items) if items is not None else {}\n        else:\n            self._items = items if items is not None else {}\n        self._change_callbacks: list[Callable[[ObservableDictChange[TKey, TValue]], None]] = []\n        self._add_callbacks: list[Callable[[TKey, TValue], None]] = []\n        self._remove_callbacks: list[Callable[[TKey, TValue], None]] = []\n        self._update_callbacks: list[Callable[[TKey, TValue], None]] = []\n        self._clear_callbacks: list[Callable[[dict[TKey, TValue]], None]] = []\n\n    @override\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of items in the dictionary.\"\"\"\n        return len(self._items)\n\n    @override\n    def __getitem__(self, key: TKey) -&gt; TValue:\n        \"\"\"Get an item from the dictionary.\"\"\"\n        return self._items[key]\n\n    @override\n    def __setitem__(self, key: TKey, value: TValue) -&gt; None:\n        \"\"\"Set an item in the dictionary.\"\"\"\n        if key in self._items:\n            self._items[key] = value\n            self._notify_update(key, value)\n        else:\n            self._items[key] = value\n            self._notify_add(key, value)\n\n    @override\n    def __delitem__(self, key: TKey) -&gt; None:\n        \"\"\"Delete an item from the dictionary.\"\"\"\n        value = self._items[key]\n        del self._items[key]\n        self._notify_remove(key, value)\n\n    @override\n    def __iter__(self) -&gt; Iterator[TKey]:\n        \"\"\"Return an iterator over the keys in the dictionary.\"\"\"\n        return iter(self._items)\n\n    @override\n    def __contains__(self, key: TKey) -&gt; bool:\n        \"\"\"Check if a key is in the dictionary.\"\"\"\n        return key in self._items\n\n    @override\n    def get(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"\n        Return the value for a key if it exists, otherwise return a default value.\n\n        Args:\n            key: The key to look up\n            default: The default value to return if the key is not found\n\n        Returns:\n            The value for the key, or the default value\n        \"\"\"\n        return self._items.get(key, default)\n\n    @override\n    def setdefault(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"\n        Return the value for a key if it exists, otherwise set and return the default value.\n\n        Args:\n            key: The key to look up\n            default: The default value to set and return if the key is not found\n\n        Returns:\n            The value for the key, or the default value\n        \"\"\"\n        if key not in self._items:\n            self._items[key] = cast(TValue, default)  # Cast to V since we know it's a value\n            self._notify_add(key, cast(TValue, default))\n            return default\n        return self._items[key]\n\n    @override\n    def pop(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"\n        Remove and return the value for a key if it exists, otherwise return a default value.\n\n        Args:\n            key: The key to look up\n            default: The default value to return if the key is not found\n\n        Returns:\n            The value for the key, or the default value\n\n        Raises:\n            KeyError: If the key is not found and no default value is provided\n        \"\"\"\n        if key in self._items:\n            value = self._items.pop(key)\n            self._notify_remove(key, value)\n            return value\n        if default is not None:\n            return default\n        raise KeyError(key)\n\n    @override\n    def popitem(self) -&gt; tuple[TKey, TValue]:\n        \"\"\"\n        Remove and return a (key, value) pair from the dictionary.\n\n        Returns:\n            A (key, value) pair\n\n        Raises:\n            KeyError: If the dictionary is empty\n        \"\"\"\n        key, value = self._items.popitem()\n        self._notify_remove(key, value)\n        return key, value\n\n    @override\n    def clear(self) -&gt; None:\n        \"\"\"Remove all items from the dictionary.\"\"\"\n        if not self._items:\n            return\n        items = self._items.copy()\n        self._items.clear()\n        self._notify_clear(items)\n\n    @override\n    def update(self, other: dict[TKey, TValue]) -&gt; None:\n        \"\"\"\n        Update the dictionary with the key/value pairs from another dictionary.\n\n        Args:\n            other: Another dictionary to update from\n        \"\"\"\n        if not other:\n            return\n        added_items: dict[TKey, TValue] = {}\n        updated_items: dict[TKey, TValue] = {}\n        for key, value in other.items():\n            if key in self._items:\n                updated_items[key] = value\n            else:\n                added_items[key] = value\n        self._items.update(other)\n\n        # Notify for added items\n        if added_items:\n            for key, value in added_items.items():\n                self._notify_add(key, value)\n\n        # Notify for updated items\n        if updated_items:\n            for key, value in updated_items.items():\n                self._notify_update(key, value)\n\n    @override\n    def keys(self) -&gt; list[TKey]:\n        \"\"\"\n        Return a list of all keys in the dictionary.\n\n        Returns:\n            A list of keys\n        \"\"\"\n        return list(self._items.keys())\n\n    @override\n    def values(self) -&gt; list[TValue]:\n        \"\"\"\n        Return a list of all values in the dictionary.\n\n        Returns:\n            A list of values\n        \"\"\"\n        return list(self._items.values())\n\n    @override\n    def items(self) -&gt; list[tuple[TKey, TValue]]:\n        \"\"\"\n        Return a list of all (key, value) pairs in the dictionary.\n\n        Returns:\n            A list of (key, value) pairs\n        \"\"\"\n        return list(self._items.items())\n\n    @override\n    def copy(self) -&gt; dict[TKey, TValue]:\n        \"\"\"\n        Return a shallow copy of the dictionary.\n\n        Returns:\n            A copy of the dictionary\n        \"\"\"\n        return self._items.copy()\n\n    @override\n    def on_change(self, callback: Callable[[ObservableDictChange[TKey, TValue]], None]) -&gt; None:\n        \"\"\"\n        Add a callback to be called when the dictionary changes.\n\n        Args:\n            callback: A function that takes a DictChange object\n        \"\"\"\n        self._change_callbacks.append(callback)\n\n    @override\n    def on_add(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"\n        Register for add events with key and value.\n\n        Args:\n            callback: A function that takes a key and value\n        \"\"\"\n        self._add_callbacks.append(callback)\n\n    @override\n    def on_remove(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"\n        Register for remove events with key and value.\n\n        Args:\n            callback: A function that takes a key and value\n        \"\"\"\n        self._remove_callbacks.append(callback)\n\n    @override\n    def on_update(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"\n        Register for update events with key and new value.\n\n        Args:\n            callback: A function that takes a key and new value\n        \"\"\"\n        self._update_callbacks.append(callback)\n\n    @override\n    def on_clear(self, callback: Callable[[dict[TKey, TValue]], None]) -&gt; None:\n        \"\"\"\n        Register for clear events with the cleared items.\n\n        Args:\n            callback: A function that takes a dict of cleared items\n        \"\"\"\n        self._clear_callbacks.append(callback)\n\n    def _notify_add(self, key: TKey, value: TValue) -&gt; None:\n        \"\"\"\n        Notify all callbacks of an item being added.\n\n        Args:\n            key: The key that was added\n            value: The value that was added\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._add_callbacks:\n            callback(key, value)\n\n        # Create a dictionary with the single item for the items field\n        items_dict = {key: value}\n\n        # Call general change callbacks\n        change = ObservableDictChange(\n            type=ObservableCollectionChangeType.ADD,\n            key=key,\n            value=value,\n            items=items_dict,\n        )\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_remove(self, key: TKey, value: TValue) -&gt; None:\n        \"\"\"\n        Notify all callbacks of an item being removed.\n\n        Args:\n            key: The key that was removed\n            value: The value that was removed\n        \"\"\"\n        print(f\"DEBUG: ObservableDict._notify_remove called with key={key}, value={value}\")\n\n        # Call specific callbacks\n        for callback in self._remove_callbacks:\n            callback(key, value)\n\n        # Create a dictionary with the single item for the items field\n        items_dict = {key: value}\n\n        # Call general change callbacks\n        change = ObservableDictChange(\n            type=ObservableCollectionChangeType.REMOVE,\n            key=key,\n            value=value,\n            items=items_dict,\n        )\n        print(f\"DEBUG: ObservableDict._notify_remove - Created change object: type={change.type}, key={change.key}, value={change.value}\")\n        for callback in self._change_callbacks:\n            callback(change)\n        print(\"DEBUG: ObservableDict._notify_remove - Completed\")\n\n    def _notify_update(self, key: TKey, value: TValue) -&gt; None:\n        \"\"\"\n        Notify all callbacks of an item being updated.\n\n        Args:\n            key: The key that was updated\n            value: The new value\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._update_callbacks:\n            callback(key, value)\n\n        # Create a dictionary with the single item for the items field\n        items_dict = {key: value}\n\n        # Call general change callbacks\n        change = ObservableDictChange(\n            type=ObservableCollectionChangeType.UPDATE,\n            key=key,\n            value=value,\n            items=items_dict,\n        )\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_clear(self, items: dict[TKey, TValue]) -&gt; None:\n        \"\"\"\n        Notify all callbacks of the dictionary being cleared.\n\n        Args:\n            items: The items that were cleared\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._clear_callbacks:\n            callback(items)\n\n        # Call general change callbacks\n        change = ObservableDictChange(type=ObservableCollectionChangeType.CLEAR, items=items)\n        for callback in self._change_callbacks:\n            callback(change)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Check if a key is in the dictionary.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __contains__(self, key: TKey) -&gt; bool:\n    \"\"\"Check if a key is in the dictionary.\"\"\"\n    return key in self._items\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Delete an item from the dictionary.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __delitem__(self, key: TKey) -&gt; None:\n    \"\"\"Delete an item from the dictionary.\"\"\"\n    value = self._items[key]\n    del self._items[key]\n    self._notify_remove(key, value)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get an item from the dictionary.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __getitem__(self, key: TKey) -&gt; TValue:\n    \"\"\"Get an item from the dictionary.\"\"\"\n    return self._items[key]\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__init__","title":"<code>__init__(items=None, *, copy=False)</code>","text":"<p>Initialize with optional external dict reference.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>dict[TKey, TValue] | None</code> <p>Optional external dict to observe. If None, creates a new dict.</p> <code>None</code> Source code in <code>observant\\observable_dict.py</code> <pre><code>def __init__(self, items: dict[TKey, TValue] | None = None, *, copy: bool = False) -&gt; None:\n    \"\"\"\n    Initialize with optional external dict reference.\n\n    Args:\n        items: Optional external dict to observe. If None, creates a new dict.\n    \"\"\"\n    if copy:\n        self._items: dict[TKey, TValue] = dict(items) if items is not None else {}\n    else:\n        self._items = items if items is not None else {}\n    self._change_callbacks: list[Callable[[ObservableDictChange[TKey, TValue]], None]] = []\n    self._add_callbacks: list[Callable[[TKey, TValue], None]] = []\n    self._remove_callbacks: list[Callable[[TKey, TValue], None]] = []\n    self._update_callbacks: list[Callable[[TKey, TValue], None]] = []\n    self._clear_callbacks: list[Callable[[dict[TKey, TValue]], None]] = []\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the keys in the dictionary.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __iter__(self) -&gt; Iterator[TKey]:\n    \"\"\"Return an iterator over the keys in the dictionary.\"\"\"\n    return iter(self._items)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of items in the dictionary.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __len__(self) -&gt; int:\n    \"\"\"Return the number of items in the dictionary.\"\"\"\n    return len(self._items)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set an item in the dictionary.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __setitem__(self, key: TKey, value: TValue) -&gt; None:\n    \"\"\"Set an item in the dictionary.\"\"\"\n    if key in self._items:\n        self._items[key] = value\n        self._notify_update(key, value)\n    else:\n        self._items[key] = value\n        self._notify_add(key, value)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.clear","title":"<code>clear()</code>","text":"<p>Remove all items from the dictionary.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef clear(self) -&gt; None:\n    \"\"\"Remove all items from the dictionary.\"\"\"\n    if not self._items:\n        return\n    items = self._items.copy()\n    self._items.clear()\n    self._notify_clear(items)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.copy","title":"<code>copy()</code>","text":"<p>Return a shallow copy of the dictionary.</p> <p>Returns:</p> Type Description <code>dict[TKey, TValue]</code> <p>A copy of the dictionary</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef copy(self) -&gt; dict[TKey, TValue]:\n    \"\"\"\n    Return a shallow copy of the dictionary.\n\n    Returns:\n        A copy of the dictionary\n    \"\"\"\n    return self._items.copy()\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.get","title":"<code>get(key, default=None)</code>","text":"<p>Return the value for a key if it exists, otherwise return a default value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TKey</code> <p>The key to look up</p> required <code>default</code> <code>TValue | None</code> <p>The default value to return if the key is not found</p> <code>None</code> <p>Returns:</p> Type Description <code>TValue | None</code> <p>The value for the key, or the default value</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef get(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"\n    Return the value for a key if it exists, otherwise return a default value.\n\n    Args:\n        key: The key to look up\n        default: The default value to return if the key is not found\n\n    Returns:\n        The value for the key, or the default value\n    \"\"\"\n    return self._items.get(key, default)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.items","title":"<code>items()</code>","text":"<p>Return a list of all (key, value) pairs in the dictionary.</p> <p>Returns:</p> Type Description <code>list[tuple[TKey, TValue]]</code> <p>A list of (key, value) pairs</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef items(self) -&gt; list[tuple[TKey, TValue]]:\n    \"\"\"\n    Return a list of all (key, value) pairs in the dictionary.\n\n    Returns:\n        A list of (key, value) pairs\n    \"\"\"\n    return list(self._items.items())\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.keys","title":"<code>keys()</code>","text":"<p>Return a list of all keys in the dictionary.</p> <p>Returns:</p> Type Description <code>list[TKey]</code> <p>A list of keys</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef keys(self) -&gt; list[TKey]:\n    \"\"\"\n    Return a list of all keys in the dictionary.\n\n    Returns:\n        A list of keys\n    \"\"\"\n    return list(self._items.keys())\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.on_add","title":"<code>on_add(callback)</code>","text":"<p>Register for add events with key and value.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[TKey, TValue], None]</code> <p>A function that takes a key and value</p> required Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef on_add(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"\n    Register for add events with key and value.\n\n    Args:\n        callback: A function that takes a key and value\n    \"\"\"\n    self._add_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.on_change","title":"<code>on_change(callback)</code>","text":"<p>Add a callback to be called when the dictionary changes.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ObservableDictChange[TKey, TValue]], None]</code> <p>A function that takes a DictChange object</p> required Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef on_change(self, callback: Callable[[ObservableDictChange[TKey, TValue]], None]) -&gt; None:\n    \"\"\"\n    Add a callback to be called when the dictionary changes.\n\n    Args:\n        callback: A function that takes a DictChange object\n    \"\"\"\n    self._change_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.on_clear","title":"<code>on_clear(callback)</code>","text":"<p>Register for clear events with the cleared items.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[dict[TKey, TValue]], None]</code> <p>A function that takes a dict of cleared items</p> required Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef on_clear(self, callback: Callable[[dict[TKey, TValue]], None]) -&gt; None:\n    \"\"\"\n    Register for clear events with the cleared items.\n\n    Args:\n        callback: A function that takes a dict of cleared items\n    \"\"\"\n    self._clear_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.on_remove","title":"<code>on_remove(callback)</code>","text":"<p>Register for remove events with key and value.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[TKey, TValue], None]</code> <p>A function that takes a key and value</p> required Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef on_remove(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"\n    Register for remove events with key and value.\n\n    Args:\n        callback: A function that takes a key and value\n    \"\"\"\n    self._remove_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.on_update","title":"<code>on_update(callback)</code>","text":"<p>Register for update events with key and new value.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[TKey, TValue], None]</code> <p>A function that takes a key and new value</p> required Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef on_update(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"\n    Register for update events with key and new value.\n\n    Args:\n        callback: A function that takes a key and new value\n    \"\"\"\n    self._update_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.pop","title":"<code>pop(key, default=None)</code>","text":"<p>Remove and return the value for a key if it exists, otherwise return a default value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TKey</code> <p>The key to look up</p> required <code>default</code> <code>TValue | None</code> <p>The default value to return if the key is not found</p> <code>None</code> <p>Returns:</p> Type Description <code>TValue | None</code> <p>The value for the key, or the default value</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found and no default value is provided</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef pop(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"\n    Remove and return the value for a key if it exists, otherwise return a default value.\n\n    Args:\n        key: The key to look up\n        default: The default value to return if the key is not found\n\n    Returns:\n        The value for the key, or the default value\n\n    Raises:\n        KeyError: If the key is not found and no default value is provided\n    \"\"\"\n    if key in self._items:\n        value = self._items.pop(key)\n        self._notify_remove(key, value)\n        return value\n    if default is not None:\n        return default\n    raise KeyError(key)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.popitem","title":"<code>popitem()</code>","text":"<p>Remove and return a (key, value) pair from the dictionary.</p> <p>Returns:</p> Type Description <code>tuple[TKey, TValue]</code> <p>A (key, value) pair</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the dictionary is empty</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef popitem(self) -&gt; tuple[TKey, TValue]:\n    \"\"\"\n    Remove and return a (key, value) pair from the dictionary.\n\n    Returns:\n        A (key, value) pair\n\n    Raises:\n        KeyError: If the dictionary is empty\n    \"\"\"\n    key, value = self._items.popitem()\n    self._notify_remove(key, value)\n    return key, value\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.setdefault","title":"<code>setdefault(key, default=None)</code>","text":"<p>Return the value for a key if it exists, otherwise set and return the default value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TKey</code> <p>The key to look up</p> required <code>default</code> <code>TValue | None</code> <p>The default value to set and return if the key is not found</p> <code>None</code> <p>Returns:</p> Type Description <code>TValue | None</code> <p>The value for the key, or the default value</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef setdefault(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"\n    Return the value for a key if it exists, otherwise set and return the default value.\n\n    Args:\n        key: The key to look up\n        default: The default value to set and return if the key is not found\n\n    Returns:\n        The value for the key, or the default value\n    \"\"\"\n    if key not in self._items:\n        self._items[key] = cast(TValue, default)  # Cast to V since we know it's a value\n        self._notify_add(key, cast(TValue, default))\n        return default\n    return self._items[key]\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.update","title":"<code>update(other)</code>","text":"<p>Update the dictionary with the key/value pairs from another dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>dict[TKey, TValue]</code> <p>Another dictionary to update from</p> required Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef update(self, other: dict[TKey, TValue]) -&gt; None:\n    \"\"\"\n    Update the dictionary with the key/value pairs from another dictionary.\n\n    Args:\n        other: Another dictionary to update from\n    \"\"\"\n    if not other:\n        return\n    added_items: dict[TKey, TValue] = {}\n    updated_items: dict[TKey, TValue] = {}\n    for key, value in other.items():\n        if key in self._items:\n            updated_items[key] = value\n        else:\n            added_items[key] = value\n    self._items.update(other)\n\n    # Notify for added items\n    if added_items:\n        for key, value in added_items.items():\n            self._notify_add(key, value)\n\n    # Notify for updated items\n    if updated_items:\n        for key, value in updated_items.items():\n            self._notify_update(key, value)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.values","title":"<code>values()</code>","text":"<p>Return a list of all values in the dictionary.</p> <p>Returns:</p> Type Description <code>list[TValue]</code> <p>A list of values</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef values(self) -&gt; list[TValue]:\n    \"\"\"\n    Return a list of all values in the dictionary.\n\n    Returns:\n        A list of values\n    \"\"\"\n    return list(self._items.values())\n</code></pre>"},{"location":"api_reference/observable_list/","title":"ObservableList","text":""},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList","title":"<code>observant.observable_list.ObservableList</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>IObservableList[T]</code></p> <p>Base implementation that can work with an external list or create its own.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>class ObservableList(Generic[T], IObservableList[T]):\n    \"\"\"Base implementation that can work with an external list or create its own.\"\"\"\n\n    def __init__(self, items: list[T] | None = None, *, copy: bool = False):\n        \"\"\"\n        Initialize with optional external list reference.\n\n        Args:\n            items: Optional external list to observe. If None, creates a new list.\n        \"\"\"\n        if copy:\n            self._items: list[T] = list(items) if items is not None else []\n        else:\n            self._items: list[T] = items if items is not None else []\n        self._change_callbacks: list[Callable[[ObservableListChange[T]], None]] = []\n        self._add_callbacks: list[Callable[[T, int], None]] = []\n        self._remove_callbacks: list[Callable[[T, int], None]] = []\n        self._clear_callbacks: list[Callable[[list[T]], None]] = []\n\n    @override\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of items in the list.\"\"\"\n        return len(self._items)\n\n    @override\n    def __getitem__(self, index: int | slice) -&gt; T | list[T]:\n        \"\"\"Get an item or slice of items from the list.\"\"\"\n        return self._items[index]\n\n    @override\n    def __setitem__(self, index: int | slice, value: T | list[T]) -&gt; None:\n        \"\"\"Set an item or slice of items in the list.\"\"\"\n        if isinstance(index, slice):\n            # Remove old items\n            old_items = self._items[index]\n            if old_items:\n                self._notify_remove_items(old_items, index.start)\n\n            # Add new items\n            if isinstance(value, list):\n                # Explicitly cast to list[C] to help Pylance\n                self._items[index] = value\n                if value:\n                    typed_value: list[T] = cast(list[T], value)\n                    self._notify_add_items(typed_value, index.start)\n            else:\n                # Handle single item assigned to slice\n                single_value: T = cast(T, value)\n                items_list: list[T] = [single_value]\n                self._items[index] = items_list\n                self._notify_add_items(items_list, index.start)\n        else:\n            # Remove old item\n            old_item = self._items[index]\n            self._notify_remove(old_item, index)\n\n            # Add new item\n            new_value: T = cast(T, value)  # Cast to T since we know it's a single item\n            self._items[index] = new_value\n            self._notify_add(new_value, index)\n\n    @override\n    def __delitem__(self, index: int | slice) -&gt; None:\n        \"\"\"Delete an item or slice of items from the list.\"\"\"\n        if isinstance(index, slice):\n            items = self._items[index]\n            if items:\n                self._notify_remove_items(items, index.start)\n        else:\n            item = self._items[index]\n            self._notify_remove(item, index)\n        del self._items[index]\n\n    @override\n    def __iter__(self) -&gt; Iterator[T]:\n        \"\"\"Return an iterator over the items in the list.\"\"\"\n        return iter(self._items)\n\n    @override\n    def __contains__(self, item: T) -&gt; bool:\n        \"\"\"Check if an item is in the list.\"\"\"\n        return item in self._items\n\n    @override\n    def append(self, item: T) -&gt; None:\n        \"\"\"\n        Add an item to the end of the list.\n\n        Args:\n            item: The item to add\n        \"\"\"\n        self._items.append(item)\n        self._notify_add(item, len(self._items) - 1)\n\n    @override\n    def extend(self, items: list[T]) -&gt; None:\n        \"\"\"\n        Extend the list by appending all items from the iterable.\n\n        Args:\n            items: The items to add\n        \"\"\"\n        if not items:\n            return\n        start_index = len(self._items)\n        self._items.extend(items)\n        self._notify_add_items(items, start_index)\n\n    @override\n    def insert(self, index: int, item: T) -&gt; None:\n        \"\"\"\n        Insert an item at a given position.\n\n        Args:\n            index: The position to insert the item\n            item: The item to insert\n        \"\"\"\n        self._items.insert(index, item)\n        self._notify_add(item, index)\n\n    @override\n    def remove(self, item: T) -&gt; None:\n        \"\"\"\n        Remove the first occurrence of an item from the list.\n\n        Args:\n            item: The item to remove\n\n        Raises:\n            ValueError: If the item is not in the list\n        \"\"\"\n        index = self._items.index(item)\n        self._items.remove(item)\n        self._notify_remove(item, index)\n\n    @override\n    def pop(self, index: int = -1) -&gt; T:\n        \"\"\"\n        Remove and return an item at a given position.\n\n        Args:\n            index: The position to remove the item from (default is -1, which is the last item)\n\n        Returns:\n            The removed item\n        \"\"\"\n        item = self._items[index]\n        self._items.pop(index)\n        self._notify_remove(item, index)\n        return item\n\n    @override\n    def clear(self) -&gt; None:\n        \"\"\"Remove all items from the list.\"\"\"\n        if not self._items:\n            return\n        items = self._items.copy()\n        self._items.clear()\n        self._notify_clear(items)\n\n    @override\n    def index(self, item: T, start: int = 0, end: int | None = None) -&gt; int:\n        \"\"\"\n        Return the index of the first occurrence of an item.\n\n        Args:\n            item: The item to find\n            start: The start index to search from\n            end: The end index to search to\n\n        Returns:\n            The index of the item\n\n        Raises:\n            ValueError: If the item is not in the list\n        \"\"\"\n        if end is None:\n            return self._items.index(item, start)\n        return self._items.index(item, start, end)\n\n    @override\n    def count(self, item: T) -&gt; int:\n        \"\"\"\n        Return the number of occurrences of an item in the list.\n\n        Args:\n            item: The item to count\n\n        Returns:\n            The number of occurrences\n        \"\"\"\n        return self._items.count(item)\n\n    @override\n    def sort(\n        self,\n        *,\n        key: Callable[[T], Any] | None = None,\n        reverse: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Sort the list in place.\n\n        Args:\n            key: A function that takes an item and returns a key for sorting\n            reverse: Whether to sort in reverse order\n        \"\"\"\n\n        # Note: pylance is just WRONG about the keys being wrong types.\n\n        if key is None:\n            if reverse:\n                self._items.sort(key=None, reverse=True)  # type: ignore\n            else:\n                self._items.sort(key=None, reverse=False)  # type: ignore\n        else:\n            self._items.sort(key=key, reverse=reverse)\n\n    @override\n    def reverse(self) -&gt; None:\n        \"\"\"Reverse the list in place.\"\"\"\n        self._items.reverse()\n        # No notification needed as the items themselves haven't changed\n\n    @override\n    def copy(self) -&gt; list[T]:\n        \"\"\"\n        Return a shallow copy of the list.\n\n        Returns:\n            A copy of the list\n        \"\"\"\n        return self._items.copy()\n\n    @override\n    def on_change(self, callback: Callable[[ObservableListChange[T]], None]) -&gt; None:\n        \"\"\"\n        Add a callback to be called when the list changes.\n\n        Args:\n            callback: A function that takes a ListChange object\n        \"\"\"\n        self._change_callbacks.append(callback)\n\n    @override\n    def on_add(self, callback: Callable[[T, int], None]) -&gt; None:\n        \"\"\"\n        Register for add events with item and index.\n\n        Args:\n            callback: A function that takes an item and its index\n        \"\"\"\n        self._add_callbacks.append(callback)\n\n    @override\n    def on_remove(self, callback: Callable[[T, int], None]) -&gt; None:\n        \"\"\"\n        Register for remove events with item and index.\n\n        Args:\n            callback: A function that takes an item and its index\n        \"\"\"\n        self._remove_callbacks.append(callback)\n\n    @override\n    def on_clear(self, callback: Callable[[list[T]], None]) -&gt; None:\n        \"\"\"\n        Register for clear events with the cleared items.\n\n        Args:\n            callback: A function that takes a list of cleared items\n        \"\"\"\n        self._clear_callbacks.append(callback)\n\n    def _notify_add(self, item: T, index: int) -&gt; None:\n        \"\"\"\n        Notify all callbacks of an item being added.\n\n        Args:\n            item: The item that was added\n            index: The index where the item was added\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._add_callbacks:\n            callback(item, index)\n\n        # Call general change callbacks\n        change = ObservableListChange(type=ObservableCollectionChangeType.ADD, index=index, item=item)\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_add_items(self, items: list[T], start_index: int) -&gt; None:\n        \"\"\"\n        Notify all callbacks of multiple items being added.\n\n        Args:\n            items: The items that were added\n            start_index: The index where the items were added\n        \"\"\"\n        # Call specific callbacks for each item\n        for i, item in enumerate(items):\n            index = start_index + i\n            for callback in self._add_callbacks:\n                callback(item, index)\n\n        # Call general change callbacks\n        change = ObservableListChange(type=ObservableCollectionChangeType.ADD, index=start_index, items=items)\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_remove(self, item: T, index: int) -&gt; None:\n        \"\"\"\n        Notify all callbacks of an item being removed.\n\n        Args:\n            item: The item that was removed\n            index: The index where the item was removed\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._remove_callbacks:\n            callback(item, index)\n\n        # Call general change callbacks\n        change = ObservableListChange(type=ObservableCollectionChangeType.REMOVE, index=index, item=item)\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_remove_items(self, items: list[T], start_index: int) -&gt; None:\n        \"\"\"\n        Notify all callbacks of multiple items being removed.\n\n        Args:\n            items: The items that were removed\n            start_index: The index where the items were removed\n        \"\"\"\n        # Call specific callbacks for each item\n        for i, item in enumerate(items):\n            index = start_index + i\n            for callback in self._remove_callbacks:\n                callback(item, index)\n\n        # Call general change callbacks\n        change = ObservableListChange(type=ObservableCollectionChangeType.REMOVE, index=start_index, items=items)\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_clear(self, items: list[T]) -&gt; None:\n        \"\"\"\n        Notify all callbacks of the list being cleared.\n\n        Args:\n            items: The items that were cleared\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._clear_callbacks:\n            callback(items)\n\n        # Call general change callbacks\n        change = ObservableListChange(type=ObservableCollectionChangeType.CLEAR, items=items)\n        for callback in self._change_callbacks:\n            callback(change)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__contains__","title":"<code>__contains__(item)</code>","text":"<p>Check if an item is in the list.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __contains__(self, item: T) -&gt; bool:\n    \"\"\"Check if an item is in the list.\"\"\"\n    return item in self._items\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__delitem__","title":"<code>__delitem__(index)</code>","text":"<p>Delete an item or slice of items from the list.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __delitem__(self, index: int | slice) -&gt; None:\n    \"\"\"Delete an item or slice of items from the list.\"\"\"\n    if isinstance(index, slice):\n        items = self._items[index]\n        if items:\n            self._notify_remove_items(items, index.start)\n    else:\n        item = self._items[index]\n        self._notify_remove(item, index)\n    del self._items[index]\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Get an item or slice of items from the list.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __getitem__(self, index: int | slice) -&gt; T | list[T]:\n    \"\"\"Get an item or slice of items from the list.\"\"\"\n    return self._items[index]\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__init__","title":"<code>__init__(items=None, *, copy=False)</code>","text":"<p>Initialize with optional external list reference.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[T] | None</code> <p>Optional external list to observe. If None, creates a new list.</p> <code>None</code> Source code in <code>observant\\observable_list.py</code> <pre><code>def __init__(self, items: list[T] | None = None, *, copy: bool = False):\n    \"\"\"\n    Initialize with optional external list reference.\n\n    Args:\n        items: Optional external list to observe. If None, creates a new list.\n    \"\"\"\n    if copy:\n        self._items: list[T] = list(items) if items is not None else []\n    else:\n        self._items: list[T] = items if items is not None else []\n    self._change_callbacks: list[Callable[[ObservableListChange[T]], None]] = []\n    self._add_callbacks: list[Callable[[T, int], None]] = []\n    self._remove_callbacks: list[Callable[[T, int], None]] = []\n    self._clear_callbacks: list[Callable[[list[T]], None]] = []\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the items in the list.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __iter__(self) -&gt; Iterator[T]:\n    \"\"\"Return an iterator over the items in the list.\"\"\"\n    return iter(self._items)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of items in the list.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __len__(self) -&gt; int:\n    \"\"\"Return the number of items in the list.\"\"\"\n    return len(self._items)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__setitem__","title":"<code>__setitem__(index, value)</code>","text":"<p>Set an item or slice of items in the list.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __setitem__(self, index: int | slice, value: T | list[T]) -&gt; None:\n    \"\"\"Set an item or slice of items in the list.\"\"\"\n    if isinstance(index, slice):\n        # Remove old items\n        old_items = self._items[index]\n        if old_items:\n            self._notify_remove_items(old_items, index.start)\n\n        # Add new items\n        if isinstance(value, list):\n            # Explicitly cast to list[C] to help Pylance\n            self._items[index] = value\n            if value:\n                typed_value: list[T] = cast(list[T], value)\n                self._notify_add_items(typed_value, index.start)\n        else:\n            # Handle single item assigned to slice\n            single_value: T = cast(T, value)\n            items_list: list[T] = [single_value]\n            self._items[index] = items_list\n            self._notify_add_items(items_list, index.start)\n    else:\n        # Remove old item\n        old_item = self._items[index]\n        self._notify_remove(old_item, index)\n\n        # Add new item\n        new_value: T = cast(T, value)  # Cast to T since we know it's a single item\n        self._items[index] = new_value\n        self._notify_add(new_value, index)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.append","title":"<code>append(item)</code>","text":"<p>Add an item to the end of the list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to add</p> required Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef append(self, item: T) -&gt; None:\n    \"\"\"\n    Add an item to the end of the list.\n\n    Args:\n        item: The item to add\n    \"\"\"\n    self._items.append(item)\n    self._notify_add(item, len(self._items) - 1)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.clear","title":"<code>clear()</code>","text":"<p>Remove all items from the list.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef clear(self) -&gt; None:\n    \"\"\"Remove all items from the list.\"\"\"\n    if not self._items:\n        return\n    items = self._items.copy()\n    self._items.clear()\n    self._notify_clear(items)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.copy","title":"<code>copy()</code>","text":"<p>Return a shallow copy of the list.</p> <p>Returns:</p> Type Description <code>list[T]</code> <p>A copy of the list</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef copy(self) -&gt; list[T]:\n    \"\"\"\n    Return a shallow copy of the list.\n\n    Returns:\n        A copy of the list\n    \"\"\"\n    return self._items.copy()\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.count","title":"<code>count(item)</code>","text":"<p>Return the number of occurrences of an item in the list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to count</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of occurrences</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef count(self, item: T) -&gt; int:\n    \"\"\"\n    Return the number of occurrences of an item in the list.\n\n    Args:\n        item: The item to count\n\n    Returns:\n        The number of occurrences\n    \"\"\"\n    return self._items.count(item)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.extend","title":"<code>extend(items)</code>","text":"<p>Extend the list by appending all items from the iterable.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[T]</code> <p>The items to add</p> required Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef extend(self, items: list[T]) -&gt; None:\n    \"\"\"\n    Extend the list by appending all items from the iterable.\n\n    Args:\n        items: The items to add\n    \"\"\"\n    if not items:\n        return\n    start_index = len(self._items)\n    self._items.extend(items)\n    self._notify_add_items(items, start_index)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.index","title":"<code>index(item, start=0, end=None)</code>","text":"<p>Return the index of the first occurrence of an item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to find</p> required <code>start</code> <code>int</code> <p>The start index to search from</p> <code>0</code> <code>end</code> <code>int | None</code> <p>The end index to search to</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The index of the item</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the item is not in the list</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef index(self, item: T, start: int = 0, end: int | None = None) -&gt; int:\n    \"\"\"\n    Return the index of the first occurrence of an item.\n\n    Args:\n        item: The item to find\n        start: The start index to search from\n        end: The end index to search to\n\n    Returns:\n        The index of the item\n\n    Raises:\n        ValueError: If the item is not in the list\n    \"\"\"\n    if end is None:\n        return self._items.index(item, start)\n    return self._items.index(item, start, end)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.insert","title":"<code>insert(index, item)</code>","text":"<p>Insert an item at a given position.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The position to insert the item</p> required <code>item</code> <code>T</code> <p>The item to insert</p> required Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef insert(self, index: int, item: T) -&gt; None:\n    \"\"\"\n    Insert an item at a given position.\n\n    Args:\n        index: The position to insert the item\n        item: The item to insert\n    \"\"\"\n    self._items.insert(index, item)\n    self._notify_add(item, index)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.on_add","title":"<code>on_add(callback)</code>","text":"<p>Register for add events with item and index.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[T, int], None]</code> <p>A function that takes an item and its index</p> required Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef on_add(self, callback: Callable[[T, int], None]) -&gt; None:\n    \"\"\"\n    Register for add events with item and index.\n\n    Args:\n        callback: A function that takes an item and its index\n    \"\"\"\n    self._add_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.on_change","title":"<code>on_change(callback)</code>","text":"<p>Add a callback to be called when the list changes.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ObservableListChange[T]], None]</code> <p>A function that takes a ListChange object</p> required Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef on_change(self, callback: Callable[[ObservableListChange[T]], None]) -&gt; None:\n    \"\"\"\n    Add a callback to be called when the list changes.\n\n    Args:\n        callback: A function that takes a ListChange object\n    \"\"\"\n    self._change_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.on_clear","title":"<code>on_clear(callback)</code>","text":"<p>Register for clear events with the cleared items.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[list[T]], None]</code> <p>A function that takes a list of cleared items</p> required Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef on_clear(self, callback: Callable[[list[T]], None]) -&gt; None:\n    \"\"\"\n    Register for clear events with the cleared items.\n\n    Args:\n        callback: A function that takes a list of cleared items\n    \"\"\"\n    self._clear_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.on_remove","title":"<code>on_remove(callback)</code>","text":"<p>Register for remove events with item and index.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[T, int], None]</code> <p>A function that takes an item and its index</p> required Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef on_remove(self, callback: Callable[[T, int], None]) -&gt; None:\n    \"\"\"\n    Register for remove events with item and index.\n\n    Args:\n        callback: A function that takes an item and its index\n    \"\"\"\n    self._remove_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.pop","title":"<code>pop(index=-1)</code>","text":"<p>Remove and return an item at a given position.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The position to remove the item from (default is -1, which is the last item)</p> <code>-1</code> <p>Returns:</p> Type Description <code>T</code> <p>The removed item</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef pop(self, index: int = -1) -&gt; T:\n    \"\"\"\n    Remove and return an item at a given position.\n\n    Args:\n        index: The position to remove the item from (default is -1, which is the last item)\n\n    Returns:\n        The removed item\n    \"\"\"\n    item = self._items[index]\n    self._items.pop(index)\n    self._notify_remove(item, index)\n    return item\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.remove","title":"<code>remove(item)</code>","text":"<p>Remove the first occurrence of an item from the list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the item is not in the list</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef remove(self, item: T) -&gt; None:\n    \"\"\"\n    Remove the first occurrence of an item from the list.\n\n    Args:\n        item: The item to remove\n\n    Raises:\n        ValueError: If the item is not in the list\n    \"\"\"\n    index = self._items.index(item)\n    self._items.remove(item)\n    self._notify_remove(item, index)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.reverse","title":"<code>reverse()</code>","text":"<p>Reverse the list in place.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef reverse(self) -&gt; None:\n    \"\"\"Reverse the list in place.\"\"\"\n    self._items.reverse()\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.sort","title":"<code>sort(*, key=None, reverse=False)</code>","text":"<p>Sort the list in place.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], Any] | None</code> <p>A function that takes an item and returns a key for sorting</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Whether to sort in reverse order</p> <code>False</code> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef sort(\n    self,\n    *,\n    key: Callable[[T], Any] | None = None,\n    reverse: bool = False,\n) -&gt; None:\n    \"\"\"\n    Sort the list in place.\n\n    Args:\n        key: A function that takes an item and returns a key for sorting\n        reverse: Whether to sort in reverse order\n    \"\"\"\n\n    # Note: pylance is just WRONG about the keys being wrong types.\n\n    if key is None:\n        if reverse:\n            self._items.sort(key=None, reverse=True)  # type: ignore\n        else:\n            self._items.sort(key=None, reverse=False)  # type: ignore\n    else:\n        self._items.sort(key=key, reverse=reverse)\n</code></pre>"},{"location":"api_reference/observable_proxy/","title":"ObservableProxy","text":""},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy","title":"<code>observant.observable_proxy.ObservableProxy</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>IObservableProxy[T]</code></p> <p>Proxy for a data object that exposes its fields as Observable, ObservableList, or ObservableDict. Provides optional sync behavior to automatically write back to the source model.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>class ObservableProxy(Generic[T], IObservableProxy[T]):\n    \"\"\"\n    Proxy for a data object that exposes its fields as Observable, ObservableList, or ObservableDict.\n    Provides optional sync behavior to automatically write back to the source model.\n    \"\"\"\n\n    def __init__(\n        self,\n        obj: T,\n        *,\n        sync: bool = False,\n        undo: bool = False,  # Undo is disabled by default\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            obj: The object to proxy.\n            sync: If True, observables will sync back to the model immediately. If False, changes must be saved explicitly.\n            undo: If True, enables undo/redo functionality for all fields.\n            undo_max: Maximum number of undo steps to store. None means unlimited.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n        \"\"\"\n        self._obj = obj\n        self._sync_default = sync\n\n        # Print a warning if sync and undo are both enabled\n        if sync and undo:\n            print(\"Warning: sync=True with undo=True may cause unexpected model mutations during undo/redo.\")\n\n        self._scalars: dict[ProxyFieldKey, Observable[Any]] = {}\n        self._lists: dict[ProxyFieldKey, ObservableList[Any]] = {}\n        self._dicts: dict[ProxyFieldKey, ObservableDict[Any, Any]] = {}\n        self._computeds: dict[str, Observable[Any]] = {}\n        self._dirty_fields: set[str] = set()\n\n        # Validation related fields\n        self._validators: dict[str, list[Callable[[Any], str | None]]] = {}\n        self._validation_errors_dict = ObservableDict[str, list[str]]({})\n        self._validation_for_cache: dict[str, Observable[list[str]]] = {}\n        self._is_valid_obs = Observable[bool](True)\n\n        # Undo/redo related fields\n        self._default_undo_config = UndoConfig(enabled=undo, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n        self._field_undo_configs: dict[str, UndoConfig] = {}\n        self._undo_stacks: dict[str, list[Callable[[], None]]] = {}\n        self._redo_stacks: dict[str, list[Callable[[], None]]] = {}\n        self._last_change_times: dict[str, float] = {}\n        self._pending_undo_groups: dict[str, Callable[[], None] | None] = {}\n        self._initial_values: dict[str, Any] = {}  # Store initial values for undo\n\n    @override\n    def observable(\n        self,\n        typ: type[TValue],\n        attr: str,\n        *,\n        sync: bool | None = None,\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; IObservable[TValue]:\n        \"\"\"\n        Get or create an Observable[T] for a scalar field.\n\n        Args:\n            typ: The type of the field.\n            attr: The field name.\n            sync: Whether to sync changes back to the model immediately.\n            undo_max: Maximum number of undo steps to store. None means use the default.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n        \"\"\"\n        sync = self._sync_default if sync is None else sync\n        key = ProxyFieldKey(attr, sync)\n\n        # Set up undo config if provided\n        if undo_max is not None or undo_debounce_ms is not None:\n            self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n        # Get the initial value\n        val = getattr(self._obj, attr)\n\n        if key not in self._scalars:\n            # Create observable with callbacks disabled to prevent premature tracking\n            # obs = Observable(val, on_change_enabled=False)\n            obs = UndoableObservable(val, attr, self, on_change_enabled=False)\n\n            # Store the observable first so it can be found by _track_scalar_change\n            self._scalars[key] = obs\n\n            if sync:\n                obs.on_change(lambda v: setattr(self._obj, attr, v))\n            # Register dirty tracking callback\n            obs.on_change(lambda _: self._dirty_fields.add(attr))\n            # Register validation callback\n            obs.on_change(lambda v: self._validate_field(attr, v))\n            # Undo tracking is now handled by UndoableObservable\n\n            # Initial value tracking is now handled by UndoableObservable\n\n            # Now enable callbacks for future changes\n            obs.enable()\n        else:\n            # Get the existing observable\n            obs = self._scalars[key]\n\n        return self._scalars[key]\n\n    @override\n    def observable_list(\n        self,\n        typ: type[TValue],\n        attr: str,\n        *,\n        sync: bool | None = None,\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; IObservableList[TValue]:\n        \"\"\"\n        Get or create an ObservableList[T] for a list field.\n\n        Args:\n            typ: The type of the list elements.\n            attr: The field name.\n            sync: Whether to sync changes back to the model immediately.\n            undo_max: Maximum number of undo steps to store. None means use the default.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n        \"\"\"\n        sync = self._sync_default if sync is None else sync\n        key = ProxyFieldKey(attr, sync)\n\n        # Set up undo config if provided\n        if undo_max is not None or undo_debounce_ms is not None:\n            self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n        if key not in self._lists:\n            val_raw = getattr(self._obj, attr)\n            val: list[T] = cast(list[T], val_raw)\n            obs = ObservableList(val, copy=not sync)\n            if sync:\n                obs.on_change(lambda _: setattr(self._obj, attr, obs.copy()))\n            # Register dirty tracking callback\n            obs.on_change(lambda _: self._dirty_fields.add(attr))\n            # Register validation callback\n            obs.on_change(lambda _: self._validate_field(attr, obs.copy()))\n            # Register undo tracking callback\n            obs.on_change(lambda c: self._track_list_change(attr, c))\n            self._lists[key] = obs\n\n        return self._lists[key]\n\n    @override\n    def observable_dict(\n        self,\n        typ: tuple[type[TDictKey], type[TDictValue]],\n        attr: str,\n        *,\n        sync: bool | None = None,\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; IObservableDict[TDictKey, TDictValue]:\n        \"\"\"\n        Get or create an ObservableDict for a dict field.\n\n        Args:\n            typ: A tuple of (key_type, value_type).\n            attr: The field name.\n            sync: Whether to sync changes back to the model immediately.\n            undo_max: Maximum number of undo steps to store. None means use the default.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n        \"\"\"\n        sync = self._sync_default if sync is None else sync\n        key = ProxyFieldKey(attr, sync)\n\n        # Set up undo config if provided\n        if undo_max is not None or undo_debounce_ms is not None:\n            self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n        if key not in self._dicts:\n            val_raw = getattr(self._obj, attr)\n            val: dict[Any, Any] = cast(dict[Any, Any], val_raw)\n            obs = ObservableDict(val, copy=not sync)\n            if sync:\n                obs.on_change(lambda _: setattr(self._obj, attr, obs.copy()))\n            # Register dirty tracking callback\n            obs.on_change(lambda _: self._dirty_fields.add(attr))\n            # Register validation callback\n            obs.on_change(lambda _: self._validate_field(attr, obs.copy()))\n            # Register undo tracking callback\n            obs.on_change(lambda c: self._track_dict_change(attr, c))\n            self._dicts[key] = obs\n\n        return self._dicts[key]\n\n    @override\n    def get(self) -&gt; T:\n        \"\"\"\n        Get the original object being proxied.\n        \"\"\"\n        return self._obj\n\n    @override\n    def update(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Set one or more scalar observable values.\n        \"\"\"\n        for attr, value in kwargs.items():\n            self.observable(object, attr).set(value)\n\n    @override\n    def load_dict(self, values: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Set multiple scalar observable values from a dict.\n        \"\"\"\n        for attr, value in values.items():\n            self.observable(object, attr).set(value)\n\n    @override\n    def save_to(self, obj: T) -&gt; None:\n        \"\"\"\n        Write all observable values back into the given object.\n        \"\"\"\n        for key, obs in self._scalars.items():\n            setattr(obj, key.attr, obs.get())\n\n        for key, obs in self._lists.items():\n            setattr(obj, key.attr, obs.copy())\n\n        for key, obs in self._dicts.items():\n            setattr(obj, key.attr, obs.copy())\n\n        # Save computed fields that shadow real fields\n        for name, obs in self._computeds.items():\n            try:\n                # Check if the target object has this field\n                getattr(obj, name)\n                # If we get here, the field exists, so save the computed value\n                setattr(obj, name, obs.get())\n            except (AttributeError, TypeError):\n                # Field doesn't exist in the target object, skip it\n                pass\n\n        # Reset dirty state after saving\n        self.reset_dirty()\n\n    @override\n    def is_dirty(self) -&gt; bool:\n        \"\"\"\n        Check if any fields have been modified since initialization or last reset.\n\n        Returns:\n            True if any fields have been modified, False otherwise.\n        \"\"\"\n        return bool(self._dirty_fields)\n\n    @override\n    def dirty_fields(self) -&gt; set[str]:\n        \"\"\"\n        Get the set of field names that have been modified.\n\n        Returns:\n            A set of field names that have been modified.\n        \"\"\"\n        return set(self._dirty_fields)\n\n    @override\n    def reset_dirty(self) -&gt; None:\n        \"\"\"\n        Reset the dirty state of all fields.\n        \"\"\"\n        self._dirty_fields.clear()\n\n    @override\n    def register_computed(\n        self,\n        name: str,\n        compute: Callable[[], TValue],\n        dependencies: list[str],\n    ) -&gt; None:\n        \"\"\"\n        Register a computed property that depends on other observables.\n\n        Args:\n            name: The name of the computed property.\n            compute: A function that returns the computed value.\n            dependencies: List of field names that this computed property depends on.\n        \"\"\"\n        # Create an observable for the computed property\n        initial_value = compute()\n        obs = Observable(initial_value)\n        self._computeds[name] = obs\n\n        # Register callbacks for each dependency\n        for dep in dependencies:\n            # For scalar dependencies\n            def update_computed(_: Any) -&gt; None:\n                new_value = compute()\n                current = obs.get()\n                if new_value != current:\n                    obs.set(new_value)\n\n            # Try to find the dependency in scalars, lists, or dicts\n            for sync in [True, False]:\n                key = ProxyFieldKey(dep, sync)\n\n                if key in self._scalars:\n                    self._scalars[key].on_change(update_computed)\n                    break\n\n                if key in self._lists:\n                    self._lists[key].on_change(update_computed)\n                    break\n\n                if key in self._dicts:\n                    self._dicts[key].on_change(update_computed)\n                    break\n\n            # Check if the dependency is another computed property\n            if dep in self._computeds:\n                self._computeds[dep].on_change(update_computed)\n\n        # Validate the computed property when it changes\n        def validate_computed(_: Any) -&gt; None:\n            value = compute()\n            self._validate_field(name, value)\n\n        obs.on_change(validate_computed)\n\n    @override\n    def computed(\n        self,\n        typ: type[TValue],\n        name: str,\n    ) -&gt; IObservable[TValue]:\n        \"\"\"\n        Get a computed property by name.\n\n        Args:\n            typ: The type of the computed property.\n            name: The name of the computed property.\n\n        Returns:\n            An observable containing the computed value.\n        \"\"\"\n        if name not in self._computeds:\n            raise KeyError(f\"Computed property '{name}' not found\")\n\n        return self._computeds[name]\n\n    @override\n    def add_validator(\n        self,\n        attr: str,\n        validator: Callable[[Any], str | None],\n    ) -&gt; None:\n        \"\"\"\n        Add a validator function for a field.\n\n        Args:\n            attr: The field name to validate.\n            validator: A function that takes the field value and returns an error message\n                       if invalid, or None if valid.\n        \"\"\"\n        if attr not in self._validators:\n            self._validators[attr] = []\n\n        self._validators[attr].append(validator)\n\n        # Validate the current value if it exists\n        self._validate_field_if_exists(attr)\n\n    def _validate_field_if_exists(self, attr: str) -&gt; None:\n        \"\"\"\n        Validate a field if it exists in any of the observable collections.\n        \"\"\"\n        # Check in scalars\n        for key in self._scalars:\n            if key.attr == attr:\n                value = self._scalars[key].get()\n                self._validate_field(attr, value)\n                return\n\n        # Check in lists\n        for key in self._lists:\n            if key.attr == attr:\n                value = self._lists[key].copy()\n                self._validate_field(attr, value)\n                return\n\n        # Check in dicts\n        for key in self._dicts:\n            if key.attr == attr:\n                value = self._dicts[key].copy()\n                self._validate_field(attr, value)\n                return\n\n        # If we get here, the field doesn't exist in any observable collection yet\n        # Try to get it directly from the object\n        try:\n            value = getattr(self._obj, attr)\n            self._validate_field(attr, value)\n        except (AttributeError, TypeError):\n            # If we can't get the value, we can't validate it yet\n            pass\n\n    def _validate_field(self, attr: str, value: Any) -&gt; None:\n        \"\"\"\n        Validate a field value against all its validators.\n\n        Args:\n            attr: The field name.\n            value: The value to validate.\n        \"\"\"\n        if attr not in self._validators:\n            # No validators for this field, it's always valid\n            if attr in self._validation_errors_dict:\n                del self._validation_errors_dict[attr]\n            return\n\n        errors: list[str] = []\n\n        for validator in self._validators[attr]:\n            try:\n                result = validator(value)\n                if result is not None:\n                    errors.append(result)\n            except Exception as e:\n                errors.append(f\"Validation error: {str(e)}\")\n\n        if errors:\n            self._validation_errors_dict[attr] = errors\n        elif attr in self._validation_errors_dict:\n            del self._validation_errors_dict[attr]\n\n        # Update the is_valid observable\n        self._is_valid_obs.set(len(self._validation_errors_dict) == 0)\n\n    @override\n    def is_valid(self) -&gt; IObservable[bool]:\n        \"\"\"\n        Get an observable that indicates whether all fields are valid.\n\n        Returns:\n            An observable that emits True if all fields are valid, False otherwise.\n        \"\"\"\n        return self._is_valid_obs\n\n    @override\n    def validation_errors(self) -&gt; IObservableDict[str, list[str]]:\n        \"\"\"\n        Get an observable dictionary of validation errors.\n\n        Returns:\n            An observable dictionary mapping field names to lists of error messages.\n        \"\"\"\n        return self._validation_errors_dict\n\n    @override\n    def validation_for(self, attr: str) -&gt; IObservable[list[str]]:\n        \"\"\"\n        Get an observable list of validation errors for a specific field.\n\n        Args:\n            attr: The field name to get validation errors for.\n\n        Returns:\n            An observable that emits a list of error messages for the field.\n            An empty list means the field is valid.\n        \"\"\"\n        if attr not in self._validation_for_cache:\n            # Create a computed observable that depends on the validation errors dict\n            initial_value = self._validation_errors_dict.get(attr) or []\n            obs = Observable[list[str]](initial_value)\n\n            # Update the observable when the validation errors dict changes\n            def update_validation(_: Any) -&gt; None:\n                new_value = self._validation_errors_dict.get(attr) or []\n                current = obs.get()\n                if new_value != current:\n                    obs.set(new_value)\n\n            self._validation_errors_dict.on_change(update_validation)\n            self._validation_for_cache[attr] = obs\n\n        return self._validation_for_cache[attr]\n\n    @override\n    def reset_validation(self, attr: str | None = None, *, revalidate: bool = False) -&gt; None:\n        \"\"\"\n        Reset validation errors for a specific field or all fields.\n\n        Args:\n            attr: The field name to reset validation for. If None, reset all fields.\n            revalidate: Whether to re-run validators after clearing errors.\n        \"\"\"\n        if attr is None:\n            # Reset all validation errors\n            self._validation_errors_dict.clear()\n            # Update the is_valid observable\n            self._is_valid_obs.set(True)\n\n            # Re-run all validators if requested\n            if revalidate:\n                for field_name in self._validators.keys():\n                    self._validate_field_if_exists(field_name)\n        else:\n            # Reset validation errors for a specific field\n            if attr in self._validation_errors_dict:\n                del self._validation_errors_dict[attr]\n                # Update the is_valid observable\n                self._is_valid_obs.set(len(self._validation_errors_dict) == 0)\n\n            # Re-run validator for this field if requested\n            if revalidate:\n                self._validate_field_if_exists(attr)\n\n    @override\n    def set_undo_config(\n        self,\n        attr: str,\n        *,\n        enabled: bool | None = None,\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Set the undo configuration for a specific field.\n\n        Args:\n            attr: The field name to configure.\n            enabled: Whether undo/redo functionality is enabled for this field.\n            undo_max: Maximum number of undo steps to store. None means unlimited.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n        \"\"\"\n        # Get the current config or create a new one\n        config = self._field_undo_configs.get(attr, UndoConfig())\n\n        # Update the config with the provided values\n        if enabled is not None:\n            config.enabled = enabled\n        elif attr not in self._field_undo_configs:\n            # If this is a new config and enabled wasn't specified, inherit from default\n            config.enabled = self._default_undo_config.enabled\n\n        if undo_max is not None:\n            config.undo_max = undo_max\n        if undo_debounce_ms is not None:\n            config.undo_debounce_ms = undo_debounce_ms\n\n        # Store the updated config\n        self._field_undo_configs[attr] = config\n\n        # Enforce the max size if it's been reduced\n        if attr in self._undo_stacks and config.undo_max is not None:\n            while len(self._undo_stacks[attr]) &gt; config.undo_max:\n                self._undo_stacks[attr].pop(0)\n\n    def _get_undo_config(self, attr: str) -&gt; UndoConfig:\n        \"\"\"\n        Get the undo configuration for a field.\n\n        Args:\n            attr: The field name.\n\n        Returns:\n            The undo configuration for the field, or the default if not set.\n        \"\"\"\n        config = self._field_undo_configs.get(attr, self._default_undo_config)\n\n        # If undo_max is None, use the default from UndoConfig\n        if config.undo_max is None:\n            from observant.types.undo_config import UndoConfig as DefaultUndoConfig\n\n            config.undo_max = DefaultUndoConfig.undo_max\n\n        # Make sure the enabled flag is set correctly\n        # If this is a field-specific config, check if it has an explicit enabled flag\n        if attr in self._field_undo_configs:\n            # If the field has a specific config but no explicit enabled flag,\n            # inherit from the default config\n            if not hasattr(config, \"enabled\"):\n                config.enabled = self._default_undo_config.enabled\n\n        return config\n\n    # _track_scalar_change has been removed - UndoableObservable now handles this\n\n    def _track_list_change(self, attr: str, change: Any) -&gt; None:\n        \"\"\"\n        Track a change to a list field for undo/redo.\n\n        Args:\n            attr: The field name.\n            change: The change object.\n        \"\"\"\n        # Get the observable for this field\n        obs = None\n        for key, o in self._lists.items():\n            if key.attr == attr:\n                obs = o\n                break\n\n        if obs is None:\n            return  # Field not found\n\n        # Create a flag to prevent recursive tracking\n        tracking_enabled = [True]\n\n        # We don't need a tracking function here since it's already registered\n        # when the observable_list is created\n\n        # We don't need to add a new tracking callback here\n        # The callback is already registered when the observable_list is created\n\n        # Helper function to temporarily disable tracking\n        def with_tracking_disabled(action: Callable[[], None]) -&gt; None:\n            print(f\"DEBUG: with_tracking_disabled - Disabling tracking for {attr}\")\n            # Disable tracking during this operation\n            tracking_enabled[0] = False\n            # Perform the action\n            print(\"DEBUG: with_tracking_disabled - Executing action\")\n            action()\n            print(\"DEBUG: with_tracking_disabled - Action executed\")\n            # Re-enable tracking\n            tracking_enabled[0] = True\n            print(f\"DEBUG: with_tracking_disabled - Tracking re-enabled for {attr}\")\n\n        # Create undo/redo functions based on the change type\n        if hasattr(change, \"type\") and change.type == ObservableCollectionChangeType.CLEAR:\n            # This is a clear operation\n            old_items = change.items\n\n            def undo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs.extend(old_items)\n\n                with_tracking_disabled(action)\n\n            def redo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs.clear()\n\n                with_tracking_disabled(action)\n\n        elif hasattr(change, \"index\") and hasattr(change, \"item\"):\n            # This could be an append/insert or a remove operation\n            index = change.index\n            item = change.item\n\n            if change.type == ObservableCollectionChangeType.ADD:\n                # This is an append or insert\n                def undo_func() -&gt; None:\n                    def action() -&gt; None:\n                        if index is not None and index &lt; len(obs):  # Check if index is valid\n                            obs.pop(index)\n\n                    with_tracking_disabled(action)\n\n                def redo_func() -&gt; None:\n                    def action() -&gt; None:\n                        if index is not None:\n                            obs.insert(index, item)\n                        else:\n                            obs.append(item)\n\n                    with_tracking_disabled(action)\n            else:\n                # This is a remove operation\n                def undo_func() -&gt; None:\n                    def action() -&gt; None:\n                        if index is not None:\n                            obs.insert(index, item)\n                        else:\n                            obs.append(item)\n\n                    with_tracking_disabled(action)\n\n                def redo_func() -&gt; None:\n                    def action() -&gt; None:\n                        if index is not None and index &lt; len(obs):  # Check if index is valid\n                            obs.pop(index)\n\n                    with_tracking_disabled(action)\n\n        else:\n            # Unknown change type\n            return\n\n        # Add to the undo stack\n        self._add_to_undo_stack(attr, undo_func, redo_func, from_undo=True)\n\n    def _track_dict_change(self, attr: str, change: Any) -&gt; None:\n        \"\"\"\n        Track a change to a dict field for undo/redo.\n\n        Args:\n            attr: The field name.\n            change: The change object.\n        \"\"\"\n        # Get the observable for this field\n        obs = None\n        for key, o in self._dicts.items():\n            if key.attr == attr:\n                obs = o\n                break\n\n        if obs is None:\n            return  # Field not found\n\n        # Create a flag to prevent recursive tracking\n        tracking_enabled = [True]\n\n        # We don't need a tracking function here since it's already registered\n        # when the observable_dict is created\n\n        # We don't need to add a new tracking callback here\n        # The callback is already registered when the observable_dict is created\n\n        # Helper function to temporarily disable tracking\n        def with_tracking_disabled(action: Callable[[], None]) -&gt; None:\n            print(f\"DEBUG: dict with_tracking_disabled - Disabling tracking for {attr}\")\n            # Disable tracking during this operation\n            tracking_enabled[0] = False\n            # Perform the action\n            print(\"DEBUG: dict with_tracking_disabled - Executing action\")\n            action()\n            print(\"DEBUG: dict with_tracking_disabled - Action executed\")\n            # Re-enable tracking\n            tracking_enabled[0] = True\n            print(f\"DEBUG: dict with_tracking_disabled - Tracking re-enabled for {attr}\")\n\n        # Create undo/redo functions based on the change type\n        if hasattr(change, \"key\") and hasattr(change, \"value\") and hasattr(change, \"old_value\"):\n            # This is a key update\n            dict_key = change.key\n            value = change.value\n            old_value = change.old_value\n\n            def undo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs[dict_key] = old_value\n\n                with_tracking_disabled(action)\n\n            def redo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs[dict_key] = value\n\n                with_tracking_disabled(action)\n\n        elif hasattr(change, \"key\") and hasattr(change, \"value\") and not hasattr(change, \"old_value\"):\n            # This is a new key\n            dict_key = change.key\n            value = change.value\n\n            def undo_func() -&gt; None:\n                def action() -&gt; None:\n                    if dict_key in obs:  # Check if key exists\n                        del obs[dict_key]\n\n                with_tracking_disabled(action)\n\n            def redo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs[dict_key] = value\n\n                with_tracking_disabled(action)\n\n        elif hasattr(change, \"key\") and hasattr(change, \"value\") and change.type == ObservableCollectionChangeType.REMOVE:\n            # This is a key deletion\n            dict_key = change.key\n            old_value = change.value\n\n            print(f\"DEBUG: _track_dict_change - Creating undo/redo functions for key deletion: {dict_key}={old_value}\")\n\n            def undo_func() -&gt; None:\n                print(f\"DEBUG: dict undo_func - Starting undo for key {dict_key}\")\n                print(f\"DEBUG: dict undo_func - Observable dict: {obs}\")\n                print(f\"DEBUG: dict undo_func - Observable dict keys: {list(obs.keys())}\")\n                print(f\"DEBUG: dict undo_func - Setting key {dict_key} to value {old_value}\")\n\n                # Directly set the key in the dictionary\n                obs[dict_key] = old_value\n\n                print(f\"DEBUG: dict undo_func - After restore, keys: {list(obs.keys())}\")\n                print(f\"DEBUG: dict undo_func - Completed undo for key {dict_key}\")\n\n            def redo_func() -&gt; None:\n                print(f\"DEBUG: dict redo_func - Starting redo for key {dict_key}\")\n                print(f\"DEBUG: dict redo_func - Observable dict: {obs}\")\n                print(f\"DEBUG: dict redo_func - Observable dict keys: {list(obs.keys())}\")\n                print(f\"DEBUG: dict redo_func - Deleting key {dict_key}\")\n\n                # Directly delete the key without using the action function\n                if dict_key in obs:  # Check if key exists\n                    del obs[dict_key]\n\n                print(f\"DEBUG: dict redo_func - After delete, keys: {list(obs.keys())}\")\n                print(f\"DEBUG: dict redo_func - Completed redo for key {dict_key}\")\n\n        elif hasattr(change, \"old_items\"):\n            # This is a clear\n            old_items = change.old_items\n\n            def undo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs.update(old_items)\n\n                with_tracking_disabled(action)\n\n            def redo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs.clear()\n\n                with_tracking_disabled(action)\n\n        else:\n            # Unknown change type\n            return\n\n        # Add to the undo stack\n        self._add_to_undo_stack(attr, undo_func, redo_func, from_undo=True)\n\n    def _add_to_undo_stack(self, attr: str, undo_func: Callable[[], None], redo_func: Callable[[], None], from_undo: bool = False) -&gt; None:\n        \"\"\"\n        Add an undo/redo pair to the undo stack for a field.\n\n        Args:\n            attr: The field name.\n            undo_func: The function to call to undo the change.\n            redo_func: The function to call to redo the change.\n            from_undo: Whether this is being called from the undo method.\n        \"\"\"\n        print(f\"DEBUG: _add_to_undo_stack called for {attr}, from_undo={from_undo}\")\n\n        # Initialize stacks if they don't exist\n        if attr not in self._undo_stacks:\n            self._undo_stacks[attr] = []\n            print(f\"DEBUG: _add_to_undo_stack - Initialized undo stack for {attr}\")\n        if attr not in self._redo_stacks:\n            self._redo_stacks[attr] = []\n            print(f\"DEBUG: _add_to_undo_stack - Initialized redo stack for {attr}\")\n\n        # Get the undo config for this field\n        config = self._get_undo_config(attr)\n        print(f\"DEBUG: _add_to_undo_stack - Got undo config for {attr}: undo_max={config.undo_max}, undo_debounce_ms={config.undo_debounce_ms}\")\n\n        # Check if we should debounce this change\n        now = time.monotonic() * 1000  # Convert to milliseconds\n        last_change_time = self._last_change_times.get(attr, 0)\n        debounce_window = config.undo_debounce_ms\n        time_since_last_change = now - last_change_time\n\n        print(f\"DEBUG: _add_to_undo_stack - now={now}, last_change_time={last_change_time}, time_since_last_change={time_since_last_change}ms, debounce_window={debounce_window}ms\")\n        print(f\"DEBUG: _add_to_undo_stack - pending_undo_groups for {attr}: {attr in self._pending_undo_groups}\")\n        if attr in self._pending_undo_groups:\n            print(f\"DEBUG: _add_to_undo_stack - pending_undo_groups[{attr}] is None: {self._pending_undo_groups[attr] is None}\")\n\n        if debounce_window is not None and attr in self._pending_undo_groups and self._pending_undo_groups[attr] is not None and time_since_last_change &lt; debounce_window:\n            # We're within the debounce window, update the pending group\n            # The pending group is the redo function from the previous change\n            # We replace it with the new redo function\n            print(f\"DEBUG: _add_to_undo_stack - Within debounce window, updating pending group for {attr}\")\n            self._pending_undo_groups[attr] = redo_func\n        else:\n            # We're outside the debounce window or there's no pending group\n            print(f\"DEBUG: _add_to_undo_stack - Outside debounce window or no pending group for {attr}\")\n\n            # Clear the redo stack when a new change is made, but not if we're undoing\n            if not from_undo:\n                self._redo_stacks[attr].clear()\n                print(f\"DEBUG: _add_to_undo_stack - Cleared redo stack for {attr}\")\n\n            # Add the undo function to the stack\n            self._undo_stacks[attr].append(undo_func)\n            print(f\"DEBUG: _add_to_undo_stack - Added undo function to stack for {attr}, stack size: {len(self._undo_stacks[attr])}\")\n\n            # Enforce the max size\n            if config.undo_max is not None:\n                while len(self._undo_stacks[attr]) &gt; config.undo_max:\n                    self._undo_stacks[attr].pop(0)\n                    print(f\"DEBUG: _add_to_undo_stack - Enforced max size for {attr}, removed oldest undo function\")\n\n            # Set the pending group\n            self._pending_undo_groups[attr] = redo_func\n            print(f\"DEBUG: _add_to_undo_stack - Set pending group for {attr}\")\n\n        # Update the last change time\n        self._last_change_times[attr] = now\n        print(f\"DEBUG: _add_to_undo_stack - Updated last change time for {attr} to {now}\")\n        print(f\"DEBUG: _add_to_undo_stack - Completed for {attr}\")\n\n    @override\n    def undo(self, attr: str) -&gt; None:\n        \"\"\"\n        Undo the most recent change to a field.\n\n        Args:\n            attr: The field name to undo changes for.\n        \"\"\"\n        print(f\"DEBUG: undo called for {attr}\")\n\n        if attr not in self._undo_stacks or not self._undo_stacks[attr]:\n            print(f\"DEBUG: undo - Nothing to undo for {attr}\")\n            return  # Nothing to undo\n\n        # Pop the most recent undo function\n        undo_func = self._undo_stacks[attr].pop()\n        print(f\"DEBUG: undo - Popped undo function from stack for {attr}, remaining: {len(self._undo_stacks[attr])}\")\n\n        # Get the pending redo function\n        redo_func = self._pending_undo_groups.get(attr)\n        print(f\"DEBUG: undo - Got pending redo function for {attr}: {redo_func is not None}\")\n\n        # Add to the redo stack if it exists\n        if redo_func is not None:\n            self._redo_stacks[attr].append(redo_func)\n            print(f\"DEBUG: undo - Added redo function to stack for {attr}\")\n            self._pending_undo_groups[attr] = None\n            print(f\"DEBUG: undo - Cleared pending undo group for {attr}\")\n\n        # Find the observable for this field to set the undoing flag\n        obs = None\n        for key, o in self._scalars.items():\n            if key.attr == attr:\n                obs = o\n                break\n\n        # Execute the undo function with undoing flag set\n        print(f\"DEBUG: undo - Executing undo function for {attr}\")\n        print(f\"DEBUG: undo - undo_func: {undo_func}\")\n\n        # Set the undoing flag if we found the observable and it's a UndoableObservable\n        from observant.undoable_observable import UndoableObservable\n\n        if obs is not None and isinstance(obs, UndoableObservable):\n            obs.set_undoing(True)\n\n        try:\n            undo_func()\n        finally:\n            # Reset the undoing flag\n            if obs is not None and isinstance(obs, UndoableObservable):\n                obs.set_undoing(False)\n\n        print(f\"DEBUG: undo - Completed for {attr}\")\n\n        # If sync is enabled for this field, update the model\n        for key in self._scalars:\n            if key.attr == attr and key.sync:\n                value = self._scalars[key].get()\n                setattr(self._obj, attr, value)\n                print(f\"DEBUG: undo - Synced {attr} to model with value {value}\")\n                break\n\n    @override\n    def redo(self, attr: str) -&gt; None:\n        \"\"\"\n        Redo the most recently undone change to a field.\n\n        Args:\n            attr: The field name to redo changes for.\n        \"\"\"\n        print(f\"DEBUG: redo called for {attr}\")\n        if attr not in self._redo_stacks or not self._redo_stacks[attr]:\n            print(f\"DEBUG: redo - Nothing to redo for {attr}\")\n            return  # Nothing to redo\n\n        # Pop the most recent redo function\n        redo_func = self._redo_stacks[attr].pop()\n        print(f\"DEBUG: redo - Popped redo function from stack for {attr}, remaining: {len(self._redo_stacks[attr])}\")\n\n        # Get the undo function that will undo this redo operation\n        # This is the function that was popped from the undo stack when undo was called\n        undo_func = None\n        if attr in self._pending_undo_groups:\n            undo_func = self._pending_undo_groups[attr]\n            print(f\"DEBUG: redo - Got pending undo function for {attr}: {undo_func is not None}\")\n\n        # Find the observable for this field to manually track changes\n        # We need to do this because the redo function disables tracking\n        obs_list = None\n        obs_dict = None\n\n        # Check if this is a list field\n        for key, o in self._lists.items():\n            if key.attr == attr:\n                obs_list = o\n                print(f\"DEBUG: redo - Found list observable for {attr}\")\n                break\n\n        # Check if this is a dict field\n        if obs_list is None:\n            for key, o in self._dicts.items():\n                if key.attr == attr:\n                    obs_dict = o\n                    print(f\"DEBUG: redo - Found dict observable for {attr}\")\n                    break\n\n        # We don't need to simulate change objects anymore\n\n        # Find the scalar observable for this field to set the undoing flag\n        obs_scalar = None\n        for key, o in self._scalars.items():\n            if key.attr == attr:\n                obs_scalar = o\n                break\n\n        # Execute the redo function with undoing flag set\n        print(f\"DEBUG: redo - Executing redo function for {attr}\")\n\n        # Set the undoing flag if we found the observable and it's a UndoableObservable\n        from observant.undoable_observable import UndoableObservable\n\n        if obs_scalar is not None and isinstance(obs_scalar, UndoableObservable):\n            obs_scalar.set_undoing(True)\n\n        try:\n            redo_func()\n        finally:\n            # Reset the undoing flag\n            if obs_scalar is not None and isinstance(obs_scalar, UndoableObservable):\n                obs_scalar.set_undoing(False)\n\n        print(f\"DEBUG: redo - Redo function executed for {attr}\")\n\n        # Add the undo function back to the undo stack\n        # This is necessary because the redo function disables tracking\n        if undo_func is not None:\n            self._undo_stacks.setdefault(attr, []).append(undo_func)\n            print(f\"DEBUG: redo - Added undo function back to stack for {attr}, stack size: {len(self._undo_stacks[attr])}\")\n            # Clear the pending undo group since we've used it\n            self._pending_undo_groups[attr] = None\n            print(f\"DEBUG: redo - Cleared pending undo group for {attr}\")\n        else:\n            # If we don't have an undo function from the pending group,\n            # we need to create one based on the current state\n            print(\"DEBUG: redo - No pending undo function, creating one\")\n\n            # For scalar fields\n            for key, o in self._scalars.items():\n                if key.attr == attr:\n                    # Create an undo function that will restore the current value\n                    current_value = o.get()\n\n                    def new_undo_func() -&gt; None:\n                        print(f\"DEBUG: new_undo_func called for {attr}\")\n                        o.set(current_value, notify=False)\n                        print(f\"DEBUG: new_undo_func completed for {attr}\")\n\n                    # Add it to the undo stack\n                    self._undo_stacks.setdefault(attr, []).append(new_undo_func)\n                    print(f\"DEBUG: redo - Created and added new undo function for scalar {attr}\")\n                    break\n\n            # For list fields\n            if obs_list is not None:\n                # Create an undo function that will restore the current list state\n                current_list = obs_list.copy()\n\n                def new_list_undo_func() -&gt; None:\n                    print(f\"DEBUG: new_list_undo_func called for {attr}\")\n                    # Clear the list and add all items back\n                    obs_list.clear()\n                    obs_list.extend(current_list)\n                    print(f\"DEBUG: new_list_undo_func completed for {attr}\")\n\n                # Add it to the undo stack\n                self._undo_stacks.setdefault(attr, []).append(new_list_undo_func)\n                print(f\"DEBUG: redo - Created and added new undo function for list {attr}\")\n\n            # For dict fields\n            if obs_dict is not None:\n                # Create an undo function that will restore the current dict state\n                current_dict = obs_dict.copy()\n\n                def new_dict_undo_func() -&gt; None:\n                    print(f\"DEBUG: new_dict_undo_func called for {attr}\")\n                    # Clear the dict and add all items back\n                    obs_dict.clear()\n                    obs_dict.update(current_dict)\n                    print(f\"DEBUG: new_dict_undo_func completed for {attr}\")\n\n                # Add it to the undo stack\n                self._undo_stacks.setdefault(attr, []).append(new_dict_undo_func)\n                print(f\"DEBUG: redo - Created and added new undo function for dict {attr}\")\n\n        print(f\"DEBUG: redo - Completed for {attr}\")\n\n        # If sync is enabled for this field, update the model\n        for key in self._scalars:\n            if key.attr == attr and key.sync:\n                value = self._scalars[key].get()\n                setattr(self._obj, attr, value)\n                print(f\"DEBUG: redo - Synced {attr} to model with value {value}\")\n                break\n\n    @override\n    def can_undo(self, attr: str) -&gt; bool:\n        \"\"\"\n        Check if there are changes that can be undone for a field.\n\n        Args:\n            attr: The field name to check.\n\n        Returns:\n            True if there are changes that can be undone, False otherwise.\n        \"\"\"\n        return attr in self._undo_stacks and bool(self._undo_stacks[attr])\n\n    @override\n    def can_redo(self, attr: str) -&gt; bool:\n        \"\"\"\n        Check if there are changes that can be redone for a field.\n\n        Args:\n            attr: The field name to check.\n\n        Returns:\n            True if there are changes that can be redone, False otherwise.\n        \"\"\"\n        return attr in self._redo_stacks and bool(self._redo_stacks[attr])\n\n    @override\n    def track_scalar_change(self, attr: str, old_value: Any, new_value: Any) -&gt; None:\n        \"\"\"\n        Track a scalar change for undo/redo functionality.\n\n        Args:\n            attr: The field name that changed.\n            old_value: The old value before the change.\n            new_value: The new value after the change.\n        \"\"\"\n        print(f\"DEBUG: track_scalar_change called for {attr} with old={old_value}, new={new_value}\")\n        if old_value == new_value:\n            print(\"DEBUG: values are the same, skipping\")\n            return\n\n        # Check if undo is enabled for this field\n        config = self._get_undo_config(attr)\n        if not config.enabled:\n            print(f\"DEBUG: undo is disabled for {attr}, skipping\")\n            return\n\n        # Get the observable for this field\n        obs = None\n        for key, o in self._scalars.items():\n            if key.attr == attr:\n                obs = o\n                break\n\n        if obs is None:\n            print(f\"DEBUG: track_scalar_change - Field {attr} not found\")\n            return  # Field not found\n\n        # Create undo/redo functions\n        def undo_func() -&gt; None:\n            print(f\"DEBUG: undo_func called for {attr}, setting value to {old_value}\")\n            # Set the old value with triggering callbacks to ensure computed properties update\n            obs.set(old_value)\n\n            # If we're undoing to the original value, clear the dirty state\n            if old_value == self._initial_values.get(attr):\n                self._dirty_fields.discard(attr)\n\n            print(f\"DEBUG: undo_func completed for {attr}\")\n\n        def redo_func() -&gt; None:\n            print(f\"DEBUG: redo_func called for {attr}, setting value to {new_value}\")\n            # Set the new value with triggering callbacks to ensure computed properties update\n            obs.set(new_value)\n\n            # If we're redoing to a non-original value, mark as dirty\n            if new_value != self._initial_values.get(attr):\n                self._dirty_fields.add(attr)\n\n            print(f\"DEBUG: redo_func completed for {attr}\")\n\n        # Add to the undo stack\n        print(f\"DEBUG: track_scalar_change - Calling _add_to_undo_stack for {attr}\")\n        self._add_to_undo_stack(attr, undo_func, redo_func)\n        print(f\"DEBUG: track_scalar_change - Completed for {attr}\")\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.__init__","title":"<code>__init__(obj, *, sync=False, undo=False, undo_max=None, undo_debounce_ms=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>obj</code> <code>T</code> <p>The object to proxy.</p> required <code>sync</code> <code>bool</code> <p>If True, observables will sync back to the model immediately. If False, changes must be saved explicitly.</p> <code>False</code> <code>undo</code> <code>bool</code> <p>If True, enables undo/redo functionality for all fields.</p> <code>False</code> <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means unlimited.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means no debouncing.</p> <code>None</code> Source code in <code>observant\\observable_proxy.py</code> <pre><code>def __init__(\n    self,\n    obj: T,\n    *,\n    sync: bool = False,\n    undo: bool = False,  # Undo is disabled by default\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Args:\n        obj: The object to proxy.\n        sync: If True, observables will sync back to the model immediately. If False, changes must be saved explicitly.\n        undo: If True, enables undo/redo functionality for all fields.\n        undo_max: Maximum number of undo steps to store. None means unlimited.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n    \"\"\"\n    self._obj = obj\n    self._sync_default = sync\n\n    # Print a warning if sync and undo are both enabled\n    if sync and undo:\n        print(\"Warning: sync=True with undo=True may cause unexpected model mutations during undo/redo.\")\n\n    self._scalars: dict[ProxyFieldKey, Observable[Any]] = {}\n    self._lists: dict[ProxyFieldKey, ObservableList[Any]] = {}\n    self._dicts: dict[ProxyFieldKey, ObservableDict[Any, Any]] = {}\n    self._computeds: dict[str, Observable[Any]] = {}\n    self._dirty_fields: set[str] = set()\n\n    # Validation related fields\n    self._validators: dict[str, list[Callable[[Any], str | None]]] = {}\n    self._validation_errors_dict = ObservableDict[str, list[str]]({})\n    self._validation_for_cache: dict[str, Observable[list[str]]] = {}\n    self._is_valid_obs = Observable[bool](True)\n\n    # Undo/redo related fields\n    self._default_undo_config = UndoConfig(enabled=undo, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n    self._field_undo_configs: dict[str, UndoConfig] = {}\n    self._undo_stacks: dict[str, list[Callable[[], None]]] = {}\n    self._redo_stacks: dict[str, list[Callable[[], None]]] = {}\n    self._last_change_times: dict[str, float] = {}\n    self._pending_undo_groups: dict[str, Callable[[], None] | None] = {}\n    self._initial_values: dict[str, Any] = {}  # Store initial values for undo\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.add_validator","title":"<code>add_validator(attr, validator)</code>","text":"<p>Add a validator function for a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to validate.</p> required <code>validator</code> <code>Callable[[Any], str | None]</code> <p>A function that takes the field value and returns an error message        if invalid, or None if valid.</p> required Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef add_validator(\n    self,\n    attr: str,\n    validator: Callable[[Any], str | None],\n) -&gt; None:\n    \"\"\"\n    Add a validator function for a field.\n\n    Args:\n        attr: The field name to validate.\n        validator: A function that takes the field value and returns an error message\n                   if invalid, or None if valid.\n    \"\"\"\n    if attr not in self._validators:\n        self._validators[attr] = []\n\n    self._validators[attr].append(validator)\n\n    # Validate the current value if it exists\n    self._validate_field_if_exists(attr)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.can_redo","title":"<code>can_redo(attr)</code>","text":"<p>Check if there are changes that can be redone for a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there are changes that can be redone, False otherwise.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef can_redo(self, attr: str) -&gt; bool:\n    \"\"\"\n    Check if there are changes that can be redone for a field.\n\n    Args:\n        attr: The field name to check.\n\n    Returns:\n        True if there are changes that can be redone, False otherwise.\n    \"\"\"\n    return attr in self._redo_stacks and bool(self._redo_stacks[attr])\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.can_undo","title":"<code>can_undo(attr)</code>","text":"<p>Check if there are changes that can be undone for a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there are changes that can be undone, False otherwise.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef can_undo(self, attr: str) -&gt; bool:\n    \"\"\"\n    Check if there are changes that can be undone for a field.\n\n    Args:\n        attr: The field name to check.\n\n    Returns:\n        True if there are changes that can be undone, False otherwise.\n    \"\"\"\n    return attr in self._undo_stacks and bool(self._undo_stacks[attr])\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.computed","title":"<code>computed(typ, name)</code>","text":"<p>Get a computed property by name.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>type[TValue]</code> <p>The type of the computed property.</p> required <code>name</code> <code>str</code> <p>The name of the computed property.</p> required <p>Returns:</p> Type Description <code>IObservable[TValue]</code> <p>An observable containing the computed value.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef computed(\n    self,\n    typ: type[TValue],\n    name: str,\n) -&gt; IObservable[TValue]:\n    \"\"\"\n    Get a computed property by name.\n\n    Args:\n        typ: The type of the computed property.\n        name: The name of the computed property.\n\n    Returns:\n        An observable containing the computed value.\n    \"\"\"\n    if name not in self._computeds:\n        raise KeyError(f\"Computed property '{name}' not found\")\n\n    return self._computeds[name]\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.dirty_fields","title":"<code>dirty_fields()</code>","text":"<p>Get the set of field names that have been modified.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of field names that have been modified.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef dirty_fields(self) -&gt; set[str]:\n    \"\"\"\n    Get the set of field names that have been modified.\n\n    Returns:\n        A set of field names that have been modified.\n    \"\"\"\n    return set(self._dirty_fields)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.get","title":"<code>get()</code>","text":"<p>Get the original object being proxied.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef get(self) -&gt; T:\n    \"\"\"\n    Get the original object being proxied.\n    \"\"\"\n    return self._obj\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.is_dirty","title":"<code>is_dirty()</code>","text":"<p>Check if any fields have been modified since initialization or last reset.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if any fields have been modified, False otherwise.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef is_dirty(self) -&gt; bool:\n    \"\"\"\n    Check if any fields have been modified since initialization or last reset.\n\n    Returns:\n        True if any fields have been modified, False otherwise.\n    \"\"\"\n    return bool(self._dirty_fields)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.is_valid","title":"<code>is_valid()</code>","text":"<p>Get an observable that indicates whether all fields are valid.</p> <p>Returns:</p> Type Description <code>IObservable[bool]</code> <p>An observable that emits True if all fields are valid, False otherwise.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef is_valid(self) -&gt; IObservable[bool]:\n    \"\"\"\n    Get an observable that indicates whether all fields are valid.\n\n    Returns:\n        An observable that emits True if all fields are valid, False otherwise.\n    \"\"\"\n    return self._is_valid_obs\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.load_dict","title":"<code>load_dict(values)</code>","text":"<p>Set multiple scalar observable values from a dict.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef load_dict(self, values: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Set multiple scalar observable values from a dict.\n    \"\"\"\n    for attr, value in values.items():\n        self.observable(object, attr).set(value)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.observable","title":"<code>observable(typ, attr, *, sync=None, undo_max=None, undo_debounce_ms=None)</code>","text":"<p>Get or create an Observable[T] for a scalar field.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>type[TValue]</code> <p>The type of the field.</p> required <code>attr</code> <code>str</code> <p>The field name.</p> required <code>sync</code> <code>bool | None</code> <p>Whether to sync changes back to the model immediately.</p> <code>None</code> <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means use the default.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means use the default.</p> <code>None</code> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef observable(\n    self,\n    typ: type[TValue],\n    attr: str,\n    *,\n    sync: bool | None = None,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; IObservable[TValue]:\n    \"\"\"\n    Get or create an Observable[T] for a scalar field.\n\n    Args:\n        typ: The type of the field.\n        attr: The field name.\n        sync: Whether to sync changes back to the model immediately.\n        undo_max: Maximum number of undo steps to store. None means use the default.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n    \"\"\"\n    sync = self._sync_default if sync is None else sync\n    key = ProxyFieldKey(attr, sync)\n\n    # Set up undo config if provided\n    if undo_max is not None or undo_debounce_ms is not None:\n        self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n    # Get the initial value\n    val = getattr(self._obj, attr)\n\n    if key not in self._scalars:\n        # Create observable with callbacks disabled to prevent premature tracking\n        # obs = Observable(val, on_change_enabled=False)\n        obs = UndoableObservable(val, attr, self, on_change_enabled=False)\n\n        # Store the observable first so it can be found by _track_scalar_change\n        self._scalars[key] = obs\n\n        if sync:\n            obs.on_change(lambda v: setattr(self._obj, attr, v))\n        # Register dirty tracking callback\n        obs.on_change(lambda _: self._dirty_fields.add(attr))\n        # Register validation callback\n        obs.on_change(lambda v: self._validate_field(attr, v))\n        # Undo tracking is now handled by UndoableObservable\n\n        # Initial value tracking is now handled by UndoableObservable\n\n        # Now enable callbacks for future changes\n        obs.enable()\n    else:\n        # Get the existing observable\n        obs = self._scalars[key]\n\n    return self._scalars[key]\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.observable_dict","title":"<code>observable_dict(typ, attr, *, sync=None, undo_max=None, undo_debounce_ms=None)</code>","text":"<p>Get or create an ObservableDict for a dict field.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>tuple[type[TDictKey], type[TDictValue]]</code> <p>A tuple of (key_type, value_type).</p> required <code>attr</code> <code>str</code> <p>The field name.</p> required <code>sync</code> <code>bool | None</code> <p>Whether to sync changes back to the model immediately.</p> <code>None</code> <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means use the default.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means use the default.</p> <code>None</code> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef observable_dict(\n    self,\n    typ: tuple[type[TDictKey], type[TDictValue]],\n    attr: str,\n    *,\n    sync: bool | None = None,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; IObservableDict[TDictKey, TDictValue]:\n    \"\"\"\n    Get or create an ObservableDict for a dict field.\n\n    Args:\n        typ: A tuple of (key_type, value_type).\n        attr: The field name.\n        sync: Whether to sync changes back to the model immediately.\n        undo_max: Maximum number of undo steps to store. None means use the default.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n    \"\"\"\n    sync = self._sync_default if sync is None else sync\n    key = ProxyFieldKey(attr, sync)\n\n    # Set up undo config if provided\n    if undo_max is not None or undo_debounce_ms is not None:\n        self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n    if key not in self._dicts:\n        val_raw = getattr(self._obj, attr)\n        val: dict[Any, Any] = cast(dict[Any, Any], val_raw)\n        obs = ObservableDict(val, copy=not sync)\n        if sync:\n            obs.on_change(lambda _: setattr(self._obj, attr, obs.copy()))\n        # Register dirty tracking callback\n        obs.on_change(lambda _: self._dirty_fields.add(attr))\n        # Register validation callback\n        obs.on_change(lambda _: self._validate_field(attr, obs.copy()))\n        # Register undo tracking callback\n        obs.on_change(lambda c: self._track_dict_change(attr, c))\n        self._dicts[key] = obs\n\n    return self._dicts[key]\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.observable_list","title":"<code>observable_list(typ, attr, *, sync=None, undo_max=None, undo_debounce_ms=None)</code>","text":"<p>Get or create an ObservableList[T] for a list field.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>type[TValue]</code> <p>The type of the list elements.</p> required <code>attr</code> <code>str</code> <p>The field name.</p> required <code>sync</code> <code>bool | None</code> <p>Whether to sync changes back to the model immediately.</p> <code>None</code> <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means use the default.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means use the default.</p> <code>None</code> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef observable_list(\n    self,\n    typ: type[TValue],\n    attr: str,\n    *,\n    sync: bool | None = None,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; IObservableList[TValue]:\n    \"\"\"\n    Get or create an ObservableList[T] for a list field.\n\n    Args:\n        typ: The type of the list elements.\n        attr: The field name.\n        sync: Whether to sync changes back to the model immediately.\n        undo_max: Maximum number of undo steps to store. None means use the default.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n    \"\"\"\n    sync = self._sync_default if sync is None else sync\n    key = ProxyFieldKey(attr, sync)\n\n    # Set up undo config if provided\n    if undo_max is not None or undo_debounce_ms is not None:\n        self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n    if key not in self._lists:\n        val_raw = getattr(self._obj, attr)\n        val: list[T] = cast(list[T], val_raw)\n        obs = ObservableList(val, copy=not sync)\n        if sync:\n            obs.on_change(lambda _: setattr(self._obj, attr, obs.copy()))\n        # Register dirty tracking callback\n        obs.on_change(lambda _: self._dirty_fields.add(attr))\n        # Register validation callback\n        obs.on_change(lambda _: self._validate_field(attr, obs.copy()))\n        # Register undo tracking callback\n        obs.on_change(lambda c: self._track_list_change(attr, c))\n        self._lists[key] = obs\n\n    return self._lists[key]\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.redo","title":"<code>redo(attr)</code>","text":"<p>Redo the most recently undone change to a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to redo changes for.</p> required Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef redo(self, attr: str) -&gt; None:\n    \"\"\"\n    Redo the most recently undone change to a field.\n\n    Args:\n        attr: The field name to redo changes for.\n    \"\"\"\n    print(f\"DEBUG: redo called for {attr}\")\n    if attr not in self._redo_stacks or not self._redo_stacks[attr]:\n        print(f\"DEBUG: redo - Nothing to redo for {attr}\")\n        return  # Nothing to redo\n\n    # Pop the most recent redo function\n    redo_func = self._redo_stacks[attr].pop()\n    print(f\"DEBUG: redo - Popped redo function from stack for {attr}, remaining: {len(self._redo_stacks[attr])}\")\n\n    # Get the undo function that will undo this redo operation\n    # This is the function that was popped from the undo stack when undo was called\n    undo_func = None\n    if attr in self._pending_undo_groups:\n        undo_func = self._pending_undo_groups[attr]\n        print(f\"DEBUG: redo - Got pending undo function for {attr}: {undo_func is not None}\")\n\n    # Find the observable for this field to manually track changes\n    # We need to do this because the redo function disables tracking\n    obs_list = None\n    obs_dict = None\n\n    # Check if this is a list field\n    for key, o in self._lists.items():\n        if key.attr == attr:\n            obs_list = o\n            print(f\"DEBUG: redo - Found list observable for {attr}\")\n            break\n\n    # Check if this is a dict field\n    if obs_list is None:\n        for key, o in self._dicts.items():\n            if key.attr == attr:\n                obs_dict = o\n                print(f\"DEBUG: redo - Found dict observable for {attr}\")\n                break\n\n    # We don't need to simulate change objects anymore\n\n    # Find the scalar observable for this field to set the undoing flag\n    obs_scalar = None\n    for key, o in self._scalars.items():\n        if key.attr == attr:\n            obs_scalar = o\n            break\n\n    # Execute the redo function with undoing flag set\n    print(f\"DEBUG: redo - Executing redo function for {attr}\")\n\n    # Set the undoing flag if we found the observable and it's a UndoableObservable\n    from observant.undoable_observable import UndoableObservable\n\n    if obs_scalar is not None and isinstance(obs_scalar, UndoableObservable):\n        obs_scalar.set_undoing(True)\n\n    try:\n        redo_func()\n    finally:\n        # Reset the undoing flag\n        if obs_scalar is not None and isinstance(obs_scalar, UndoableObservable):\n            obs_scalar.set_undoing(False)\n\n    print(f\"DEBUG: redo - Redo function executed for {attr}\")\n\n    # Add the undo function back to the undo stack\n    # This is necessary because the redo function disables tracking\n    if undo_func is not None:\n        self._undo_stacks.setdefault(attr, []).append(undo_func)\n        print(f\"DEBUG: redo - Added undo function back to stack for {attr}, stack size: {len(self._undo_stacks[attr])}\")\n        # Clear the pending undo group since we've used it\n        self._pending_undo_groups[attr] = None\n        print(f\"DEBUG: redo - Cleared pending undo group for {attr}\")\n    else:\n        # If we don't have an undo function from the pending group,\n        # we need to create one based on the current state\n        print(\"DEBUG: redo - No pending undo function, creating one\")\n\n        # For scalar fields\n        for key, o in self._scalars.items():\n            if key.attr == attr:\n                # Create an undo function that will restore the current value\n                current_value = o.get()\n\n                def new_undo_func() -&gt; None:\n                    print(f\"DEBUG: new_undo_func called for {attr}\")\n                    o.set(current_value, notify=False)\n                    print(f\"DEBUG: new_undo_func completed for {attr}\")\n\n                # Add it to the undo stack\n                self._undo_stacks.setdefault(attr, []).append(new_undo_func)\n                print(f\"DEBUG: redo - Created and added new undo function for scalar {attr}\")\n                break\n\n        # For list fields\n        if obs_list is not None:\n            # Create an undo function that will restore the current list state\n            current_list = obs_list.copy()\n\n            def new_list_undo_func() -&gt; None:\n                print(f\"DEBUG: new_list_undo_func called for {attr}\")\n                # Clear the list and add all items back\n                obs_list.clear()\n                obs_list.extend(current_list)\n                print(f\"DEBUG: new_list_undo_func completed for {attr}\")\n\n            # Add it to the undo stack\n            self._undo_stacks.setdefault(attr, []).append(new_list_undo_func)\n            print(f\"DEBUG: redo - Created and added new undo function for list {attr}\")\n\n        # For dict fields\n        if obs_dict is not None:\n            # Create an undo function that will restore the current dict state\n            current_dict = obs_dict.copy()\n\n            def new_dict_undo_func() -&gt; None:\n                print(f\"DEBUG: new_dict_undo_func called for {attr}\")\n                # Clear the dict and add all items back\n                obs_dict.clear()\n                obs_dict.update(current_dict)\n                print(f\"DEBUG: new_dict_undo_func completed for {attr}\")\n\n            # Add it to the undo stack\n            self._undo_stacks.setdefault(attr, []).append(new_dict_undo_func)\n            print(f\"DEBUG: redo - Created and added new undo function for dict {attr}\")\n\n    print(f\"DEBUG: redo - Completed for {attr}\")\n\n    # If sync is enabled for this field, update the model\n    for key in self._scalars:\n        if key.attr == attr and key.sync:\n            value = self._scalars[key].get()\n            setattr(self._obj, attr, value)\n            print(f\"DEBUG: redo - Synced {attr} to model with value {value}\")\n            break\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.register_computed","title":"<code>register_computed(name, compute, dependencies)</code>","text":"<p>Register a computed property that depends on other observables.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the computed property.</p> required <code>compute</code> <code>Callable[[], TValue]</code> <p>A function that returns the computed value.</p> required <code>dependencies</code> <code>list[str]</code> <p>List of field names that this computed property depends on.</p> required Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef register_computed(\n    self,\n    name: str,\n    compute: Callable[[], TValue],\n    dependencies: list[str],\n) -&gt; None:\n    \"\"\"\n    Register a computed property that depends on other observables.\n\n    Args:\n        name: The name of the computed property.\n        compute: A function that returns the computed value.\n        dependencies: List of field names that this computed property depends on.\n    \"\"\"\n    # Create an observable for the computed property\n    initial_value = compute()\n    obs = Observable(initial_value)\n    self._computeds[name] = obs\n\n    # Register callbacks for each dependency\n    for dep in dependencies:\n        # For scalar dependencies\n        def update_computed(_: Any) -&gt; None:\n            new_value = compute()\n            current = obs.get()\n            if new_value != current:\n                obs.set(new_value)\n\n        # Try to find the dependency in scalars, lists, or dicts\n        for sync in [True, False]:\n            key = ProxyFieldKey(dep, sync)\n\n            if key in self._scalars:\n                self._scalars[key].on_change(update_computed)\n                break\n\n            if key in self._lists:\n                self._lists[key].on_change(update_computed)\n                break\n\n            if key in self._dicts:\n                self._dicts[key].on_change(update_computed)\n                break\n\n        # Check if the dependency is another computed property\n        if dep in self._computeds:\n            self._computeds[dep].on_change(update_computed)\n\n    # Validate the computed property when it changes\n    def validate_computed(_: Any) -&gt; None:\n        value = compute()\n        self._validate_field(name, value)\n\n    obs.on_change(validate_computed)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.reset_dirty","title":"<code>reset_dirty()</code>","text":"<p>Reset the dirty state of all fields.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef reset_dirty(self) -&gt; None:\n    \"\"\"\n    Reset the dirty state of all fields.\n    \"\"\"\n    self._dirty_fields.clear()\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.reset_validation","title":"<code>reset_validation(attr=None, *, revalidate=False)</code>","text":"<p>Reset validation errors for a specific field or all fields.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str | None</code> <p>The field name to reset validation for. If None, reset all fields.</p> <code>None</code> <code>revalidate</code> <code>bool</code> <p>Whether to re-run validators after clearing errors.</p> <code>False</code> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef reset_validation(self, attr: str | None = None, *, revalidate: bool = False) -&gt; None:\n    \"\"\"\n    Reset validation errors for a specific field or all fields.\n\n    Args:\n        attr: The field name to reset validation for. If None, reset all fields.\n        revalidate: Whether to re-run validators after clearing errors.\n    \"\"\"\n    if attr is None:\n        # Reset all validation errors\n        self._validation_errors_dict.clear()\n        # Update the is_valid observable\n        self._is_valid_obs.set(True)\n\n        # Re-run all validators if requested\n        if revalidate:\n            for field_name in self._validators.keys():\n                self._validate_field_if_exists(field_name)\n    else:\n        # Reset validation errors for a specific field\n        if attr in self._validation_errors_dict:\n            del self._validation_errors_dict[attr]\n            # Update the is_valid observable\n            self._is_valid_obs.set(len(self._validation_errors_dict) == 0)\n\n        # Re-run validator for this field if requested\n        if revalidate:\n            self._validate_field_if_exists(attr)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.save_to","title":"<code>save_to(obj)</code>","text":"<p>Write all observable values back into the given object.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef save_to(self, obj: T) -&gt; None:\n    \"\"\"\n    Write all observable values back into the given object.\n    \"\"\"\n    for key, obs in self._scalars.items():\n        setattr(obj, key.attr, obs.get())\n\n    for key, obs in self._lists.items():\n        setattr(obj, key.attr, obs.copy())\n\n    for key, obs in self._dicts.items():\n        setattr(obj, key.attr, obs.copy())\n\n    # Save computed fields that shadow real fields\n    for name, obs in self._computeds.items():\n        try:\n            # Check if the target object has this field\n            getattr(obj, name)\n            # If we get here, the field exists, so save the computed value\n            setattr(obj, name, obs.get())\n        except (AttributeError, TypeError):\n            # Field doesn't exist in the target object, skip it\n            pass\n\n    # Reset dirty state after saving\n    self.reset_dirty()\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.set_undo_config","title":"<code>set_undo_config(attr, *, enabled=None, undo_max=None, undo_debounce_ms=None)</code>","text":"<p>Set the undo configuration for a specific field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to configure.</p> required <code>enabled</code> <code>bool | None</code> <p>Whether undo/redo functionality is enabled for this field.</p> <code>None</code> <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means unlimited.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means no debouncing.</p> <code>None</code> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef set_undo_config(\n    self,\n    attr: str,\n    *,\n    enabled: bool | None = None,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Set the undo configuration for a specific field.\n\n    Args:\n        attr: The field name to configure.\n        enabled: Whether undo/redo functionality is enabled for this field.\n        undo_max: Maximum number of undo steps to store. None means unlimited.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n    \"\"\"\n    # Get the current config or create a new one\n    config = self._field_undo_configs.get(attr, UndoConfig())\n\n    # Update the config with the provided values\n    if enabled is not None:\n        config.enabled = enabled\n    elif attr not in self._field_undo_configs:\n        # If this is a new config and enabled wasn't specified, inherit from default\n        config.enabled = self._default_undo_config.enabled\n\n    if undo_max is not None:\n        config.undo_max = undo_max\n    if undo_debounce_ms is not None:\n        config.undo_debounce_ms = undo_debounce_ms\n\n    # Store the updated config\n    self._field_undo_configs[attr] = config\n\n    # Enforce the max size if it's been reduced\n    if attr in self._undo_stacks and config.undo_max is not None:\n        while len(self._undo_stacks[attr]) &gt; config.undo_max:\n            self._undo_stacks[attr].pop(0)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.track_scalar_change","title":"<code>track_scalar_change(attr, old_value, new_value)</code>","text":"<p>Track a scalar change for undo/redo functionality.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name that changed.</p> required <code>old_value</code> <code>Any</code> <p>The old value before the change.</p> required <code>new_value</code> <code>Any</code> <p>The new value after the change.</p> required Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef track_scalar_change(self, attr: str, old_value: Any, new_value: Any) -&gt; None:\n    \"\"\"\n    Track a scalar change for undo/redo functionality.\n\n    Args:\n        attr: The field name that changed.\n        old_value: The old value before the change.\n        new_value: The new value after the change.\n    \"\"\"\n    print(f\"DEBUG: track_scalar_change called for {attr} with old={old_value}, new={new_value}\")\n    if old_value == new_value:\n        print(\"DEBUG: values are the same, skipping\")\n        return\n\n    # Check if undo is enabled for this field\n    config = self._get_undo_config(attr)\n    if not config.enabled:\n        print(f\"DEBUG: undo is disabled for {attr}, skipping\")\n        return\n\n    # Get the observable for this field\n    obs = None\n    for key, o in self._scalars.items():\n        if key.attr == attr:\n            obs = o\n            break\n\n    if obs is None:\n        print(f\"DEBUG: track_scalar_change - Field {attr} not found\")\n        return  # Field not found\n\n    # Create undo/redo functions\n    def undo_func() -&gt; None:\n        print(f\"DEBUG: undo_func called for {attr}, setting value to {old_value}\")\n        # Set the old value with triggering callbacks to ensure computed properties update\n        obs.set(old_value)\n\n        # If we're undoing to the original value, clear the dirty state\n        if old_value == self._initial_values.get(attr):\n            self._dirty_fields.discard(attr)\n\n        print(f\"DEBUG: undo_func completed for {attr}\")\n\n    def redo_func() -&gt; None:\n        print(f\"DEBUG: redo_func called for {attr}, setting value to {new_value}\")\n        # Set the new value with triggering callbacks to ensure computed properties update\n        obs.set(new_value)\n\n        # If we're redoing to a non-original value, mark as dirty\n        if new_value != self._initial_values.get(attr):\n            self._dirty_fields.add(attr)\n\n        print(f\"DEBUG: redo_func completed for {attr}\")\n\n    # Add to the undo stack\n    print(f\"DEBUG: track_scalar_change - Calling _add_to_undo_stack for {attr}\")\n    self._add_to_undo_stack(attr, undo_func, redo_func)\n    print(f\"DEBUG: track_scalar_change - Completed for {attr}\")\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.undo","title":"<code>undo(attr)</code>","text":"<p>Undo the most recent change to a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to undo changes for.</p> required Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef undo(self, attr: str) -&gt; None:\n    \"\"\"\n    Undo the most recent change to a field.\n\n    Args:\n        attr: The field name to undo changes for.\n    \"\"\"\n    print(f\"DEBUG: undo called for {attr}\")\n\n    if attr not in self._undo_stacks or not self._undo_stacks[attr]:\n        print(f\"DEBUG: undo - Nothing to undo for {attr}\")\n        return  # Nothing to undo\n\n    # Pop the most recent undo function\n    undo_func = self._undo_stacks[attr].pop()\n    print(f\"DEBUG: undo - Popped undo function from stack for {attr}, remaining: {len(self._undo_stacks[attr])}\")\n\n    # Get the pending redo function\n    redo_func = self._pending_undo_groups.get(attr)\n    print(f\"DEBUG: undo - Got pending redo function for {attr}: {redo_func is not None}\")\n\n    # Add to the redo stack if it exists\n    if redo_func is not None:\n        self._redo_stacks[attr].append(redo_func)\n        print(f\"DEBUG: undo - Added redo function to stack for {attr}\")\n        self._pending_undo_groups[attr] = None\n        print(f\"DEBUG: undo - Cleared pending undo group for {attr}\")\n\n    # Find the observable for this field to set the undoing flag\n    obs = None\n    for key, o in self._scalars.items():\n        if key.attr == attr:\n            obs = o\n            break\n\n    # Execute the undo function with undoing flag set\n    print(f\"DEBUG: undo - Executing undo function for {attr}\")\n    print(f\"DEBUG: undo - undo_func: {undo_func}\")\n\n    # Set the undoing flag if we found the observable and it's a UndoableObservable\n    from observant.undoable_observable import UndoableObservable\n\n    if obs is not None and isinstance(obs, UndoableObservable):\n        obs.set_undoing(True)\n\n    try:\n        undo_func()\n    finally:\n        # Reset the undoing flag\n        if obs is not None and isinstance(obs, UndoableObservable):\n            obs.set_undoing(False)\n\n    print(f\"DEBUG: undo - Completed for {attr}\")\n\n    # If sync is enabled for this field, update the model\n    for key in self._scalars:\n        if key.attr == attr and key.sync:\n            value = self._scalars[key].get()\n            setattr(self._obj, attr, value)\n            print(f\"DEBUG: undo - Synced {attr} to model with value {value}\")\n            break\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.update","title":"<code>update(**kwargs)</code>","text":"<p>Set one or more scalar observable values.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef update(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Set one or more scalar observable values.\n    \"\"\"\n    for attr, value in kwargs.items():\n        self.observable(object, attr).set(value)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.validation_errors","title":"<code>validation_errors()</code>","text":"<p>Get an observable dictionary of validation errors.</p> <p>Returns:</p> Type Description <code>IObservableDict[str, list[str]]</code> <p>An observable dictionary mapping field names to lists of error messages.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef validation_errors(self) -&gt; IObservableDict[str, list[str]]:\n    \"\"\"\n    Get an observable dictionary of validation errors.\n\n    Returns:\n        An observable dictionary mapping field names to lists of error messages.\n    \"\"\"\n    return self._validation_errors_dict\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.validation_for","title":"<code>validation_for(attr)</code>","text":"<p>Get an observable list of validation errors for a specific field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to get validation errors for.</p> required <p>Returns:</p> Type Description <code>IObservable[list[str]]</code> <p>An observable that emits a list of error messages for the field.</p> <code>IObservable[list[str]]</code> <p>An empty list means the field is valid.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef validation_for(self, attr: str) -&gt; IObservable[list[str]]:\n    \"\"\"\n    Get an observable list of validation errors for a specific field.\n\n    Args:\n        attr: The field name to get validation errors for.\n\n    Returns:\n        An observable that emits a list of error messages for the field.\n        An empty list means the field is valid.\n    \"\"\"\n    if attr not in self._validation_for_cache:\n        # Create a computed observable that depends on the validation errors dict\n        initial_value = self._validation_errors_dict.get(attr) or []\n        obs = Observable[list[str]](initial_value)\n\n        # Update the observable when the validation errors dict changes\n        def update_validation(_: Any) -&gt; None:\n            new_value = self._validation_errors_dict.get(attr) or []\n            current = obs.get()\n            if new_value != current:\n                obs.set(new_value)\n\n        self._validation_errors_dict.on_change(update_validation)\n        self._validation_for_cache[attr] = obs\n\n    return self._validation_for_cache[attr]\n</code></pre>"},{"location":"api_reference/undoable_observable/","title":"UndoableObservable","text":""},{"location":"api_reference/undoable_observable/#observant.undoable_observable.UndoableObservable","title":"<code>observant.undoable_observable.UndoableObservable</code>","text":"<p>               Bases: <code>Observable[T]</code>, <code>Generic[T]</code></p> Source code in <code>observant\\undoable_observable.py</code> <pre><code>class UndoableObservable(Observable[T], Generic[T]):\n    def __init__(self, value: T, attr: str, proxy: IObservableProxy[TValue], *, on_change_enabled: bool = True) -&gt; None:\n        super().__init__(value, on_change_enabled=on_change_enabled)\n        self._attr = attr\n        self._proxy = proxy\n        self._is_undoing = False  # Flag to prevent recursive tracking during undo/redo\n\n    @override\n    def set(self, value: T, notify: bool = True) -&gt; None:\n        old_value = self.get()\n\n        # Only track changes if not already undoing and notify is True\n        if old_value != value and notify and not self._is_undoing:\n            self._proxy.track_scalar_change(self._attr, old_value, value)\n\n        super().set(value, notify=notify)\n\n    def set_undoing(self, is_undoing: bool) -&gt; None:\n        \"\"\"Set the undoing flag to prevent recursive tracking during undo/redo.\"\"\"\n        self._is_undoing = is_undoing\n</code></pre>"},{"location":"api_reference/undoable_observable/#observant.undoable_observable.UndoableObservable.set_undoing","title":"<code>set_undoing(is_undoing)</code>","text":"<p>Set the undoing flag to prevent recursive tracking during undo/redo.</p> Source code in <code>observant\\undoable_observable.py</code> <pre><code>def set_undoing(self, is_undoing: bool) -&gt; None:\n    \"\"\"Set the undoing flag to prevent recursive tracking during undo/redo.\"\"\"\n    self._is_undoing = is_undoing\n</code></pre>"},{"location":"api_reference/interfaces/","title":"Interfaces","text":"<p>This section provides API reference for all interfaces in Observant.py.</p> <ul> <li>IObservable</li> <li>IObservableList</li> <li>IObservableDict</li> <li>IObservableProxy</li> </ul>"},{"location":"api_reference/interfaces/iobservable/","title":"IObservable","text":""},{"location":"api_reference/interfaces/iobservable/#observant.interfaces.observable.IObservable","title":"<code>observant.interfaces.observable.IObservable</code>","text":"<p>               Bases: <code>Generic[T]</code></p> Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>class IObservable(Generic[T]):\n    def get(self) -&gt; T:\n        \"\"\"\n        Get the current value of the observable.\n\n        Returns:\n            The current value.\n        \"\"\"\n        ...\n\n    def set(self, value: T, notify: bool = True) -&gt; None:\n        \"\"\"\n        Set a new value for the observable and notify all registered callbacks.\n\n        Args:\n            value: The new value to set.\n            notify: Whether to notify the callbacks after setting the value.\n        \"\"\"\n        ...\n\n    def on_change(self, callback: Callable[[T], None]) -&gt; None:\n        \"\"\"\n        Register a callback function to be called when the value changes.\n\n        Args:\n            callback: A function that takes the new value as its argument.\n        \"\"\"\n        ...\n\n    def enable(self) -&gt; None:\n        \"\"\"\n        Enable the observable to notify changes.\n        \"\"\"\n        ...\n\n    def disable(self) -&gt; None:\n        \"\"\"\n        Disable the observable from notifying changes.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable/#observant.interfaces.observable.IObservable.disable","title":"<code>disable()</code>","text":"<p>Disable the observable from notifying changes.</p> Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>def disable(self) -&gt; None:\n    \"\"\"\n    Disable the observable from notifying changes.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable/#observant.interfaces.observable.IObservable.enable","title":"<code>enable()</code>","text":"<p>Enable the observable to notify changes.</p> Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>def enable(self) -&gt; None:\n    \"\"\"\n    Enable the observable to notify changes.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable/#observant.interfaces.observable.IObservable.get","title":"<code>get()</code>","text":"<p>Get the current value of the observable.</p> <p>Returns:</p> Type Description <code>T</code> <p>The current value.</p> Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>def get(self) -&gt; T:\n    \"\"\"\n    Get the current value of the observable.\n\n    Returns:\n        The current value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable/#observant.interfaces.observable.IObservable.on_change","title":"<code>on_change(callback)</code>","text":"<p>Register a callback function to be called when the value changes.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[T], None]</code> <p>A function that takes the new value as its argument.</p> required Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>def on_change(self, callback: Callable[[T], None]) -&gt; None:\n    \"\"\"\n    Register a callback function to be called when the value changes.\n\n    Args:\n        callback: A function that takes the new value as its argument.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable/#observant.interfaces.observable.IObservable.set","title":"<code>set(value, notify=True)</code>","text":"<p>Set a new value for the observable and notify all registered callbacks.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The new value to set.</p> required <code>notify</code> <code>bool</code> <p>Whether to notify the callbacks after setting the value.</p> <code>True</code> Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>def set(self, value: T, notify: bool = True) -&gt; None:\n    \"\"\"\n    Set a new value for the observable and notify all registered callbacks.\n\n    Args:\n        value: The new value to set.\n        notify: Whether to notify the callbacks after setting the value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/","title":"IObservableDict","text":""},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict","title":"<code>observant.interfaces.dict.IObservableDict</code>","text":"<p>               Bases: <code>Generic[TKey, TValue]</code>, <code>ABC</code></p> <p>Interface for observable dictionaries with specific event types.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>class IObservableDict(Generic[TKey, TValue], ABC):\n    \"\"\"Interface for observable dictionaries with specific event types.\"\"\"\n\n    @abstractmethod\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of items in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def __getitem__(self, key: TKey) -&gt; TValue:\n        \"\"\"Get an item from the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def __setitem__(self, key: TKey, value: TValue) -&gt; None:\n        \"\"\"Set an item in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def __delitem__(self, key: TKey) -&gt; None:\n        \"\"\"Delete an item from the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def __iter__(self) -&gt; Iterator[TKey]:\n        \"\"\"Return an iterator over the keys in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def __contains__(self, key: TKey) -&gt; bool:\n        \"\"\"Check if a key is in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def get(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"Return the value for a key if it exists, otherwise return a default value.\"\"\"\n        ...\n\n    @abstractmethod\n    def setdefault(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"Return the value for a key if it exists, otherwise set and return the default value.\"\"\"\n        ...\n\n    @abstractmethod\n    def pop(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"Remove and return the value for a key if it exists, otherwise return a default value.\"\"\"\n        ...\n\n    @abstractmethod\n    def popitem(self) -&gt; tuple[TKey, TValue]:\n        \"\"\"Remove and return a (key, value) pair from the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def clear(self) -&gt; None:\n        \"\"\"Remove all items from the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def update(self, other: dict[TKey, TValue]) -&gt; None:\n        \"\"\"Update the dictionary with the key/value pairs from another dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def keys(self) -&gt; list[TKey]:\n        \"\"\"Return a list of all keys in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def values(self) -&gt; list[TValue]:\n        \"\"\"Return a list of all values in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def items(self) -&gt; list[tuple[TKey, TValue]]:\n        \"\"\"Return a list of all (key, value) pairs in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def copy(self) -&gt; dict[TKey, TValue]:\n        \"\"\"Return a shallow copy of the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_change(\n        self, callback: Callable[[ObservableDictChange[TKey, TValue]], None]\n    ) -&gt; None:\n        \"\"\"Register for all change events with detailed information.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_add(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"Register for add events with key and value.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_remove(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"Register for remove events with key and value.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_update(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"Register for update events with key and new value.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_clear(self, callback: Callable[[dict[TKey, TValue]], None]) -&gt; None:\n        \"\"\"Register for clear events with the cleared items.\"\"\"\n        ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.__contains__","title":"<code>__contains__(key)</code>  <code>abstractmethod</code>","text":"<p>Check if a key is in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __contains__(self, key: TKey) -&gt; bool:\n    \"\"\"Check if a key is in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.__delitem__","title":"<code>__delitem__(key)</code>  <code>abstractmethod</code>","text":"<p>Delete an item from the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __delitem__(self, key: TKey) -&gt; None:\n    \"\"\"Delete an item from the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.__getitem__","title":"<code>__getitem__(key)</code>  <code>abstractmethod</code>","text":"<p>Get an item from the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __getitem__(self, key: TKey) -&gt; TValue:\n    \"\"\"Get an item from the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.__iter__","title":"<code>__iter__()</code>  <code>abstractmethod</code>","text":"<p>Return an iterator over the keys in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __iter__(self) -&gt; Iterator[TKey]:\n    \"\"\"Return an iterator over the keys in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.__len__","title":"<code>__len__()</code>  <code>abstractmethod</code>","text":"<p>Return the number of items in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __len__(self) -&gt; int:\n    \"\"\"Return the number of items in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.__setitem__","title":"<code>__setitem__(key, value)</code>  <code>abstractmethod</code>","text":"<p>Set an item in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __setitem__(self, key: TKey, value: TValue) -&gt; None:\n    \"\"\"Set an item in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.clear","title":"<code>clear()</code>  <code>abstractmethod</code>","text":"<p>Remove all items from the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef clear(self) -&gt; None:\n    \"\"\"Remove all items from the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.copy","title":"<code>copy()</code>  <code>abstractmethod</code>","text":"<p>Return a shallow copy of the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef copy(self) -&gt; dict[TKey, TValue]:\n    \"\"\"Return a shallow copy of the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.get","title":"<code>get(key, default=None)</code>  <code>abstractmethod</code>","text":"<p>Return the value for a key if it exists, otherwise return a default value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef get(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"Return the value for a key if it exists, otherwise return a default value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.items","title":"<code>items()</code>  <code>abstractmethod</code>","text":"<p>Return a list of all (key, value) pairs in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef items(self) -&gt; list[tuple[TKey, TValue]]:\n    \"\"\"Return a list of all (key, value) pairs in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.keys","title":"<code>keys()</code>  <code>abstractmethod</code>","text":"<p>Return a list of all keys in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef keys(self) -&gt; list[TKey]:\n    \"\"\"Return a list of all keys in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.on_add","title":"<code>on_add(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for add events with key and value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef on_add(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"Register for add events with key and value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.on_change","title":"<code>on_change(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for all change events with detailed information.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef on_change(\n    self, callback: Callable[[ObservableDictChange[TKey, TValue]], None]\n) -&gt; None:\n    \"\"\"Register for all change events with detailed information.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.on_clear","title":"<code>on_clear(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for clear events with the cleared items.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef on_clear(self, callback: Callable[[dict[TKey, TValue]], None]) -&gt; None:\n    \"\"\"Register for clear events with the cleared items.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.on_remove","title":"<code>on_remove(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for remove events with key and value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef on_remove(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"Register for remove events with key and value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.on_update","title":"<code>on_update(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for update events with key and new value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef on_update(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"Register for update events with key and new value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.pop","title":"<code>pop(key, default=None)</code>  <code>abstractmethod</code>","text":"<p>Remove and return the value for a key if it exists, otherwise return a default value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef pop(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"Remove and return the value for a key if it exists, otherwise return a default value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.popitem","title":"<code>popitem()</code>  <code>abstractmethod</code>","text":"<p>Remove and return a (key, value) pair from the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef popitem(self) -&gt; tuple[TKey, TValue]:\n    \"\"\"Remove and return a (key, value) pair from the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.setdefault","title":"<code>setdefault(key, default=None)</code>  <code>abstractmethod</code>","text":"<p>Return the value for a key if it exists, otherwise set and return the default value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef setdefault(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"Return the value for a key if it exists, otherwise set and return the default value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.update","title":"<code>update(other)</code>  <code>abstractmethod</code>","text":"<p>Update the dictionary with the key/value pairs from another dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef update(self, other: dict[TKey, TValue]) -&gt; None:\n    \"\"\"Update the dictionary with the key/value pairs from another dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_dict/#observant.interfaces.dict.IObservableDict.values","title":"<code>values()</code>  <code>abstractmethod</code>","text":"<p>Return a list of all values in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef values(self) -&gt; list[TValue]:\n    \"\"\"Return a list of all values in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/","title":"IObservableList","text":""},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList","title":"<code>observant.interfaces.list.IObservableList</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Interface for observable lists with specific event types.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>class IObservableList(Generic[T], ABC):\n    \"\"\"Interface for observable lists with specific event types.\"\"\"\n\n    @abstractmethod\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of items in the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def __getitem__(self, index: int | slice) -&gt; T | list[T]:\n        \"\"\"Get an item or slice of items from the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def __setitem__(self, index: int | slice, value: T | list[T]) -&gt; None:\n        \"\"\"Set an item or slice of items in the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def __delitem__(self, index: int | slice) -&gt; None:\n        \"\"\"Delete an item or slice of items from the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def __iter__(self) -&gt; Iterator[T]:\n        \"\"\"Return an iterator over the items in the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def __contains__(self, item: T) -&gt; bool:\n        \"\"\"Check if an item is in the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def append(self, item: T) -&gt; None:\n        \"\"\"Add an item to the end of the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def extend(self, items: list[T]) -&gt; None:\n        \"\"\"Extend the list by appending all items from the iterable.\"\"\"\n        ...\n\n    @abstractmethod\n    def insert(self, index: int, item: T) -&gt; None:\n        \"\"\"Insert an item at a given position.\"\"\"\n        ...\n\n    @abstractmethod\n    def remove(self, item: T) -&gt; None:\n        \"\"\"Remove the first occurrence of an item from the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def pop(self, index: int = -1) -&gt; T:\n        \"\"\"Remove and return an item at a given position.\"\"\"\n        ...\n\n    @abstractmethod\n    def clear(self) -&gt; None:\n        \"\"\"Remove all items from the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def index(self, item: T, start: int = 0, end: int | None = None) -&gt; int:\n        \"\"\"Return the index of the first occurrence of an item.\"\"\"\n        ...\n\n    @abstractmethod\n    def count(self, item: T) -&gt; int:\n        \"\"\"Return the number of occurrences of an item in the list.\"\"\"\n        ...\n\n    @overload\n    def sort(self, *, key: None = None, reverse: bool = False) -&gt; None: ...\n\n    @overload\n    def sort(self, *, key: Callable[[T], Any], reverse: bool = False) -&gt; None: ...\n\n    @abstractmethod\n    def sort(\n        self,\n        *,\n        key: Callable[[T], Any] | None = None,\n        reverse: bool = False,\n    ) -&gt; None: ...\n\n    @abstractmethod\n    def reverse(self) -&gt; None:\n        \"\"\"Reverse the list in place.\"\"\"\n        ...\n\n    @abstractmethod\n    def copy(self) -&gt; list[T]:\n        \"\"\"Return a shallow copy of the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_change(self, callback: Callable[[ObservableListChange[T]], None]) -&gt; None:\n        \"\"\"Register for all change events with detailed information.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_add(self, callback: Callable[[T, int], None]) -&gt; None:\n        \"\"\"Register for add events with item and index.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_remove(self, callback: Callable[[T, int], None]) -&gt; None:\n        \"\"\"Register for remove events with item and index.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_clear(self, callback: Callable[[list[T]], None]) -&gt; None:\n        \"\"\"Register for clear events with the cleared items.\"\"\"\n        ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.__contains__","title":"<code>__contains__(item)</code>  <code>abstractmethod</code>","text":"<p>Check if an item is in the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __contains__(self, item: T) -&gt; bool:\n    \"\"\"Check if an item is in the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.__delitem__","title":"<code>__delitem__(index)</code>  <code>abstractmethod</code>","text":"<p>Delete an item or slice of items from the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __delitem__(self, index: int | slice) -&gt; None:\n    \"\"\"Delete an item or slice of items from the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.__getitem__","title":"<code>__getitem__(index)</code>  <code>abstractmethod</code>","text":"<p>Get an item or slice of items from the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __getitem__(self, index: int | slice) -&gt; T | list[T]:\n    \"\"\"Get an item or slice of items from the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.__iter__","title":"<code>__iter__()</code>  <code>abstractmethod</code>","text":"<p>Return an iterator over the items in the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __iter__(self) -&gt; Iterator[T]:\n    \"\"\"Return an iterator over the items in the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.__len__","title":"<code>__len__()</code>  <code>abstractmethod</code>","text":"<p>Return the number of items in the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __len__(self) -&gt; int:\n    \"\"\"Return the number of items in the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.__setitem__","title":"<code>__setitem__(index, value)</code>  <code>abstractmethod</code>","text":"<p>Set an item or slice of items in the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __setitem__(self, index: int | slice, value: T | list[T]) -&gt; None:\n    \"\"\"Set an item or slice of items in the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.append","title":"<code>append(item)</code>  <code>abstractmethod</code>","text":"<p>Add an item to the end of the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef append(self, item: T) -&gt; None:\n    \"\"\"Add an item to the end of the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.clear","title":"<code>clear()</code>  <code>abstractmethod</code>","text":"<p>Remove all items from the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef clear(self) -&gt; None:\n    \"\"\"Remove all items from the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.copy","title":"<code>copy()</code>  <code>abstractmethod</code>","text":"<p>Return a shallow copy of the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef copy(self) -&gt; list[T]:\n    \"\"\"Return a shallow copy of the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.count","title":"<code>count(item)</code>  <code>abstractmethod</code>","text":"<p>Return the number of occurrences of an item in the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef count(self, item: T) -&gt; int:\n    \"\"\"Return the number of occurrences of an item in the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.extend","title":"<code>extend(items)</code>  <code>abstractmethod</code>","text":"<p>Extend the list by appending all items from the iterable.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef extend(self, items: list[T]) -&gt; None:\n    \"\"\"Extend the list by appending all items from the iterable.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.index","title":"<code>index(item, start=0, end=None)</code>  <code>abstractmethod</code>","text":"<p>Return the index of the first occurrence of an item.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef index(self, item: T, start: int = 0, end: int | None = None) -&gt; int:\n    \"\"\"Return the index of the first occurrence of an item.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.insert","title":"<code>insert(index, item)</code>  <code>abstractmethod</code>","text":"<p>Insert an item at a given position.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef insert(self, index: int, item: T) -&gt; None:\n    \"\"\"Insert an item at a given position.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.on_add","title":"<code>on_add(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for add events with item and index.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef on_add(self, callback: Callable[[T, int], None]) -&gt; None:\n    \"\"\"Register for add events with item and index.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.on_change","title":"<code>on_change(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for all change events with detailed information.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef on_change(self, callback: Callable[[ObservableListChange[T]], None]) -&gt; None:\n    \"\"\"Register for all change events with detailed information.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.on_clear","title":"<code>on_clear(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for clear events with the cleared items.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef on_clear(self, callback: Callable[[list[T]], None]) -&gt; None:\n    \"\"\"Register for clear events with the cleared items.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.on_remove","title":"<code>on_remove(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for remove events with item and index.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef on_remove(self, callback: Callable[[T, int], None]) -&gt; None:\n    \"\"\"Register for remove events with item and index.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.pop","title":"<code>pop(index=-1)</code>  <code>abstractmethod</code>","text":"<p>Remove and return an item at a given position.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef pop(self, index: int = -1) -&gt; T:\n    \"\"\"Remove and return an item at a given position.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.remove","title":"<code>remove(item)</code>  <code>abstractmethod</code>","text":"<p>Remove the first occurrence of an item from the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef remove(self, item: T) -&gt; None:\n    \"\"\"Remove the first occurrence of an item from the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_list/#observant.interfaces.list.IObservableList.reverse","title":"<code>reverse()</code>  <code>abstractmethod</code>","text":"<p>Reverse the list in place.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef reverse(self) -&gt; None:\n    \"\"\"Reverse the list in place.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/","title":"IObservableProxy","text":""},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy","title":"<code>observant.interfaces.proxy.IObservableProxy</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Proxy for a data object that exposes its fields as Observable, ObservableList, or ObservableDict. Provides optional sync behavior to automatically write back to the source model.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>class IObservableProxy(Generic[T], ABC):\n    \"\"\"\n    Proxy for a data object that exposes its fields as Observable, ObservableList, or ObservableDict.\n    Provides optional sync behavior to automatically write back to the source model.\n    \"\"\"\n\n    @abstractmethod\n    def observable(\n        self,\n        typ: type[T],\n        attr: str,\n        *,\n        sync: bool | None = None,\n    ) -&gt; IObservable[T]:\n        \"\"\"\n        Get or create an Observable[T] for a scalar field.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def observable_list(\n        self,\n        typ: type[T],\n        attr: str,\n        *,\n        sync: bool | None = None,\n    ) -&gt; IObservableList[T]:\n        \"\"\"\n        Get or create an ObservableList[T] for a list field.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def observable_dict(\n        self,\n        typ: tuple[type[TKey], type[TValue]],\n        attr: str,\n        *,\n        sync: bool | None = None,\n    ) -&gt; IObservableDict[TKey, TValue]:\n        \"\"\"\n        Get or create an ObservableDict for a dict field.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get(self) -&gt; T:\n        \"\"\"\n        Get the original object being proxied.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Set one or more scalar observable values.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def load_dict(self, values: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Set multiple scalar observable values from a dict.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def save_to(self, obj: T) -&gt; None:\n        \"\"\"\n        Write all observable values back into the given object.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def is_dirty(self) -&gt; bool:\n        \"\"\"\n        Check if any fields have been modified since initialization or last reset.\n\n        Returns:\n            True if any fields have been modified, False otherwise.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def dirty_fields(self) -&gt; set[str]:\n        \"\"\"\n        Get the set of field names that have been modified.\n\n        Returns:\n            A set of field names that have been modified.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def reset_dirty(self) -&gt; None:\n        \"\"\"\n        Reset the dirty state of all fields.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def register_computed(\n        self,\n        name: str,\n        compute: Callable[[], T],\n        dependencies: list[str],\n    ) -&gt; None:\n        \"\"\"\n        Register a computed property that depends on other observables.\n\n        Args:\n            name: The name of the computed property.\n            compute: A function that returns the computed value.\n            dependencies: List of field names that this computed property depends on.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def computed(\n        self,\n        typ: type[T],\n        name: str,\n    ) -&gt; IObservable[T]:\n        \"\"\"\n        Get a computed property by name.\n\n        Args:\n            typ: The type of the computed property.\n            name: The name of the computed property.\n\n        Returns:\n            An observable containing the computed value.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def add_validator(\n        self,\n        attr: str,\n        validator: Callable[[Any], str | None],\n    ) -&gt; None:\n        \"\"\"\n        Add a validator function for a field.\n\n        Args:\n            attr: The field name to validate.\n            validator: A function that takes the field value and returns an error message\n                       if invalid, or None if valid.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def is_valid(self) -&gt; IObservable[bool]:\n        \"\"\"\n        Get an observable that indicates whether all fields are valid.\n\n        Returns:\n            An observable that emits True if all fields are valid, False otherwise.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def validation_errors(self) -&gt; IObservableDict[str, list[str]]:\n        \"\"\"\n        Get an observable dictionary of validation errors.\n\n        Returns:\n            An observable dictionary mapping field names to lists of error messages.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def validation_for(self, attr: str) -&gt; IObservable[list[str]]:\n        \"\"\"\n        Get an observable list of validation errors for a specific field.\n\n        Args:\n            attr: The field name to get validation errors for.\n\n        Returns:\n            An observable that emits a list of error messages for the field.\n            An empty list means the field is valid.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def reset_validation(self, attr: str | None = None, *, revalidate: bool = False) -&gt; None:\n        \"\"\"\n        Reset validation errors for a specific field or all fields.\n\n        Args:\n            attr: The field name to reset validation for. If None, reset all fields.\n            revalidate: Whether to re-run validators after clearing errors.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def set_undo_config(\n        self,\n        attr: str,\n        *,\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Set the undo configuration for a specific field.\n\n        Args:\n            attr: The field name to configure.\n            undo_max: Maximum number of undo steps to store. None means unlimited.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def undo(self, attr: str) -&gt; None:\n        \"\"\"\n        Undo the most recent change to a field.\n\n        Args:\n            attr: The field name to undo changes for.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def redo(self, attr: str) -&gt; None:\n        \"\"\"\n        Redo the most recently undone change to a field.\n\n        Args:\n            attr: The field name to redo changes for.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def can_undo(self, attr: str) -&gt; bool:\n        \"\"\"\n        Check if there are changes that can be undone for a field.\n\n        Args:\n            attr: The field name to check.\n\n        Returns:\n            True if there are changes that can be undone, False otherwise.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def can_redo(self, attr: str) -&gt; bool:\n        \"\"\"\n        Check if there are changes that can be redone for a field.\n\n        Args:\n            attr: The field name to check.\n\n        Returns:\n            True if there are changes that can be redone, False otherwise.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def track_scalar_change(self, attr: str, old_value: Any, new_value: Any) -&gt; None:\n        \"\"\"\n        Track a scalar change for undo/redo functionality.\n\n        Args:\n            attr: The field name that changed.\n            old_value: The old value before the change.\n            new_value: The new value after the change.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.add_validator","title":"<code>add_validator(attr, validator)</code>  <code>abstractmethod</code>","text":"<p>Add a validator function for a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to validate.</p> required <code>validator</code> <code>Callable[[Any], str | None]</code> <p>A function that takes the field value and returns an error message        if invalid, or None if valid.</p> required Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef add_validator(\n    self,\n    attr: str,\n    validator: Callable[[Any], str | None],\n) -&gt; None:\n    \"\"\"\n    Add a validator function for a field.\n\n    Args:\n        attr: The field name to validate.\n        validator: A function that takes the field value and returns an error message\n                   if invalid, or None if valid.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.can_redo","title":"<code>can_redo(attr)</code>  <code>abstractmethod</code>","text":"<p>Check if there are changes that can be redone for a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there are changes that can be redone, False otherwise.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef can_redo(self, attr: str) -&gt; bool:\n    \"\"\"\n    Check if there are changes that can be redone for a field.\n\n    Args:\n        attr: The field name to check.\n\n    Returns:\n        True if there are changes that can be redone, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.can_undo","title":"<code>can_undo(attr)</code>  <code>abstractmethod</code>","text":"<p>Check if there are changes that can be undone for a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there are changes that can be undone, False otherwise.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef can_undo(self, attr: str) -&gt; bool:\n    \"\"\"\n    Check if there are changes that can be undone for a field.\n\n    Args:\n        attr: The field name to check.\n\n    Returns:\n        True if there are changes that can be undone, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.computed","title":"<code>computed(typ, name)</code>  <code>abstractmethod</code>","text":"<p>Get a computed property by name.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>type[T]</code> <p>The type of the computed property.</p> required <code>name</code> <code>str</code> <p>The name of the computed property.</p> required <p>Returns:</p> Type Description <code>IObservable[T]</code> <p>An observable containing the computed value.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef computed(\n    self,\n    typ: type[T],\n    name: str,\n) -&gt; IObservable[T]:\n    \"\"\"\n    Get a computed property by name.\n\n    Args:\n        typ: The type of the computed property.\n        name: The name of the computed property.\n\n    Returns:\n        An observable containing the computed value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.dirty_fields","title":"<code>dirty_fields()</code>  <code>abstractmethod</code>","text":"<p>Get the set of field names that have been modified.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of field names that have been modified.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef dirty_fields(self) -&gt; set[str]:\n    \"\"\"\n    Get the set of field names that have been modified.\n\n    Returns:\n        A set of field names that have been modified.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.get","title":"<code>get()</code>  <code>abstractmethod</code>","text":"<p>Get the original object being proxied.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef get(self) -&gt; T:\n    \"\"\"\n    Get the original object being proxied.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.is_dirty","title":"<code>is_dirty()</code>  <code>abstractmethod</code>","text":"<p>Check if any fields have been modified since initialization or last reset.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if any fields have been modified, False otherwise.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef is_dirty(self) -&gt; bool:\n    \"\"\"\n    Check if any fields have been modified since initialization or last reset.\n\n    Returns:\n        True if any fields have been modified, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.is_valid","title":"<code>is_valid()</code>  <code>abstractmethod</code>","text":"<p>Get an observable that indicates whether all fields are valid.</p> <p>Returns:</p> Type Description <code>IObservable[bool]</code> <p>An observable that emits True if all fields are valid, False otherwise.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef is_valid(self) -&gt; IObservable[bool]:\n    \"\"\"\n    Get an observable that indicates whether all fields are valid.\n\n    Returns:\n        An observable that emits True if all fields are valid, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.load_dict","title":"<code>load_dict(values)</code>  <code>abstractmethod</code>","text":"<p>Set multiple scalar observable values from a dict.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef load_dict(self, values: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Set multiple scalar observable values from a dict.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.observable","title":"<code>observable(typ, attr, *, sync=None)</code>  <code>abstractmethod</code>","text":"<p>Get or create an Observable[T] for a scalar field.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef observable(\n    self,\n    typ: type[T],\n    attr: str,\n    *,\n    sync: bool | None = None,\n) -&gt; IObservable[T]:\n    \"\"\"\n    Get or create an Observable[T] for a scalar field.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.observable_dict","title":"<code>observable_dict(typ, attr, *, sync=None)</code>  <code>abstractmethod</code>","text":"<p>Get or create an ObservableDict for a dict field.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef observable_dict(\n    self,\n    typ: tuple[type[TKey], type[TValue]],\n    attr: str,\n    *,\n    sync: bool | None = None,\n) -&gt; IObservableDict[TKey, TValue]:\n    \"\"\"\n    Get or create an ObservableDict for a dict field.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.observable_list","title":"<code>observable_list(typ, attr, *, sync=None)</code>  <code>abstractmethod</code>","text":"<p>Get or create an ObservableList[T] for a list field.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef observable_list(\n    self,\n    typ: type[T],\n    attr: str,\n    *,\n    sync: bool | None = None,\n) -&gt; IObservableList[T]:\n    \"\"\"\n    Get or create an ObservableList[T] for a list field.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.redo","title":"<code>redo(attr)</code>  <code>abstractmethod</code>","text":"<p>Redo the most recently undone change to a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to redo changes for.</p> required Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef redo(self, attr: str) -&gt; None:\n    \"\"\"\n    Redo the most recently undone change to a field.\n\n    Args:\n        attr: The field name to redo changes for.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.register_computed","title":"<code>register_computed(name, compute, dependencies)</code>  <code>abstractmethod</code>","text":"<p>Register a computed property that depends on other observables.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the computed property.</p> required <code>compute</code> <code>Callable[[], T]</code> <p>A function that returns the computed value.</p> required <code>dependencies</code> <code>list[str]</code> <p>List of field names that this computed property depends on.</p> required Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef register_computed(\n    self,\n    name: str,\n    compute: Callable[[], T],\n    dependencies: list[str],\n) -&gt; None:\n    \"\"\"\n    Register a computed property that depends on other observables.\n\n    Args:\n        name: The name of the computed property.\n        compute: A function that returns the computed value.\n        dependencies: List of field names that this computed property depends on.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.reset_dirty","title":"<code>reset_dirty()</code>  <code>abstractmethod</code>","text":"<p>Reset the dirty state of all fields.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef reset_dirty(self) -&gt; None:\n    \"\"\"\n    Reset the dirty state of all fields.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.reset_validation","title":"<code>reset_validation(attr=None, *, revalidate=False)</code>  <code>abstractmethod</code>","text":"<p>Reset validation errors for a specific field or all fields.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str | None</code> <p>The field name to reset validation for. If None, reset all fields.</p> <code>None</code> <code>revalidate</code> <code>bool</code> <p>Whether to re-run validators after clearing errors.</p> <code>False</code> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef reset_validation(self, attr: str | None = None, *, revalidate: bool = False) -&gt; None:\n    \"\"\"\n    Reset validation errors for a specific field or all fields.\n\n    Args:\n        attr: The field name to reset validation for. If None, reset all fields.\n        revalidate: Whether to re-run validators after clearing errors.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.save_to","title":"<code>save_to(obj)</code>  <code>abstractmethod</code>","text":"<p>Write all observable values back into the given object.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef save_to(self, obj: T) -&gt; None:\n    \"\"\"\n    Write all observable values back into the given object.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.set_undo_config","title":"<code>set_undo_config(attr, *, undo_max=None, undo_debounce_ms=None)</code>  <code>abstractmethod</code>","text":"<p>Set the undo configuration for a specific field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to configure.</p> required <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means unlimited.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means no debouncing.</p> <code>None</code> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef set_undo_config(\n    self,\n    attr: str,\n    *,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Set the undo configuration for a specific field.\n\n    Args:\n        attr: The field name to configure.\n        undo_max: Maximum number of undo steps to store. None means unlimited.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.track_scalar_change","title":"<code>track_scalar_change(attr, old_value, new_value)</code>  <code>abstractmethod</code>","text":"<p>Track a scalar change for undo/redo functionality.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name that changed.</p> required <code>old_value</code> <code>Any</code> <p>The old value before the change.</p> required <code>new_value</code> <code>Any</code> <p>The new value after the change.</p> required Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef track_scalar_change(self, attr: str, old_value: Any, new_value: Any) -&gt; None:\n    \"\"\"\n    Track a scalar change for undo/redo functionality.\n\n    Args:\n        attr: The field name that changed.\n        old_value: The old value before the change.\n        new_value: The new value after the change.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.undo","title":"<code>undo(attr)</code>  <code>abstractmethod</code>","text":"<p>Undo the most recent change to a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to undo changes for.</p> required Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef undo(self, attr: str) -&gt; None:\n    \"\"\"\n    Undo the most recent change to a field.\n\n    Args:\n        attr: The field name to undo changes for.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.update","title":"<code>update(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Set one or more scalar observable values.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef update(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Set one or more scalar observable values.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.validation_errors","title":"<code>validation_errors()</code>  <code>abstractmethod</code>","text":"<p>Get an observable dictionary of validation errors.</p> <p>Returns:</p> Type Description <code>IObservableDict[str, list[str]]</code> <p>An observable dictionary mapping field names to lists of error messages.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef validation_errors(self) -&gt; IObservableDict[str, list[str]]:\n    \"\"\"\n    Get an observable dictionary of validation errors.\n\n    Returns:\n        An observable dictionary mapping field names to lists of error messages.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/iobservable_proxy/#observant.interfaces.proxy.IObservableProxy.validation_for","title":"<code>validation_for(attr)</code>  <code>abstractmethod</code>","text":"<p>Get an observable list of validation errors for a specific field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to get validation errors for.</p> required <p>Returns:</p> Type Description <code>IObservable[list[str]]</code> <p>An observable that emits a list of error messages for the field.</p> <code>IObservable[list[str]]</code> <p>An empty list means the field is valid.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef validation_for(self, attr: str) -&gt; IObservable[list[str]]:\n    \"\"\"\n    Get an observable list of validation errors for a specific field.\n\n    Args:\n        attr: The field name to get validation errors for.\n\n    Returns:\n        An observable that emits a list of error messages for the field.\n        An empty list means the field is valid.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/types/","title":"Types","text":"<p>This section provides API reference for all types in Observant.py.</p> <ul> <li>ObservableCollectionChangeType</li> <li>ObservableListChange</li> <li>ObservableDictChange</li> <li>ProxyFieldKey</li> <li>UndoConfig</li> </ul>"},{"location":"api_reference/types/observablecollectionchangetype/","title":"ObservableCollectionChangeType","text":""},{"location":"api_reference/types/observablecollectionchangetype/#observant.types.collection_change_type.ObservableCollectionChangeType","title":"<code>observant.types.collection_change_type.ObservableCollectionChangeType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Type of change that occurred in a collection.</p> Source code in <code>observant\\types\\collection_change_type.py</code> <pre><code>class ObservableCollectionChangeType(Enum):\n    \"\"\"Type of change that occurred in a collection.\"\"\"\n\n    ADD = auto()\n    REMOVE = auto()\n    CLEAR = auto()\n    UPDATE = auto()  # For dictionaries, when a value is updated\n</code></pre>"},{"location":"api_reference/types/observabledictchange/","title":"ObservableDictChange","text":""},{"location":"api_reference/types/observabledictchange/#observant.types.dict_change.ObservableDictChange","title":"<code>observant.types.dict_change.ObservableDictChange</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[TKey, TValue]</code></p> <p>Information about a change to an ObservableDict.</p> Source code in <code>observant\\types\\dict_change.py</code> <pre><code>@dataclass(frozen=True)\nclass ObservableDictChange(Generic[TKey, TValue]):\n    \"\"\"Information about a change to an ObservableDict.\"\"\"\n\n    type: ObservableCollectionChangeType\n    key: TKey | None = None  # Key where the change occurred, if applicable\n    value: TValue | None = (\n        None  # Value that was added, removed, or updated, if applicable\n    )\n    items: dict[TKey, TValue] | None = (\n        None  # Multiple items that were added, removed, or updated, if applicable\n    )\n</code></pre>"},{"location":"api_reference/types/observablelistchange/","title":"ObservableListChange","text":""},{"location":"api_reference/types/observablelistchange/#observant.types.list_change.ObservableListChange","title":"<code>observant.types.list_change.ObservableListChange</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Information about a change to an ObservableList.</p> Source code in <code>observant\\types\\list_change.py</code> <pre><code>@dataclass(frozen=True)\nclass ObservableListChange(Generic[T]):\n    \"\"\"Information about a change to an ObservableList.\"\"\"\n\n    type: ObservableCollectionChangeType\n    index: int | None = None  # Index where the change occurred, if applicable\n    item: T | None = None  # Item that was added or removed, if applicable\n    items: list[T] | None = None  # Multiple items that were added or removed, if applicable\n</code></pre>"},{"location":"api_reference/types/proxyfieldkey/","title":"ProxyFieldKey","text":""},{"location":"api_reference/types/proxyfieldkey/#observant.types.proxy_field_key.ProxyFieldKey","title":"<code>observant.types.proxy_field_key.ProxyFieldKey</code>  <code>dataclass</code>","text":"Source code in <code>observant\\types\\proxy_field_key.py</code> <pre><code>@dataclass(frozen=True)\nclass ProxyFieldKey:\n    attr: str\n    sync: bool\n</code></pre>"},{"location":"api_reference/types/undoconfig/","title":"UndoConfig","text":""},{"location":"api_reference/types/undoconfig/#observant.types.undo_config.UndoConfig","title":"<code>observant.types.undo_config.UndoConfig</code>  <code>dataclass</code>","text":"<p>Configuration for undo/redo behavior of an observable field.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>Whether undo/redo functionality is enabled for this field.</p> <code>undo_max</code> <code>Optional[int]</code> <p>Maximum number of undo steps to store. None means unlimited.</p> <code>undo_debounce_ms</code> <code>Optional[int]</code> <p>Time window in milliseconds to group changes. None means no debouncing.</p> Source code in <code>observant\\types\\undo_config.py</code> <pre><code>@dataclass\nclass UndoConfig:\n    \"\"\"\n    Configuration for undo/redo behavior of an observable field.\n\n    Attributes:\n        enabled: Whether undo/redo functionality is enabled for this field.\n        undo_max: Maximum number of undo steps to store. None means unlimited.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n    \"\"\"\n\n    enabled: bool = False\n    undo_max: Optional[int] = 50\n    undo_debounce_ms: Optional[int] = None\n</code></pre>"},{"location":"examples/advanced/","title":"Advanced Usage Examples","text":"<p>This page provides examples of more advanced patterns and use cases for Observant.py.</p>"},{"location":"examples/advanced/#model-view-viewmodel-mvvm-pattern","title":"Model-View-ViewModel (MVVM) Pattern","text":"<p>Using <code>ObservableProxy</code> to implement the MVVM pattern:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\n# Model\n@dataclass\nclass TodoItem:\n    id: int\n    text: str\n    completed: bool\n\n@dataclass\nclass TodoListModel:\n    items: List[TodoItem]\n    next_id: int = 1\n\n# ViewModel\nclass TodoListViewModel:\n    def __init__(self, model: TodoListModel):\n        self.model = model\n        self.proxy = ObservableProxy(model)\n\n        # Get observable list of items\n        self.items = self.proxy.observable_list(TodoItem, \"items\")\n\n        # Register computed properties\n        self.proxy.register_computed(\n            \"completed_count\",\n            lambda: sum(1 for item in self.items if item.completed),\n            [\"items\"]\n        )\n\n        self.proxy.register_computed(\n            \"active_count\",\n            lambda: len(self.items) - self.proxy.computed(int, \"completed_count\").get(),\n            [\"items\", \"completed_count\"]\n        )\n\n        self.proxy.register_computed(\n            \"all_completed\",\n            lambda: len(self.items) &gt; 0 and self.proxy.computed(int, \"completed_count\").get() == len(self.items),\n            [\"items\", \"completed_count\"]\n        )\n\n        # Filter state\n        self.filter_proxy = ObservableProxy({\"filter\": \"all\"})\n        self.filter = self.filter_proxy.observable(str, \"filter\")\n\n        # Register filtered items computed property\n        self.proxy.register_computed(\n            \"filtered_items\",\n            lambda: [\n                item for item in self.items\n                if self.filter.get() == \"all\"\n                or (self.filter.get() == \"active\" and not item.completed)\n                or (self.filter.get() == \"completed\" and item.completed)\n            ],\n            [\"items\"]\n        )\n\n        # Listen for filter changes to update filtered items\n        self.filter.on_change(lambda _: self.proxy.computed(list, \"filtered_items\").get())\n\n    def add_item(self, text: str):\n        \"\"\"Add a new todo item.\"\"\"\n        next_id = self.proxy.observable(int, \"next_id\").get()\n        self.items.append(TodoItem(id=next_id, text=text, completed=False))\n        self.proxy.observable(int, \"next_id\").set(next_id + 1)\n\n    def remove_item(self, item_id: int):\n        \"\"\"Remove a todo item by ID.\"\"\"\n        index = next((i for i, item in enumerate(self.items) if item.id == item_id), -1)\n        if index &gt;= 0:\n            self.items.pop(index)\n\n    def toggle_item(self, item_id: int):\n        \"\"\"Toggle the completed state of a todo item.\"\"\"\n        item = next((item for item in self.items if item.id == item_id), None)\n        if item:\n            item_proxy = ObservableProxy(item)\n            completed_obs = item_proxy.observable(bool, \"completed\")\n            completed_obs.set(not completed_obs.get())\n            item_proxy.save_to(item)\n\n    def clear_completed(self):\n        \"\"\"Remove all completed items.\"\"\"\n        active_items = [item for item in self.items if not item.completed]\n        self.items.clear()\n        self.items.extend(active_items)\n\n    def toggle_all(self):\n        \"\"\"Toggle the completed state of all items.\"\"\"\n        target_state = not self.proxy.computed(bool, \"all_completed\").get()\n        for item in self.items:\n            item_proxy = ObservableProxy(item)\n            item_proxy.observable(bool, \"completed\").set(target_state)\n            item_proxy.save_to(item)\n\n    def set_filter(self, filter_value: str):\n        \"\"\"Set the current filter.\"\"\"\n        if filter_value in [\"all\", \"active\", \"completed\"]:\n            self.filter.set(filter_value)\n\n    def save(self):\n        \"\"\"Save changes back to the model.\"\"\"\n        self.proxy.save_to(self.model)\n\n# View (pseudocode)\nclass TodoListView:\n    def __init__(self, view_model: TodoListViewModel):\n        self.view_model = view_model\n\n        # Listen for changes to the filtered items\n        self.view_model.proxy.computed(list, \"filtered_items\").on_change(self.render_items)\n\n        # Listen for changes to the counts\n        self.view_model.proxy.computed(int, \"active_count\").on_change(self.render_counts)\n        self.view_model.proxy.computed(int, \"completed_count\").on_change(self.render_counts)\n\n        # Listen for changes to the filter\n        self.view_model.filter.on_change(self.update_filter_buttons)\n\n    def render_items(self, items):\n        print(f\"Rendering {len(items)} items:\")\n        for item in items:\n            print(f\"  {'[x]' if item.completed else '[ ]'} {item.text}\")\n\n    def render_counts(self, _):\n        active_count = self.view_model.proxy.computed(int, \"active_count\").get()\n        completed_count = self.view_model.proxy.computed(int, \"completed_count\").get()\n        print(f\"Counts: {active_count} active, {completed_count} completed\")\n\n    def update_filter_buttons(self, filter_value):\n        print(f\"Filter changed to: {filter_value}\")\n\n    def handle_add_item(self, text):\n        self.view_model.add_item(text)\n\n    def handle_toggle_item(self, item_id):\n        self.view_model.toggle_item(item_id)\n\n    def handle_remove_item(self, item_id):\n        self.view_model.remove_item(item_id)\n\n    def handle_clear_completed(self):\n        self.view_model.clear_completed()\n\n    def handle_toggle_all(self):\n        self.view_model.toggle_all()\n\n    def handle_filter_change(self, filter_value):\n        self.view_model.set_filter(filter_value)\n\n# Usage\nmodel = TodoListModel(items=[])\nview_model = TodoListViewModel(model)\nview = TodoListView(view_model)\n\n# Add some items\nview.handle_add_item(\"Learn Python\")\nview.handle_add_item(\"Learn Observant.py\")\nview.handle_add_item(\"Build an app\")\n\n# Toggle an item\nview.handle_toggle_item(1)  # Mark \"Learn Python\" as completed\n\n# Change the filter\nview.handle_filter_change(\"active\")\nview.handle_filter_change(\"all\")\n\n# Save changes back to the model\nview_model.save()\n</code></pre>"},{"location":"examples/advanced/#nested-observable-proxies","title":"Nested Observable Proxies","text":"<p>Using nested <code>ObservableProxy</code> instances to work with complex object hierarchies:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\n\n@dataclass\nclass Address:\n    street: str\n    city: str\n    state: str\n    zip_code: str\n\n@dataclass\nclass Contact:\n    name: str\n    email: str\n    phone: str\n    address: Address\n\n@dataclass\nclass User:\n    username: str\n    contacts: List[Contact]\n    preferences: Dict[str, str]\n\n# Create a user with nested objects\nuser = User(\n    username=\"alice\",\n    contacts=[\n        Contact(\n            name=\"Bob\",\n            email=\"bob@example.com\",\n            phone=\"555-1234\",\n            address=Address(\n                street=\"123 Main St\",\n                city=\"Anytown\",\n                state=\"CA\",\n                zip_code=\"12345\"\n            )\n        )\n    ],\n    preferences={\"theme\": \"dark\", \"notifications\": \"on\"}\n)\n\n# Create a proxy for the user\nuser_proxy = ObservableProxy(user)\n\n# Access the contacts list\ncontacts = user_proxy.observable_list(Contact, \"contacts\")\n\n# Get the first contact\ncontact = contacts[0]\n\n# Create a proxy for the contact\ncontact_proxy = ObservableProxy(contact)\n\n# Access the address\naddress_obs = contact_proxy.observable(Address, \"address\")\n\n# Get the current address\naddress = address_obs.get()\n\n# Create a proxy for the address\naddress_proxy = ObservableProxy(address)\n\n# Update the address\naddress_proxy.observable(str, \"street\").set(\"456 Oak Ave\")\naddress_proxy.observable(str, \"city\").set(\"Othertown\")\n\n# Save the address changes back to the address object\naddress_proxy.save_to(address)\n\n# Save the contact changes back to the contact object\ncontact_proxy.save_to(contact)\n\n# Save the user changes back to the user object\nuser_proxy.save_to(user)\n\nprint(user.contacts[0].address.street)  # Prints: 456 Oak Ave\nprint(user.contacts[0].address.city)  # Prints: Othertown\n</code></pre>"},{"location":"examples/advanced/#dependency-injection-with-observables","title":"Dependency Injection with Observables","text":"<p>Using observables with dependency injection to create loosely coupled components:</p> <pre><code>from observant import Observable, ObservableList\nfrom typing import List, Protocol, Optional\n\n# Define protocols for services\nclass IUserService(Protocol):\n    def get_current_user(self) -&gt; str: ...\n    def set_current_user(self, username: str) -&gt; None: ...\n\nclass IMessageService(Protocol):\n    def get_messages(self, username: str) -&gt; List[str]: ...\n    def send_message(self, username: str, message: str) -&gt; None: ...\n\n# Implement services\nclass UserService:\n    def __init__(self):\n        self.current_user = Observable(\"\")\n\n    def get_current_user(self) -&gt; str:\n        return self.current_user.get()\n\n    def set_current_user(self, username: str) -&gt; None:\n        self.current_user.set(username)\n\nclass MessageService:\n    def __init__(self):\n        self.messages = {}\n\n    def get_messages(self, username: str) -&gt; List[str]:\n        return self.messages.get(username, [])\n\n    def send_message(self, username: str, message: str) -&gt; None:\n        if username not in self.messages:\n            self.messages[username] = []\n        self.messages[username].append(message)\n\n# Create a service container\nclass ServiceContainer:\n    def __init__(self):\n        self.user_service = UserService()\n        self.message_service = MessageService()\n\n# Create components that use the services\nclass UserComponent:\n    def __init__(self, user_service: IUserService):\n        self.user_service = user_service\n        self.current_user = self.user_service.current_user\n\n        # Listen for changes to the current user\n        self.current_user.on_change(self.on_user_changed)\n\n    def on_user_changed(self, username):\n        if username:\n            print(f\"User changed to: {username}\")\n        else:\n            print(\"User logged out\")\n\n    def login(self, username: str):\n        self.user_service.set_current_user(username)\n\n    def logout(self):\n        self.user_service.set_current_user(\"\")\n\nclass MessageComponent:\n    def __init__(self, user_service: IUserService, message_service: IMessageService):\n        self.user_service = user_service\n        self.message_service = message_service\n        self.messages = ObservableList([])\n\n        # Listen for changes to the current user\n        self.user_service.current_user.on_change(self.load_messages)\n\n    def load_messages(self, username):\n        if username:\n            # Load messages for the current user\n            messages = self.message_service.get_messages(username)\n            self.messages.clear()\n            self.messages.extend(messages)\n        else:\n            # Clear messages when no user is logged in\n            self.messages.clear()\n\n    def send_message(self, message: str):\n        username = self.user_service.get_current_user()\n        if username:\n            self.message_service.send_message(username, message)\n            self.load_messages(username)\n\n# Usage\ncontainer = ServiceContainer()\nuser_component = UserComponent(container.user_service)\nmessage_component = MessageComponent(container.user_service, container.message_service)\n\n# Listen for changes to the messages\nmessage_component.messages.on_change(\n    lambda change: print(f\"Messages changed: {message_component.messages}\")\n)\n\n# Login as Alice\nuser_component.login(\"alice\")  # Prints: User changed to: alice\n\n# Send some messages\nmessage_component.send_message(\"Hello, world!\")\nmessage_component.send_message(\"How are you?\")\n# Prints: Messages changed: ['Hello, world!', 'How are you?']\n\n# Login as Bob\nuser_component.login(\"bob\")  # Prints: User changed to: bob\n# Prints: Messages changed: []\n\n# Send a message as Bob\nmessage_component.send_message(\"Hi there!\")\n# Prints: Messages changed: ['Hi there!']\n\n# Login back as Alice\nuser_component.login(\"alice\")\n# Prints: Messages changed: ['Hello, world!', 'How are you?']\n\n# Logout\nuser_component.logout()  # Prints: User logged out\n# Prints: Messages changed: []\n</code></pre>"},{"location":"examples/advanced/#state-management-with-undoredo","title":"State Management with Undo/Redo","text":"<p>Using <code>ObservableProxy</code> with undo/redo to implement a document editor:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport time\n\n@dataclass\nclass TextBlock:\n    id: int\n    content: str\n    style: Dict[str, str]\n\n@dataclass\nclass Document:\n    title: str\n    blocks: List[TextBlock]\n    metadata: Dict[str, str]\n\nclass DocumentEditor:\n    def __init__(self, document: Document):\n        self.document = document\n        self.proxy = ObservableProxy(document, undo=True, undo_debounce_ms=500)\n\n        # Get observables\n        self.title = self.proxy.observable(str, \"title\")\n        self.blocks = self.proxy.observable_list(TextBlock, \"blocks\")\n        self.metadata = self.proxy.observable_dict((str, str), \"metadata\")\n\n        # Track history\n        self.history = []\n        self.title.on_change(lambda _: self._add_history_entry(\"title\"))\n        self.blocks.on_change(lambda _: self._add_history_entry(\"blocks\"))\n        self.metadata.on_change(lambda _: self._add_history_entry(\"metadata\"))\n\n    def _add_history_entry(self, field_name):\n        self.history.append({\n            \"field\": field_name,\n            \"timestamp\": time.time(),\n            \"can_undo\": self.proxy.can_undo(field_name),\n            \"can_redo\": self.proxy.can_redo(field_name)\n        })\n\n    def set_title(self, title: str):\n        \"\"\"Set the document title.\"\"\"\n        self.title.set(title)\n\n    def add_block(self, content: str, style: Dict[str, str] = None):\n        \"\"\"Add a new text block.\"\"\"\n        block_id = len(self.blocks) + 1\n        self.blocks.append(TextBlock(\n            id=block_id,\n            content=content,\n            style=style or {}\n        ))\n\n    def update_block(self, block_id: int, content: Optional[str] = None, style: Optional[Dict[str, str]] = None):\n        \"\"\"Update a text block.\"\"\"\n        block = next((b for b in self.blocks if b.id == block_id), None)\n        if block:\n            block_proxy = ObservableProxy(block, undo=True)\n\n            if content is not None:\n                block_proxy.observable(str, \"content\").set(content)\n\n            if style is not None:\n                block_style = block_proxy.observable_dict((str, str), \"style\")\n                for key, value in style.items():\n                    block_style[key] = value\n\n            block_proxy.save_to(block)\n\n    def remove_block(self, block_id: int):\n        \"\"\"Remove a text block.\"\"\"\n        index = next((i for i, b in enumerate(self.blocks) if b.id == block_id), -1)\n        if index &gt;= 0:\n            self.blocks.pop(index)\n\n    def set_metadata(self, key: str, value: str):\n        \"\"\"Set a metadata value.\"\"\"\n        self.metadata[key] = value\n\n    def undo(self, field_name: str):\n        \"\"\"Undo changes to a field.\"\"\"\n        if self.proxy.can_undo(field_name):\n            self.proxy.undo(field_name)\n            return True\n        return False\n\n    def redo(self, field_name: str):\n        \"\"\"Redo changes to a field.\"\"\"\n        if self.proxy.can_redo(field_name):\n            self.proxy.redo(field_name)\n            return True\n        return False\n\n    def save(self):\n        \"\"\"Save changes back to the document.\"\"\"\n        self.proxy.save_to(self.document)\n        return self.document\n\n# Usage\ndoc = Document(\n    title=\"Untitled Document\",\n    blocks=[],\n    metadata={\"author\": \"Anonymous\", \"created\": \"2023-01-01\"}\n)\n\neditor = DocumentEditor(doc)\n\n# Set the title\neditor.set_title(\"My Document\")\n\n# Add some blocks\neditor.add_block(\"Introduction\", {\"font-weight\": \"bold\"})\neditor.add_block(\"This is a sample document created with Observant.py.\")\neditor.add_block(\"Conclusion\", {\"font-weight\": \"bold\"})\n\n# Update a block\neditor.update_block(2, content=\"This is a sample document created with Observant.py. It demonstrates the use of ObservableProxy with undo/redo functionality.\")\n\n# Set metadata\neditor.set_metadata(\"author\", \"Alice\")\neditor.set_metadata(\"modified\", \"2023-01-02\")\n\n# Undo the last metadata change\neditor.undo(\"metadata\")\n\n# Redo the metadata change\neditor.redo(\"metadata\")\n\n# Save the document\nsaved_doc = editor.save()\n\nprint(f\"Title: {saved_doc.title}\")\nprint(f\"Blocks: {len(saved_doc.blocks)}\")\nfor block in saved_doc.blocks:\n    print(f\"  {block.id}: {block.content} {block.style}\")\nprint(f\"Metadata: {saved_doc.metadata}\")\nprint(f\"History: {len(editor.history)} entries\")\n</code></pre>"},{"location":"examples/advanced/#reactive-data-processing-pipeline","title":"Reactive Data Processing Pipeline","text":"<p>Using observables to create a reactive data processing pipeline:</p> <pre><code>from observant import Observable, ObservableList\nfrom typing import List, Dict, Any, Callable\nimport time\nimport random\n\n# Define a data source\nclass DataSource:\n    def __init__(self, interval_ms: int = 1000):\n        self.data = ObservableList([])\n        self.interval_ms = interval_ms\n        self.running = False\n\n    def start(self):\n        \"\"\"Start generating data.\"\"\"\n        self.running = True\n        self._generate_data()\n\n    def stop(self):\n        \"\"\"Stop generating data.\"\"\"\n        self.running = False\n\n    def _generate_data(self):\n        \"\"\"Generate a random data point.\"\"\"\n        if not self.running:\n            return\n\n        # Generate a random data point\n        data_point = {\n            \"timestamp\": time.time(),\n            \"value\": random.random() * 100\n        }\n\n        # Add it to the list\n        self.data.append(data_point)\n\n        # Schedule the next data point\n        time.sleep(self.interval_ms / 1000)\n        self._generate_data()\n\n# Define a data processor\nclass DataProcessor:\n    def __init__(self, data_source: DataSource, window_size: int = 10):\n        self.data_source = data_source\n        self.window_size = window_size\n        self.processed_data = Observable([])\n\n        # Listen for changes to the data source\n        self.data_source.data.on_change(self._process_data)\n\n    def _process_data(self, _):\n        \"\"\"Process the data when it changes.\"\"\"\n        data = self.data_source.data[-self.window_size:] if len(self.data_source.data) &gt; 0 else []\n\n        if not data:\n            self.processed_data.set([])\n            return\n\n        # Calculate statistics\n        values = [d[\"value\"] for d in data]\n        result = {\n            \"count\": len(values),\n            \"min\": min(values),\n            \"max\": max(values),\n            \"avg\": sum(values) / len(values),\n            \"timestamp\": time.time()\n        }\n\n        # Update the processed data\n        current = self.processed_data.get()\n        self.processed_data.set(current + [result])\n\n# Define a data visualizer\nclass DataVisualizer:\n    def __init__(self, data_processor: DataProcessor):\n        self.data_processor = data_processor\n\n        # Listen for changes to the processed data\n        self.data_processor.processed_data.on_change(self._update_visualization)\n\n    def _update_visualization(self, data):\n        \"\"\"Update the visualization when the data changes.\"\"\"\n        if not data:\n            print(\"No data to visualize\")\n            return\n\n        # Get the latest data point\n        latest = data[-1]\n\n        # Print a simple visualization\n        print(f\"Data point {latest['count']}:\")\n        print(f\"  Min: {latest['min']:.2f}\")\n        print(f\"  Max: {latest['max']:.2f}\")\n        print(f\"  Avg: {latest['avg']:.2f}\")\n        print(f\"  {'=' * int(latest['avg'] / 5)}\")\n\n# Define an alert manager\nclass AlertManager:\n    def __init__(self, data_processor: DataProcessor, threshold: float = 80):\n        self.data_processor = data_processor\n        self.threshold = threshold\n        self.alerts = ObservableList([])\n\n        # Listen for changes to the processed data\n        self.data_processor.processed_data.on_change(self._check_alerts)\n\n    def _check_alerts(self, data):\n        \"\"\"Check for alerts when the data changes.\"\"\"\n        if not data:\n            return\n\n        # Get the latest data point\n        latest = data[-1]\n\n        # Check if the average exceeds the threshold\n        if latest[\"avg\"] &gt; self.threshold:\n            alert = {\n                \"timestamp\": time.time(),\n                \"message\": f\"Average value {latest['avg']:.2f} exceeds threshold {self.threshold}\",\n                \"level\": \"warning\"\n            }\n            self.alerts.append(alert)\n            print(f\"ALERT: {alert['message']}\")\n\n# Usage\ndata_source = DataSource(interval_ms=500)\ndata_processor = DataProcessor(data_source, window_size=5)\ndata_visualizer = DataVisualizer(data_processor)\nalert_manager = AlertManager(data_processor, threshold=80)\n\n# Start generating data\ndata_source.start()\n\n# Let it run for a few seconds\ntime.sleep(5)\n\n# Stop generating data\ndata_source.stop()\n\nprint(f\"Generated {len(data_source.data)} data points\")\nprint(f\"Processed {len(data_processor.processed_data.get())} data points\")\nprint(f\"Generated {len(alert_manager.alerts)} alerts\")\n</code></pre>"},{"location":"examples/advanced/#next-steps","title":"Next Steps","text":"<p>These examples demonstrate some of the more advanced patterns and use cases for Observant.py. For more information, see the API Reference.</p>"},{"location":"examples/basic/","title":"Basic Usage Examples","text":"<p>This page provides examples of common patterns and use cases for Observant.py.</p>"},{"location":"examples/basic/#simple-counter","title":"Simple Counter","text":"<p>A basic example of using <code>Observable</code> to track a counter value:</p> <pre><code>from observant import Observable\n\n# Create a counter\ncounter = Observable(0)\n\n# Register a callback to be notified when the counter changes\ncounter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n# Increment the counter\ncounter.set(counter.get() + 1)  # Prints: Counter changed to 1\ncounter.set(counter.get() + 1)  # Prints: Counter changed to 2\n</code></pre>"},{"location":"examples/basic/#form-validation","title":"Form Validation","text":"<p>Using <code>ObservableProxy</code> to implement form validation:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass LoginForm:\n    username: str\n    password: str\n    remember_me: bool\n\n# Create a form\nform = LoginForm(username=\"\", password=\"\", remember_me=False)\n\n# Create a proxy\nproxy = ObservableProxy(form)\n\n# Add validators\nproxy.add_validator(\"username\", lambda v: \"Username is required\" if not v else None)\nproxy.add_validator(\"password\", lambda v: \"Password is required\" if not v else None)\nproxy.add_validator(\"password\", lambda v: \"Password must be at least 8 characters\" if v and len(v) &lt; 8 else None)\n\n# Get observables for form fields\nusername = proxy.observable(str, \"username\")\npassword = proxy.observable(str, \"password\")\nremember_me = proxy.observable(bool, \"remember_me\")\n\n# Listen for validation errors\nproxy.validation_for(\"username\").on_change(\n    lambda errors: print(f\"Username errors: {errors}\")\n)\nproxy.validation_for(\"password\").on_change(\n    lambda errors: print(f\"Password errors: {errors}\")\n)\n\n# Listen for overall form validity\nproxy.is_valid().on_change(\n    lambda valid: print(f\"Form is {'valid' if valid else 'invalid'}\")\n)\n\n# Update form fields\nusername.set(\"alice\")  # Username errors: []\npassword.set(\"123\")  # Password errors: ['Password must be at least 8 characters']\npassword.set(\"password123\")  # Password errors: []\nremember_me.set(True)  # Form is valid\n\n# Check if the form is valid\nif proxy.is_valid().get():\n    # Save the form\n    proxy.save_to(form)\n    print(f\"Form saved: {form}\")\n</code></pre>"},{"location":"examples/basic/#shopping-cart","title":"Shopping Cart","text":"<p>Using <code>ObservableList</code> and <code>ObservableProxy</code> to implement a shopping cart:</p> <pre><code>from observant import ObservableList, ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass CartItem:\n    product_id: str\n    name: str\n    price: float\n    quantity: int\n\n@dataclass\nclass ShoppingCart:\n    items: List[CartItem]\n    coupon_code: str\n\n# Create a shopping cart\ncart = ShoppingCart(items=[], coupon_code=\"\")\n\n# Create a proxy\nproxy = ObservableProxy(cart)\n\n# Get the observable list of items\nitems = proxy.observable_list(CartItem, \"items\")\n\n# Register computed properties\nproxy.register_computed(\n    \"subtotal\",\n    lambda: sum(item.price * item.quantity for item in items),\n    [\"items\"]\n)\n\nproxy.register_computed(\n    \"discount\",\n    lambda: proxy.computed(float, \"subtotal\").get() * 0.1 if proxy.observable(str, \"coupon_code\").get() == \"SAVE10\" else 0,\n    [\"subtotal\", \"coupon_code\"]\n)\n\nproxy.register_computed(\n    \"total\",\n    lambda: proxy.computed(float, \"subtotal\").get() - proxy.computed(float, \"discount\").get(),\n    [\"subtotal\", \"discount\"]\n)\n\n# Listen for changes\nitems.on_change(lambda _: print(f\"Cart items changed\"))\nproxy.computed(float, \"subtotal\").on_change(lambda value: print(f\"Subtotal: ${value:.2f}\"))\nproxy.computed(float, \"discount\").on_change(lambda value: print(f\"Discount: ${value:.2f}\"))\nproxy.computed(float, \"total\").on_change(lambda value: print(f\"Total: ${value:.2f}\"))\n\n# Add items to the cart\nitems.append(CartItem(product_id=\"p1\", name=\"T-shirt\", price=19.99, quantity=1))\n# Cart items changed\n# Subtotal: $19.99\n# Discount: $0.00\n# Total: $19.99\n\nitems.append(CartItem(product_id=\"p2\", name=\"Jeans\", price=49.99, quantity=1))\n# Cart items changed\n# Subtotal: $69.98\n# Discount: $0.00\n# Total: $69.98\n\n# Update an item's quantity\nitem = items[0]\nitem_proxy = ObservableProxy(item)\nitem_proxy.observable(int, \"quantity\").set(2)\nitem_proxy.save_to(item)\n# Cart items changed\n# Subtotal: $89.97\n# Discount: $0.00\n# Total: $89.97\n\n# Apply a coupon code\nproxy.observable(str, \"coupon_code\").set(\"SAVE10\")\n# Discount: $8.99\n# Total: $80.98\n</code></pre>"},{"location":"examples/basic/#todo-list","title":"Todo List","text":"<p>Using <code>ObservableList</code> and <code>ObservableProxy</code> to implement a todo list with filtering:</p> <pre><code>from observant import ObservableList, ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass TodoItem:\n    text: str\n    completed: bool\n\n@dataclass\nclass TodoList:\n    items: List[TodoItem]\n    filter: str  # \"all\", \"active\", or \"completed\"\n\n# Create a todo list\ntodo_list = TodoList(items=[], filter=\"all\")\n\n# Create a proxy\nproxy = ObservableProxy(todo_list)\n\n# Get the observable list of items\nitems = proxy.observable_list(TodoItem, \"items\")\n\n# Register computed properties\nproxy.register_computed(\n    \"filtered_items\",\n    lambda: [\n        item for item in items\n        if proxy.observable(str, \"filter\").get() == \"all\"\n        or (proxy.observable(str, \"filter\").get() == \"active\" and not item.completed)\n        or (proxy.observable(str, \"filter\").get() == \"completed\" and item.completed)\n    ],\n    [\"items\", \"filter\"]\n)\n\nproxy.register_computed(\n    \"active_count\",\n    lambda: sum(1 for item in items if not item.completed),\n    [\"items\"]\n)\n\nproxy.register_computed(\n    \"completed_count\",\n    lambda: sum(1 for item in items if item.completed),\n    [\"items\"]\n)\n\n# Listen for changes\nproxy.computed(list, \"filtered_items\").on_change(\n    lambda items: print(f\"Filtered items: {[item.text for item in items]}\")\n)\nproxy.computed(int, \"active_count\").on_change(\n    lambda count: print(f\"Active count: {count}\")\n)\nproxy.computed(int, \"completed_count\").on_change(\n    lambda count: print(f\"Completed count: {count}\")\n)\n\n# Add items to the list\nitems.append(TodoItem(text=\"Buy groceries\", completed=False))\n# Filtered items: ['Buy groceries']\n# Active count: 1\n# Completed count: 0\n\nitems.append(TodoItem(text=\"Clean house\", completed=False))\n# Filtered items: ['Buy groceries', 'Clean house']\n# Active count: 2\n# Completed count: 0\n\nitems.append(TodoItem(text=\"Pay bills\", completed=True))\n# Filtered items: ['Buy groceries', 'Clean house', 'Pay bills']\n# Active count: 2\n# Completed count: 1\n\n# Toggle an item's completed state\nitem = items[0]\nitem_proxy = ObservableProxy(item)\nitem_proxy.observable(bool, \"completed\").set(True)\nitem_proxy.save_to(item)\n# Filtered items: ['Buy groceries', 'Clean house', 'Pay bills']\n# Active count: 1\n# Completed count: 2\n\n# Change the filter\nproxy.observable(str, \"filter\").set(\"active\")\n# Filtered items: ['Clean house']\n\nproxy.observable(str, \"filter\").set(\"completed\")\n# Filtered items: ['Buy groceries', 'Pay bills']\n\nproxy.observable(str, \"filter\").set(\"all\")\n# Filtered items: ['Buy groceries', 'Clean house', 'Pay bills']\n</code></pre>"},{"location":"examples/basic/#settings-manager","title":"Settings Manager","text":"<p>Using <code>ObservableDict</code> to implement a settings manager:</p> <pre><code>from observant import ObservableDict\nimport json\nimport os\n\nclass SettingsManager:\n    def __init__(self, filename: str, defaults: dict = None):\n        self.filename = filename\n        self.defaults = defaults or {}\n        self.settings = ObservableDict(self.defaults.copy())\n\n        # Load settings from file if it exists\n        if os.path.exists(filename):\n            try:\n                with open(filename, 'r') as f:\n                    loaded = json.load(f)\n                    self.settings.update(loaded)\n            except (json.JSONDecodeError, IOError):\n                # If loading fails, use defaults\n                pass\n\n        # Save settings when they change\n        self.settings.on_change(lambda _: self.save())\n\n    def save(self):\n        \"\"\"Save settings to file.\"\"\"\n        try:\n            with open(self.filename, 'w') as f:\n                json.dump(self.settings.copy(), f, indent=2)\n            print(f\"Settings saved to {self.filename}\")\n        except IOError:\n            print(f\"Error saving settings to {self.filename}\")\n\n    def reset(self):\n        \"\"\"Reset settings to defaults.\"\"\"\n        self.settings.clear()\n        self.settings.update(self.defaults)\n        print(\"Settings reset to defaults\")\n\n# Usage\nsettings = SettingsManager(\"settings.json\", {\n    \"theme\": \"light\",\n    \"font_size\": 12,\n    \"notifications\": True\n})\n\n# Access settings\ncurrent_theme = settings.settings[\"theme\"]\nprint(f\"Current theme: {current_theme}\")\n\n# Update settings (automatically saved to file)\nsettings.settings[\"theme\"] = \"dark\"\nsettings.settings[\"font_size\"] = 14\n\n# Reset to defaults\nsettings.reset()\n</code></pre>"},{"location":"examples/basic/#undoredo-text-editor","title":"Undo/Redo Text Editor","text":"<p>Using <code>UndoableObservable</code> to implement a text editor with undo/redo:</p> <pre><code>from observant import UndoableObservable\n\nclass TextEditor:\n    def __init__(self, initial_text: str = \"\"):\n        self.text = UndoableObservable(initial_text, undo_debounce_ms=500)\n        self.text.on_change(self._on_text_changed)\n\n        # Track if we can undo/redo\n        self._can_undo = False\n        self._can_redo = False\n        self._update_undo_redo_state()\n\n    def _on_text_changed(self, text):\n        print(f\"Text changed: {text}\")\n        self._update_undo_redo_state()\n\n    def _update_undo_redo_state(self):\n        can_undo = self.text.can_undo()\n        can_redo = self.text.can_redo()\n\n        if can_undo != self._can_undo:\n            self._can_undo = can_undo\n            print(f\"Can undo: {can_undo}\")\n\n        if can_redo != self._can_redo:\n            self._can_redo = can_redo\n            print(f\"Can redo: {can_redo}\")\n\n    def set_text(self, text: str):\n        self.text.set(text)\n\n    def undo(self):\n        if self.text.can_undo():\n            self.text.undo()\n            return True\n        return False\n\n    def redo(self):\n        if self.text.can_redo():\n            self.text.redo()\n            return True\n        return False\n\n    def get_text(self):\n        return self.text.get()\n\n# Usage\neditor = TextEditor(\"Hello, world!\")\nprint(f\"Initial text: {editor.get_text()}\")\n\neditor.set_text(\"Hello, Python!\")\n# Text changed: Hello, Python!\n# Can undo: True\n\neditor.set_text(\"Hello, Observant!\")\n# Text changed: Hello, Observant!\n\neditor.undo()\n# Text changed: Hello, Python!\n# Can redo: True\n\neditor.redo()\n# Text changed: Hello, Observant!\n# Can redo: False\n\nprint(f\"Final text: {editor.get_text()}\")\n</code></pre>"},{"location":"examples/basic/#next-steps","title":"Next Steps","text":"<p>For more advanced examples, see the Advanced Patterns page.</p>"},{"location":"reference/all_types/","title":"All Types","text":"<p>This page provides an overview of all the types available in Observant.py, including some specialized types that aren't covered in the main documentation.</p>"},{"location":"reference/all_types/#core-types","title":"Core Types","text":""},{"location":"reference/all_types/#observable","title":"Observable","text":"<p>The <code>Observable</code> class is the foundation of Observant.py. It wraps a value and notifies listeners when the value changes.</p> <pre><code>from observant import Observable\n\n# Create an observable with an initial value\ncounter = Observable(0)\n\n# Register a callback to be notified when the value changes\ncounter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n# Change the value\ncounter.set(1)  # Prints: Counter changed to 1\n</code></pre> <p>Learn more about Observable</p>"},{"location":"reference/all_types/#observablelist","title":"ObservableList","text":"<p>The <code>ObservableList</code> class provides an observable wrapper around a Python list. It notifies listeners when items are added, removed, or the list is cleared.</p> <pre><code>from observant import ObservableList\n\n# Create an observable list with initial values\nfruits = ObservableList([\"apple\", \"banana\"])\n\n# Register a callback to be notified when the list changes\nfruits.on_change(lambda change: print(f\"List changed: {change.type.name}\"))\n\n# Modify the list\nfruits.append(\"cherry\")  # Prints: List changed: ADD\n</code></pre> <p>Learn more about ObservableList</p>"},{"location":"reference/all_types/#observabledict","title":"ObservableDict","text":"<p>The <code>ObservableDict</code> class provides an observable wrapper around a Python dictionary. It notifies listeners when entries are added, updated, or removed.</p> <pre><code>from observant import ObservableDict\n\n# Create an observable dictionary with initial values\nsettings = ObservableDict({\"theme\": \"dark\", \"notifications\": True})\n\n# Register a callback to be notified when the dictionary changes\nsettings.on_change(lambda change: print(f\"Dict changed: {change.key}\"))\n\n# Modify the dictionary\nsettings[\"theme\"] = \"light\"  # Prints: Dict changed: theme\n</code></pre> <p>Learn more about ObservableDict</p>"},{"location":"reference/all_types/#observableproxy","title":"ObservableProxy","text":"<p>The <code>ObservableProxy</code> class is the most powerful component of Observant.py. It wraps an existing object and exposes its fields as observables, allowing you to track changes, validate data, implement undo/redo, create computed properties, and synchronize state.</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user\nuser = User(name=\"Ada\", age=36)\n\n# Create a proxy\nproxy = ObservableProxy(user)\n\n# Access fields as observables\nname = proxy.observable(str, \"name\")\nname.on_change(lambda value: print(f\"Name changed to {value}\"))\n\n# Modify a field\nname.set(\"Grace\")  # Prints: Name changed to Grace\n</code></pre> <p>Learn more about ObservableProxy</p>"},{"location":"reference/observable/","title":"Observable","text":"<p>The <code>Observable</code> class is the foundation of Observant.py. It wraps a value and notifies listeners when the value changes.</p>"},{"location":"reference/observable/#basic-usage","title":"Basic Usage","text":"<pre><code>from observant import Observable\n\n# Create an observable with an initial value\ncounter = Observable(0)\n\n# Register a callback to be notified when the value changes\ncounter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n# Change the value\ncounter.set(1)  # Prints: Counter changed to 1\n\n# Get the current value\ncurrent_value = counter.get()  # Returns: 1\n</code></pre>"},{"location":"reference/observable/#type-safety","title":"Type Safety","text":"<p><code>Observable</code> is generic over the type of value it contains:</p> <pre><code>from observant import Observable\nfrom typing import List\n\n# Type-safe observable\nname: Observable[str] = Observable(\"Ada\")\nnumbers: Observable[List[int]] = Observable([1, 2, 3])\n\n# The IDE and type checker will warn about incorrect types\nname.set(42)  # Type error: Expected str, got int\n</code></pre>"},{"location":"reference/observable/#api-reference","title":"API Reference","text":""},{"location":"reference/observable/#constructor","title":"Constructor","text":"<pre><code>Observable(initial_value: T, on_change_enabled: bool = True)\n</code></pre> <ul> <li><code>initial_value</code>: The initial value to store</li> <li><code>on_change_enabled</code>: Whether to enable change notifications immediately</li> </ul>"},{"location":"reference/observable/#methods","title":"Methods","text":""},{"location":"reference/observable/#get","title":"<code>get()</code>","text":"<pre><code>def get(self) -&gt; T\n</code></pre> <p>Returns the current value.</p>"},{"location":"reference/observable/#set","title":"<code>set()</code>","text":"<pre><code>def set(self, value: T, notify: bool = True) -&gt; None\n</code></pre> <p>Sets a new value.</p> <ul> <li><code>value</code>: The new value to set</li> <li><code>notify</code>: Whether to notify listeners of the change</li> </ul>"},{"location":"reference/observable/#on_change","title":"<code>on_change()</code>","text":"<pre><code>def on_change(self, callback: Callable[[T], None]) -&gt; None\n</code></pre> <p>Registers a callback to be notified when the value changes.</p> <ul> <li><code>callback</code>: A function that takes the new value as its argument</li> </ul>"},{"location":"reference/observable/#enable","title":"<code>enable()</code>","text":"<pre><code>def enable(self) -&gt; None\n</code></pre> <p>Enables change notifications.</p>"},{"location":"reference/observable/#disable","title":"<code>disable()</code>","text":"<pre><code>def disable(self) -&gt; None\n</code></pre> <p>Disables change notifications.</p>"},{"location":"reference/observable/#examples","title":"Examples","text":""},{"location":"reference/observable/#tracking-ui-state","title":"Tracking UI State","text":"<pre><code>from observant import Observable\n\n# Track UI state\nis_loading = Observable(False)\nerror_message = Observable(\"\")\nuser_data = Observable(None)\n\n# Update UI when state changes\nis_loading.on_change(lambda loading: update_loading_spinner(loading))\nerror_message.on_change(lambda error: show_error(error) if error else hide_error())\nuser_data.on_change(lambda data: render_user(data) if data else show_login())\n\n# During an API call\nis_loading.set(True)\ntry:\n    data = api.fetch_user()\n    user_data.set(data)\n    error_message.set(\"\")\nexcept Exception as e:\n    error_message.set(str(e))\n    user_data.set(None)\nfinally:\n    is_loading.set(False)\n</code></pre>"},{"location":"reference/observable/#debouncing-changes","title":"Debouncing Changes","text":"<pre><code>from observant import Observable\nimport time\nfrom threading import Timer\n\ndef debounce(wait):\n    \"\"\"Decorator that will postpone a function's execution until after wait seconds\n    have elapsed since the last time it was invoked.\"\"\"\n    def decorator(fn):\n        timer = None\n        def debounced(*args, **kwargs):\n            nonlocal timer\n            if timer is not None:\n                timer.cancel()\n            timer = Timer(wait, lambda: fn(*args, **kwargs))\n            timer.start()\n        return debounced\n    return decorator\n\n# Create an observable for a search query\nsearch_query = Observable(\"\")\n\n# Create a debounced search function\n@debounce(0.5)  # Wait 500ms before searching\ndef perform_search(query):\n    print(f\"Searching for: {query}\")\n    # Actual search logic here...\n\n# Connect the observable to the debounced function\nsearch_query.on_change(perform_search)\n\n# Simulate user typing\nsearch_query.set(\"a\")\nsearch_query.set(\"ap\")\nsearch_query.set(\"app\")\nsearch_query.set(\"appl\")\nsearch_query.set(\"apple\")\n\n# Only the final \"apple\" will trigger the search after 500ms\n</code></pre>"},{"location":"reference/observable/#combining-observables","title":"Combining Observables","text":"<pre><code>from observant import Observable\n\n# Create observables for first and last name\nfirst_name = Observable(\"Ada\")\nlast_name = Observable(\"Lovelace\")\n\n# Create a derived observable for the full name\nfull_name = Observable(f\"{first_name.get()} {last_name.get()}\")\n\n# Update full_name when either component changes\ndef update_full_name(*args):\n    full_name.set(f\"{first_name.get()} {last_name.get()}\")\n\nfirst_name.on_change(update_full_name)\nlast_name.on_change(update_full_name)\n\n# Test it\nfirst_name.set(\"Grace\")  # full_name becomes \"Grace Lovelace\"\nlast_name.set(\"Hopper\")  # full_name becomes \"Grace Hopper\"\n</code></pre>"},{"location":"reference/observable/#implementation-details","title":"Implementation Details","text":"<p>The <code>Observable</code> class implements the <code>IObservable</code> interface, which is defined in <code>observant.interfaces.observable</code>. This interface ensures that all observable types in the library have a consistent API.</p> <p>For more advanced use cases, consider using <code>ObservableProxy</code> which can automatically create observables for all fields in a data object.</p>"},{"location":"reference/observable/#api-documentation","title":"API Documentation","text":"<p>API Reference for Observable</p>"},{"location":"reference/observable_dict/","title":"ObservableDict","text":"<p>The <code>ObservableDict</code> class provides an observable wrapper around a Python dictionary. It notifies listeners when entries are added, updated, or removed.</p>"},{"location":"reference/observable_dict/#basic-usage","title":"Basic Usage","text":"<pre><code>from observant import ObservableDict\n\n# Create an observable dictionary with initial values\nsettings = ObservableDict({\"theme\": \"dark\", \"notifications\": True})\n\n# Register a callback to be notified when the dictionary changes\nsettings.on_change(lambda change: print(f\"Dict changed: {change.key} = {change.value}\"))\n\n# Modify the dictionary\nsettings[\"theme\"] = \"light\"  # Prints: Dict changed: theme = light\nsettings[\"sound\"] = \"on\"  # Prints: Dict changed: sound = on\ndel settings[\"notifications\"]  # Prints: Dict changed: notifications = True\nsettings.clear()  # Prints a clear notification\n</code></pre>"},{"location":"reference/observable_dict/#type-safety","title":"Type Safety","text":"<p><code>ObservableDict</code> is generic over the types of keys and values it contains:</p> <pre><code>from observant import ObservableDict\n\n# Type-safe observable dictionary\nuser_ages: ObservableDict[str, int] = ObservableDict({\"Alice\": 32, \"Bob\": 28})\nsettings: ObservableDict[str, bool] = ObservableDict({\"dark_mode\": True, \"notifications\": False})\n\n# The IDE and type checker will warn about incorrect types\nuser_ages[\"Charlie\"] = \"thirty\"  # Type error: Expected int, got str\nsettings[42] = True  # Type error: Expected str key, got int\n</code></pre>"},{"location":"reference/observable_dict/#change-notifications","title":"Change Notifications","text":"<p>When the dictionary changes, the callback receives a <code>DictChange</code> object with the following properties:</p> <ul> <li><code>type</code>: The type of change (SET, REMOVE, CLEAR)</li> <li><code>key</code>: The key that was changed (None for CLEAR)</li> <li><code>value</code>: The new value for SET operations, or the removed value for REMOVE operations</li> <li><code>old_value</code>: The previous value for SET operations (if the key existed)</li> <li><code>old_items</code>: For CLEAR operations, the dictionary of items that were cleared</li> </ul> <pre><code>from observant import ObservableDict\nfrom observant.types.collection_change_type import ObservableCollectionChangeType\n\nsettings = ObservableDict({\"theme\": \"dark\", \"notifications\": True})\n\ndef on_change(change):\n    if change.type == ObservableCollectionChangeType.SET:\n        if hasattr(change, 'old_value'):\n            print(f\"Updated {change.key} from {change.old_value} to {change.value}\")\n        else:\n            print(f\"Added {change.key} = {change.value}\")\n    elif change.type == ObservableCollectionChangeType.REMOVE:\n        print(f\"Removed {change.key} = {change.value}\")\n    elif change.type == ObservableCollectionChangeType.CLEAR:\n        print(f\"Cleared {len(change.old_items)} items: {change.old_items}\")\n\nsettings.on_change(on_change)\n\nsettings[\"theme\"] = \"light\"  # Prints: Updated theme from dark to light\nsettings[\"sound\"] = \"on\"  # Prints: Added sound = on\ndel settings[\"notifications\"]  # Prints: Removed notifications = True\nsettings.clear()  # Prints: Cleared 2 items: {'theme': 'light', 'sound': 'on'}\n</code></pre>"},{"location":"reference/observable_dict/#api-reference","title":"API Reference","text":""},{"location":"reference/observable_dict/#constructor","title":"Constructor","text":"<pre><code>ObservableDict(initial_items: dict[TKey, TValue] = None, copy: bool = True)\n</code></pre> <ul> <li><code>initial_items</code>: The initial dictionary of items (default: empty dict)</li> <li><code>copy</code>: Whether to copy the initial items (default: True)</li> </ul>"},{"location":"reference/observable_dict/#dictionary-operations","title":"Dictionary Operations","text":"<p><code>ObservableDict</code> supports all standard dictionary operations:</p> <pre><code>settings = ObservableDict({\"theme\": \"dark\", \"notifications\": True})\n\n# Set a value\nsettings[\"sound\"] = \"on\"\n\n# Get a value\ntheme = settings[\"theme\"]\nsound = settings.get(\"sound\", \"off\")  # With default value\n\n# Remove a key\ndel settings[\"notifications\"]\nremoved_value = settings.pop(\"theme\")\n\n# Check if a key exists\nif \"sound\" in settings:\n    print(\"Sound setting exists!\")\n\n# Clear the dictionary\nsettings.clear()\n\n# Get the length\nlength = len(settings)\n\n# Iterate over keys\nfor key in settings:\n    print(key)\n\n# Iterate over key-value pairs\nfor key, value in settings.items():\n    print(f\"{key} = {value}\")\n\n# Get all keys and values\nkeys = settings.keys()\nvalues = settings.values()\n</code></pre>"},{"location":"reference/observable_dict/#additional-methods","title":"Additional Methods","text":""},{"location":"reference/observable_dict/#on_change","title":"<code>on_change()</code>","text":"<pre><code>def on_change(self, callback: Callable[[DictChange[TKey, TValue]], None]) -&gt; None\n</code></pre> <p>Registers a callback to be notified when the dictionary changes.</p> <ul> <li><code>callback</code>: A function that takes a <code>DictChange</code> object as its argument</li> </ul>"},{"location":"reference/observable_dict/#copy","title":"<code>copy()</code>","text":"<pre><code>def copy(self) -&gt; dict[TKey, TValue]\n</code></pre> <p>Returns a copy of the underlying dictionary.</p>"},{"location":"reference/observable_dict/#update","title":"<code>update()</code>","text":"<pre><code>def update(self, other: dict[TKey, TValue]) -&gt; None\n</code></pre> <p>Updates the dictionary with key-value pairs from another dictionary.</p>"},{"location":"reference/observable_dict/#examples","title":"Examples","text":""},{"location":"reference/observable_dict/#form-validation","title":"Form Validation","text":"<pre><code>from observant import ObservableDict\nfrom typing import Dict, List, Optional\n\nclass FormValidator:\n    def __init__(self, initial_values: Dict[str, str] = None):\n        self.values = ObservableDict(initial_values or {})\n        self.errors = ObservableDict[str, List[str]]({})\n        self.validators: Dict[str, List[callable]] = {}\n\n        # Validate when values change\n        self.values.on_change(self._on_value_change)\n\n    def add_validator(self, field: str, validator: callable):\n        \"\"\"Add a validator function for a field.\n\n        The validator should take a value and return an error message or None.\n        \"\"\"\n        if field not in self.validators:\n            self.validators[field] = []\n        self.validators[field].append(validator)\n\n        # Validate immediately if the field has a value\n        if field in self.values:\n            self._validate_field(field, self.values[field])\n\n    def _on_value_change(self, change):\n        if change.type.name == \"SET\" and change.key is not None:\n            self._validate_field(change.key, change.value)\n\n    def _validate_field(self, field: str, value: str):\n        if field not in self.validators:\n            return\n\n        field_errors = []\n        for validator in self.validators[field]:\n            error = validator(value)\n            if error:\n                field_errors.append(error)\n\n        if field_errors:\n            self.errors[field] = field_errors\n        elif field in self.errors:\n            del self.errors[field]\n\n    @property\n    def is_valid(self) -&gt; bool:\n        return len(self.errors) == 0\n\n# Usage\nform = FormValidator({\n    \"username\": \"\",\n    \"email\": \"\",\n    \"password\": \"\"\n})\n\n# Add validators\nform.add_validator(\"username\", lambda v: \"Username is required\" if not v else None)\nform.add_validator(\"email\", lambda v: \"Email is required\" if not v else None)\nform.add_validator(\"email\", lambda v: \"Invalid email format\" if v and \"@\" not in v else None)\nform.add_validator(\"password\", lambda v: \"Password must be at least 8 characters\" if len(v) &lt; 8 else None)\n\n# Track errors\nform.errors.on_change(lambda _: print(f\"Form errors: {form.errors.copy()}\"))\n\n# Update values\nform.values[\"username\"] = \"alice\"  # No errors\nform.values[\"email\"] = \"alice\"  # Error: Invalid email format\nform.values[\"email\"] = \"alice@example.com\"  # No errors\nform.values[\"password\"] = \"1234\"  # Error: Password must be at least 8 characters\n</code></pre>"},{"location":"reference/observable_dict/#settings-manager","title":"Settings Manager","text":"<pre><code>from observant import ObservableDict\nimport json\nimport os\n\nclass SettingsManager:\n    def __init__(self, filename: str, defaults: dict = None):\n        self.filename = filename\n        self.defaults = defaults or {}\n        self.settings = ObservableDict(self.defaults.copy())\n\n        # Load settings from file if it exists\n        if os.path.exists(filename):\n            try:\n                with open(filename, 'r') as f:\n                    loaded = json.load(f)\n                    self.settings.update(loaded)\n            except (json.JSONDecodeError, IOError):\n                # If loading fails, use defaults\n                pass\n\n        # Save settings when they change\n        self.settings.on_change(lambda _: self.save())\n\n    def save(self):\n        \"\"\"Save settings to file.\"\"\"\n        try:\n            with open(self.filename, 'w') as f:\n                json.dump(self.settings.copy(), f, indent=2)\n        except IOError:\n            print(f\"Error saving settings to {self.filename}\")\n\n    def reset(self):\n        \"\"\"Reset settings to defaults.\"\"\"\n        self.settings.clear()\n        self.settings.update(self.defaults)\n\n# Usage\nsettings = SettingsManager(\"settings.json\", {\n    \"theme\": \"light\",\n    \"font_size\": 12,\n    \"notifications\": True\n})\n\n# Access settings\ncurrent_theme = settings.settings[\"theme\"]\n\n# Update settings (automatically saved to file)\nsettings.settings[\"theme\"] = \"dark\"\nsettings.settings[\"font_size\"] = 14\n\n# Reset to defaults\nsettings.reset()\n</code></pre>"},{"location":"reference/observable_dict/#implementation-details","title":"Implementation Details","text":"<p>The <code>ObservableDict</code> class implements the <code>IObservableDict</code> interface, which is defined in <code>observant.interfaces.dict</code>. This interface ensures that all observable dictionary types in the library have a consistent API.</p> <p>For more advanced use cases, consider using <code>ObservableProxy</code> which can automatically create observable dictionaries for dictionary fields in a data object.</p>"},{"location":"reference/observable_dict/#api-documentation","title":"API Documentation","text":"<p>API Reference for ObservableDict</p>"},{"location":"reference/observable_list/","title":"ObservableList","text":"<p>The <code>ObservableList</code> class provides an observable wrapper around a Python list. It notifies listeners when items are added, removed, or the list is cleared.</p>"},{"location":"reference/observable_list/#basic-usage","title":"Basic Usage","text":"<pre><code>from observant import ObservableList\n\n# Create an observable list with initial values\nfruits = ObservableList([\"apple\", \"banana\"])\n\n# Register a callback to be notified when the list changes\nfruits.on_change(lambda change: print(f\"List changed: {change.type.name} at index {change.index}\"))\n\n# Modify the list\nfruits.append(\"cherry\")  # Prints: List changed: ADD at index 2\nfruits.pop(0)  # Prints: List changed: REMOVE at index 0\nfruits.clear()  # Prints: List changed: CLEAR at index None\n</code></pre>"},{"location":"reference/observable_list/#type-safety","title":"Type Safety","text":"<p><code>ObservableList</code> is generic over the type of items it contains:</p> <pre><code>from observant import ObservableList\n\n# Type-safe observable list\nnames: ObservableList[str] = ObservableList([\"Ada\", \"Grace\"])\nnumbers: ObservableList[int] = ObservableList([1, 2, 3])\n\n# The IDE and type checker will warn about incorrect types\nnames.append(42)  # Type error: Expected str, got int\n</code></pre>"},{"location":"reference/observable_list/#change-notifications","title":"Change Notifications","text":"<p>When the list changes, the callback receives a <code>ListChange</code> object with the following properties:</p> <ul> <li><code>type</code>: The type of change (ADD, REMOVE, CLEAR)</li> <li><code>index</code>: The index where the change occurred (None for CLEAR)</li> <li><code>item</code>: The item that was added or removed (None for CLEAR)</li> <li><code>items</code>: For CLEAR operations, the list of items that were cleared</li> </ul> <pre><code>from observant import ObservableList\nfrom observant.types.collection_change_type import ObservableCollectionChangeType\n\nfruits = ObservableList([\"apple\", \"banana\"])\n\ndef on_change(change):\n    if change.type == ObservableCollectionChangeType.ADD:\n        print(f\"Added {change.item} at index {change.index}\")\n    elif change.type == ObservableCollectionChangeType.REMOVE:\n        print(f\"Removed {change.item} from index {change.index}\")\n    elif change.type == ObservableCollectionChangeType.CLEAR:\n        print(f\"Cleared {len(change.items)} items: {change.items}\")\n\nfruits.on_change(on_change)\n\nfruits.append(\"cherry\")  # Prints: Added cherry at index 2\nfruits.pop(0)  # Prints: Removed apple from index 0\nfruits.clear()  # Prints: Cleared 2 items: ['banana', 'cherry']\n</code></pre>"},{"location":"reference/observable_list/#api-reference","title":"API Reference","text":""},{"location":"reference/observable_list/#constructor","title":"Constructor","text":"<pre><code>ObservableList(initial_items: list[T] = None, copy: bool = True)\n</code></pre> <ul> <li><code>initial_items</code>: The initial list of items (default: empty list)</li> <li><code>copy</code>: Whether to copy the initial items (default: True)</li> </ul>"},{"location":"reference/observable_list/#list-operations","title":"List Operations","text":"<p><code>ObservableList</code> supports all standard list operations:</p> <pre><code>fruits = ObservableList([\"apple\", \"banana\"])\n\n# Append an item\nfruits.append(\"cherry\")\n\n# Insert an item at a specific index\nfruits.insert(1, \"orange\")\n\n# Remove an item\nfruits.remove(\"banana\")\n\n# Pop an item\nitem = fruits.pop()  # Removes and returns the last item\nitem = fruits.pop(0)  # Removes and returns the item at index 0\n\n# Clear the list\nfruits.clear()\n\n# Get the length\nlength = len(fruits)\n\n# Check if an item is in the list\nif \"apple\" in fruits:\n    print(\"Found apple!\")\n\n# Access items by index\nfirst = fruits[0]\nfruits[1] = \"new value\"\n\n# Slice the list\nsubset = fruits[1:3]\n\n# Iterate over items\nfor fruit in fruits:\n    print(fruit)\n</code></pre>"},{"location":"reference/observable_list/#additional-methods","title":"Additional Methods","text":""},{"location":"reference/observable_list/#on_change","title":"<code>on_change()</code>","text":"<pre><code>def on_change(self, callback: Callable[[ListChange[T]], None]) -&gt; None\n</code></pre> <p>Registers a callback to be notified when the list changes.</p> <ul> <li><code>callback</code>: A function that takes a <code>ListChange</code> object as its argument</li> </ul>"},{"location":"reference/observable_list/#copy","title":"<code>copy()</code>","text":"<pre><code>def copy(self) -&gt; list[T]\n</code></pre> <p>Returns a copy of the underlying list.</p>"},{"location":"reference/observable_list/#extend","title":"<code>extend()</code>","text":"<pre><code>def extend(self, items: Iterable[T]) -&gt; None\n</code></pre> <p>Extends the list with items from an iterable.</p>"},{"location":"reference/observable_list/#examples","title":"Examples","text":""},{"location":"reference/observable_list/#filtering-and-sorting","title":"Filtering and Sorting","text":"<pre><code>from observant import ObservableList\n\n# Create a list of users\nusers = ObservableList([\n    {\"name\": \"Alice\", \"age\": 32},\n    {\"name\": \"Bob\", \"age\": 28},\n    {\"name\": \"Charlie\", \"age\": 45}\n])\n\n# Create filtered views\nadults = ObservableList()\nseniors = ObservableList()\n\n# Update filtered views when the main list changes\ndef update_filtered_views():\n    adults.clear()\n    seniors.clear()\n\n    for user in users:\n        if user[\"age\"] &gt;= 18:\n            adults.append(user)\n        if user[\"age\"] &gt;= 65:\n            seniors.append(user)\n\n# Initial population\nupdate_filtered_views()\n\n# Register for changes\nusers.on_change(lambda _: update_filtered_views())\n\n# Add a new user\nusers.append({\"name\": \"Diana\", \"age\": 67})\n# adults now contains all 4 users\n# seniors now contains Diana\n</code></pre>"},{"location":"reference/observable_list/#undoredo-support","title":"Undo/Redo Support","text":"<pre><code>from observant import ObservableList\nfrom observant.types.collection_change_type import ObservableCollectionChangeType\nfrom typing import List, Any, Callable\n\nclass UndoableList:\n    def __init__(self, initial_items=None):\n        self.list = ObservableList(initial_items)\n        self.undo_stack: List[Callable[[], None]] = []\n        self.redo_stack: List[Callable[[], None]] = []\n\n        # Register for changes to build undo/redo stacks\n        self.list.on_change(self._on_change)\n\n    def _on_change(self, change):\n        # Clear redo stack when a new change is made\n        self.redo_stack.clear()\n\n        if change.type == ObservableCollectionChangeType.ADD:\n            # For adds, the undo action is to remove the item\n            def undo():\n                if change.index is not None:\n                    self.list.pop(change.index)\n            self.undo_stack.append(undo)\n\n        elif change.type == ObservableCollectionChangeType.REMOVE:\n            # For removes, the undo action is to add the item back\n            def undo():\n                if change.index is not None:\n                    self.list.insert(change.index, change.item)\n            self.undo_stack.append(undo)\n\n        elif change.type == ObservableCollectionChangeType.CLEAR:\n            # For clears, the undo action is to restore all items\n            items = change.items\n            def undo():\n                self.list.extend(items)\n            self.undo_stack.append(undo)\n\n    def undo(self):\n        if self.undo_stack:\n            undo_action = self.undo_stack.pop()\n            # TODO: Store the current state for redo\n            undo_action()\n\n    def redo(self):\n        if self.redo_stack:\n            redo_action = self.redo_stack.pop()\n            redo_action()\n\n# Usage\ntodo_list = UndoableList([\"Buy groceries\", \"Clean house\"])\ntodo_list.list.append(\"Write code\")  # Adds to undo stack\ntodo_list.undo()  # Removes \"Write code\"\n</code></pre>"},{"location":"reference/observable_list/#implementation-details","title":"Implementation Details","text":"<p>The <code>ObservableList</code> class implements the <code>IObservableList</code> interface, which is defined in <code>observant.interfaces.list</code>. This interface ensures that all observable list types in the library have a consistent API.</p> <p>For more advanced use cases, consider using <code>ObservableProxy</code> which can automatically create observable lists for list fields in a data object.</p>"},{"location":"reference/observable_list/#api-documentation","title":"API Documentation","text":"<p>API Reference for ObservableList</p>"},{"location":"reference/proxy/","title":"ObservableProxy","text":"<p>The <code>ObservableProxy</code> class is the most powerful component of Observant.py. It wraps an existing object and exposes its fields as observables, allowing you to track changes, validate data, implement undo/redo, create computed properties, and synchronize state.</p>"},{"location":"reference/proxy/#basic-usage","title":"Basic Usage","text":"<pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n    preferences: dict[str, str]\n    friends: list[str]\n\n# Create a user\nuser = User(\n    name=\"Ada\",\n    age=36,\n    preferences={\"theme\": \"dark\"},\n    friends=[\"Charles\", \"Grace\"]\n)\n\n# Create a proxy for the user\nproxy = ObservableProxy(user)\n\n# Access scalar fields as observables\nname_obs = proxy.observable(str, \"name\")\nname_obs.on_change(lambda name: print(f\"Name changed to: {name}\"))\n\n# Access list fields as observable lists\nfriends_obs = proxy.observable_list(str, \"friends\")\nfriends_obs.on_change(lambda change: print(f\"Friends changed: {change.type.name}\"))\n\n# Access dict fields as observable dictionaries\nprefs_obs = proxy.observable_dict((str, str), \"preferences\")\nprefs_obs.on_change(lambda change: print(f\"Preferences changed: {change.key}\"))\n\n# Make changes\nname_obs.set(\"Grace\")  # Prints: Name changed to: Grace\nfriends_obs.append(\"Alan\")  # Prints: Friends changed: ADD\nprefs_obs[\"notifications\"] = \"on\"  # Prints: Preferences changed: notifications\n\n# Save changes back to the original object\nproxy.save_to(user)\n</code></pre>"},{"location":"reference/proxy/#key-features","title":"Key Features","text":"<p><code>ObservableProxy</code> provides several powerful features:</p> <ol> <li>Type-safe field access: Get strongly-typed observables for each field</li> <li>Validation: Add validators to ensure data integrity</li> <li>Undo/Redo: Track and revert changes</li> <li>Computed Properties: Create properties that automatically update</li> <li>Dirty State Tracking: Know which fields have been modified</li> <li>Synchronization: Optionally sync changes back to the original object</li> </ol>"},{"location":"reference/proxy/#constructor","title":"Constructor","text":"<pre><code>ObservableProxy(\n    obj: T,\n    *,\n    sync: bool = False,\n    undo: bool = False,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n)\n</code></pre> <ul> <li><code>obj</code>: The object to proxy</li> <li><code>sync</code>: If True, changes are immediately synced back to the original object</li> <li><code>undo</code>: If True, enables undo/redo functionality for all fields</li> <li><code>undo_max</code>: Maximum number of undo steps to store (None means unlimited)</li> <li><code>undo_debounce_ms</code>: Time window in milliseconds to group changes (None means no debouncing)</li> </ul>"},{"location":"reference/proxy/#core-methods","title":"Core Methods","text":""},{"location":"reference/proxy/#accessing-fields","title":"Accessing Fields","text":"<pre><code># Get an observable for a scalar field\nname_obs = proxy.observable(str, \"name\")\n\n# Get an observable list for a list field\nfriends_obs = proxy.observable_list(str, \"friends\")\n\n# Get an observable dict for a dict field\nprefs_obs = proxy.observable_dict((str, str), \"preferences\")\n</code></pre>"},{"location":"reference/proxy/#saving-changes","title":"Saving Changes","text":"<pre><code># Save all changes back to the original object\nproxy.save_to(user)\n\n# Or create a new object with the changes\nnew_user = User(name=\"\", age=0, preferences={}, friends=[])\nproxy.save_to(new_user)\n</code></pre>"},{"location":"reference/proxy/#updating-multiple-fields","title":"Updating Multiple Fields","text":"<pre><code># Update multiple scalar fields at once\nproxy.update(name=\"Grace\", age=52)\n\n# Load values from a dictionary\nproxy.load_dict({\"name\": \"Grace\", \"age\": 52})\n</code></pre>"},{"location":"reference/proxy/#accessing-the-original-object","title":"Accessing the Original Object","text":"<pre><code># Get the original object being proxied\noriginal = proxy.get()\n</code></pre>"},{"location":"reference/proxy/#examples","title":"Examples","text":""},{"location":"reference/proxy/#form-binding","title":"Form Binding","text":"<pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import List, Dict\n\n@dataclass\nclass UserProfile:\n    username: str\n    email: str\n    bio: str\n    tags: List[str]\n    settings: Dict[str, bool]\n\n# Create a model\nprofile = UserProfile(\n    username=\"\",\n    email=\"\",\n    bio=\"\",\n    tags=[],\n    settings={\"public\": True, \"notifications\": True}\n)\n\n# Create a proxy\nproxy = ObservableProxy(profile)\n\n# Add validation\nproxy.add_validator(\"username\", lambda v: \"Username is required\" if not v else None)\nproxy.add_validator(\"username\", lambda v: \"Username too short\" if len(v) &lt; 3 else None)\nproxy.add_validator(\"email\", lambda v: \"Email is required\" if not v else None)\nproxy.add_validator(\"email\", lambda v: \"Invalid email\" if v and \"@\" not in v else None)\n\n# Bind to UI elements (pseudocode)\ndef bind_input(field_name, input_element):\n    # Get the observable\n    obs = proxy.observable(str, field_name)\n\n    # Update the observable when the input changes\n    input_element.on_change(lambda value: obs.set(value))\n\n    # Update the input when the observable changes\n    obs.on_change(lambda value: input_element.set_value(value))\n\n    # Show validation errors\n    proxy.validation_for(field_name).on_change(\n        lambda errors: input_element.show_errors(errors)\n    )\n\n# Bind to form elements\nbind_input(\"username\", username_input)\nbind_input(\"email\", email_input)\nbind_input(\"bio\", bio_textarea)\n\n# Disable submit button if form is invalid\nproxy.is_valid().on_change(\n    lambda valid: submit_button.set_enabled(valid)\n)\n\n# Handle form submission\ndef on_submit():\n    if proxy.is_valid().get():\n        # Save changes back to the model\n        proxy.save_to(profile)\n        # Submit the form\n        api.submit_profile(profile)\n</code></pre>"},{"location":"reference/proxy/#model-view-viewmodel-mvvm-pattern","title":"Model-View-ViewModel (MVVM) Pattern","text":"<pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass TodoItem:\n    text: str\n    completed: bool\n\n@dataclass\nclass TodoListModel:\n    items: List[TodoItem]\n\nclass TodoListViewModel:\n    def __init__(self, model: TodoListModel):\n        self.model = model\n        self.proxy = ObservableProxy(model)\n\n        # Get observable list of items\n        self.items = self.proxy.observable_list(TodoItem, \"items\")\n\n        # Register computed properties\n        self.proxy.register_computed(\n            \"completed_count\",\n            lambda: sum(1 for item in self.items if item.completed),\n            [\"items\"]\n        )\n\n        self.proxy.register_computed(\n            \"active_count\",\n            lambda: len(self.items) - self.proxy.computed(int, \"completed_count\").get(),\n            [\"items\", \"completed_count\"]\n        )\n\n        self.proxy.register_computed(\n            \"all_completed\",\n            lambda: len(self.items) &gt; 0 and self.proxy.computed(int, \"completed_count\").get() == len(self.items),\n            [\"items\", \"completed_count\"]\n        )\n\n    def add_item(self, text: str):\n        self.items.append(TodoItem(text=text, completed=False))\n\n    def remove_item(self, index: int):\n        self.items.pop(index)\n\n    def toggle_item(self, index: int):\n        item = self.items[index]\n        item_proxy = ObservableProxy(item)\n        completed_obs = item_proxy.observable(bool, \"completed\")\n        completed_obs.set(not completed_obs.get())\n        item_proxy.save_to(item)\n\n    def clear_completed(self):\n        # Create a new list with only active items\n        active_items = [item for item in self.items if not item.completed]\n        self.items.clear()\n        self.items.extend(active_items)\n\n    def toggle_all(self):\n        target_state = not self.proxy.computed(bool, \"all_completed\").get()\n        for item in self.items:\n            item_proxy = ObservableProxy(item)\n            item_proxy.observable(bool, \"completed\").set(target_state)\n            item_proxy.save_to(item)\n\n    def save(self):\n        self.proxy.save_to(self.model)\n</code></pre>"},{"location":"reference/proxy/#next-steps","title":"Next Steps","text":"<p>Explore the specific features of <code>ObservableProxy</code> in more detail:</p> <ul> <li>Validation: Add validators to ensure data integrity</li> <li>Undo/Redo: Track and revert changes</li> <li>Computed Fields: Create properties that automatically update</li> <li>Syncing &amp; Dirty State: Synchronize state between models</li> </ul>"},{"location":"reference/proxy/#api-documentation","title":"API Documentation","text":"<p>API Reference for ObservableProxy</p>"},{"location":"reference/proxy/computed/","title":"Computed Fields","text":"<p><code>ObservableProxy</code> allows you to define computed fields that automatically update based on changes to other fields. This page explains how to use computed fields.</p>"},{"location":"reference/proxy/computed/#basic-usage","title":"Basic Usage","text":"<p>Computed fields are properties that are derived from other fields. They are recalculated automatically when their dependencies change.</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\n# Create a user\nuser = User(first_name=\"Ada\", last_name=\"Lovelace\")\n\n# Create a proxy\nproxy = ObservableProxy(user)\n\n# Register a computed property for the full name\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    [\"first_name\", \"last_name\"]\n)\n\n# Access the computed property\nfull_name = proxy.computed(str, \"full_name\")\nprint(full_name.get())  # Prints: Ada Lovelace\n\n# Update a dependency\nproxy.observable(str, \"first_name\").set(\"Grace\")\nprint(full_name.get())  # Prints: Grace Lovelace\n</code></pre>"},{"location":"reference/proxy/computed/#registering-computed-fields","title":"Registering Computed Fields","text":"<p>To create a computed field, you need to register it with the proxy:</p> <pre><code>proxy.register_computed(\n    \"field_name\",     # Name of the computed field\n    compute_function, # Function that computes the value\n    dependencies      # List of field names that the computed field depends on\n)\n</code></pre> <p>The compute function should return the computed value. It can access the values of other fields using the proxy's <code>observable()</code>, <code>observable_list()</code>, <code>observable_dict()</code>, or <code>computed()</code> methods.</p>"},{"location":"reference/proxy/computed/#accessing-computed-fields","title":"Accessing Computed Fields","text":"<p>You can access a computed field using the <code>computed()</code> method:</p> <pre><code>computed_field = proxy.computed(field_type, \"field_name\")\n</code></pre> <p>The returned object is an <code>Observable</code> that you can use like any other observable:</p> <pre><code># Get the current value\nvalue = computed_field.get()\n\n# Listen for changes\ncomputed_field.on_change(lambda value: print(f\"Computed field changed to {value}\"))\n</code></pre>"},{"location":"reference/proxy/computed/#computed-field-dependencies","title":"Computed Field Dependencies","text":"<p>When you register a computed field, you specify its dependencies. The computed field will be recalculated automatically when any of its dependencies change.</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass Rectangle:\n    width: float\n    height: float\n\n# Create a rectangle\nrect = Rectangle(width=10.0, height=5.0)\n\n# Create a proxy\nproxy = ObservableProxy(rect)\n\n# Register computed properties\nproxy.register_computed(\n    \"area\",\n    lambda: proxy.observable(float, \"width\").get() * proxy.observable(float, \"height\").get(),\n    [\"width\", \"height\"]\n)\n\nproxy.register_computed(\n    \"perimeter\",\n    lambda: 2 * (proxy.observable(float, \"width\").get() + proxy.observable(float, \"height\").get()),\n    [\"width\", \"height\"]\n)\n\n# Access computed properties\narea = proxy.computed(float, \"area\")\nperimeter = proxy.computed(float, \"perimeter\")\n\nprint(f\"Area: {area.get()}\")  # Prints: Area: 50.0\nprint(f\"Perimeter: {perimeter.get()}\")  # Prints: Perimeter: 30.0\n\n# Update a dependency\nproxy.observable(float, \"width\").set(20.0)\n\nprint(f\"Area: {area.get()}\")  # Prints: Area: 100.0\nprint(f\"Perimeter: {perimeter.get()}\")  # Prints: Perimeter: 50.0\n</code></pre>"},{"location":"reference/proxy/computed/#computed-fields-with-collections","title":"Computed Fields with Collections","text":"<p>Computed fields can also depend on list and dictionary fields:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass ShoppingCart:\n    items: List[float]\n\n# Create a shopping cart\ncart = ShoppingCart(items=[10.0, 20.0, 5.0])\n\n# Create a proxy\nproxy = ObservableProxy(cart)\n\n# Register computed properties\nproxy.register_computed(\n    \"total\",\n    lambda: sum(proxy.observable_list(float, \"items\")),\n    [\"items\"]\n)\n\nproxy.register_computed(\n    \"item_count\",\n    lambda: len(proxy.observable_list(float, \"items\")),\n    [\"items\"]\n)\n\nproxy.register_computed(\n    \"average_price\",\n    lambda: proxy.computed(float, \"total\").get() / proxy.computed(int, \"item_count\").get() if proxy.computed(int, \"item_count\").get() &gt; 0 else 0.0,\n    [\"total\", \"item_count\"]\n)\n\n# Access computed properties\ntotal = proxy.computed(float, \"total\")\nitem_count = proxy.computed(int, \"item_count\")\naverage_price = proxy.computed(float, \"average_price\")\n\nprint(f\"Total: ${total.get()}\")  # Prints: Total: $35.0\nprint(f\"Item count: {item_count.get()}\")  # Prints: Item count: 3\nprint(f\"Average price: ${average_price.get()}\")  # Prints: Average price: $11.67\n\n# Update the items\nitems = proxy.observable_list(float, \"items\")\nitems.append(15.0)\n\nprint(f\"Total: ${total.get()}\")  # Prints: Total: $50.0\nprint(f\"Item count: {item_count.get()}\")  # Prints: Item count: 4\nprint(f\"Average price: ${average_price.get()}\")  # Prints: Average price: $12.5\n</code></pre>"},{"location":"reference/proxy/computed/#computed-fields-depending-on-other-computed-fields","title":"Computed Fields Depending on Other Computed Fields","text":"<p>Computed fields can depend on other computed fields. In the example above, <code>average_price</code> depends on <code>total</code> and <code>item_count</code>, which are themselves computed fields.</p> <p>When you update a field, all computed fields that depend on it, directly or indirectly, will be recalculated in the correct order.</p>"},{"location":"reference/proxy/computed/#computed-fields-with-validation","title":"Computed Fields with Validation","text":"<p>You can add validators to computed fields just like regular fields:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\n# Create a user\nuser = User(first_name=\"\", last_name=\"\")\n\n# Create a proxy\nproxy = ObservableProxy(user)\n\n# Register a computed property for the full name\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\".strip(),\n    [\"first_name\", \"last_name\"]\n)\n\n# Add a validator to the computed property\nproxy.add_validator(\"full_name\", lambda v: \"Full name is required\" if not v else None)\n\n# Check validation errors\nerrors = proxy.validation_for(\"full_name\").get()\nprint(errors)  # Prints: ['Full name is required']\n\n# Fix the validation error\nproxy.observable(str, \"first_name\").set(\"Ada\")\nproxy.observable(str, \"last_name\").set(\"Lovelace\")\n\n# Check validation errors again\nerrors = proxy.validation_for(\"full_name\").get()\nprint(errors)  # Prints: []\n</code></pre>"},{"location":"reference/proxy/computed/#computed-fields-with-undoredo","title":"Computed Fields with Undo/Redo","text":"<p>Computed fields are automatically updated during undo and redo operations:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\n# Create a user\nuser = User(first_name=\"Ada\", last_name=\"Lovelace\")\n\n# Create a proxy with undo enabled\nproxy = ObservableProxy(user, undo=True)\n\n# Register a computed property for the full name\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    [\"first_name\", \"last_name\"]\n)\n\n# Get observables\nfirst_name = proxy.observable(str, \"first_name\")\nfull_name = proxy.computed(str, \"full_name\")\n\n# Make a change\nfirst_name.set(\"Grace\")  # full_name becomes \"Grace Lovelace\"\n\n# Undo the change\nproxy.undo(\"first_name\")  # full_name is automatically updated to \"Ada Lovelace\"\n</code></pre>"},{"location":"reference/proxy/computed/#advanced-computed-field-patterns","title":"Advanced Computed Field Patterns","text":""},{"location":"reference/proxy/computed/#filtering-and-sorting","title":"Filtering and Sorting","text":"<p>Computed fields can be used to filter and sort collections:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import List, Dict\n\n@dataclass\nclass TodoItem:\n    text: str\n    completed: bool\n\n@dataclass\nclass TodoList:\n    items: List[TodoItem]\n\n# Create a todo list\ntodo_list = TodoList(items=[\n    TodoItem(text=\"Buy groceries\", completed=False),\n    TodoItem(text=\"Clean house\", completed=True),\n    TodoItem(text=\"Write code\", completed=False)\n])\n\n# Create a proxy\nproxy = ObservableProxy(todo_list)\n\n# Register computed properties\nproxy.register_computed(\n    \"active_items\",\n    lambda: [item for item in proxy.observable_list(TodoItem, \"items\") if not item.completed],\n    [\"items\"]\n)\n\nproxy.register_computed(\n    \"completed_items\",\n    lambda: [item for item in proxy.observable_list(TodoItem, \"items\") if item.completed],\n    [\"items\"]\n)\n\nproxy.register_computed(\n    \"active_count\",\n    lambda: len(proxy.computed(list, \"active_items\").get()),\n    [\"active_items\"]\n)\n\nproxy.register_computed(\n    \"completed_count\",\n    lambda: len(proxy.computed(list, \"completed_items\").get()),\n    [\"completed_items\"]\n)\n\n# Access computed properties\nactive_items = proxy.computed(list, \"active_items\")\ncompleted_items = proxy.computed(list, \"completed_items\")\nactive_count = proxy.computed(int, \"active_count\")\ncompleted_count = proxy.computed(int, \"completed_count\")\n\nprint(f\"Active items: {[item.text for item in active_items.get()]}\")\n# Prints: Active items: ['Buy groceries', 'Write code']\n\nprint(f\"Completed items: {[item.text for item in completed_items.get()]}\")\n# Prints: Completed items: ['Clean house']\n\nprint(f\"Active count: {active_count.get()}\")  # Prints: Active count: 2\nprint(f\"Completed count: {completed_count.get()}\")  # Prints: Completed count: 1\n\n# Update an item\nitems = proxy.observable_list(TodoItem, \"items\")\nitems[0].completed = True\n\n# Computed properties are automatically updated\nprint(f\"Active items: {[item.text for item in active_items.get()]}\")\n# Prints: Active items: ['Write code']\n\nprint(f\"Completed items: {[item.text for item in completed_items.get()]}\")\n# Prints: Completed items: ['Buy groceries', 'Clean house']\n\nprint(f\"Active count: {active_count.get()}\")  # Prints: Active count: 1\nprint(f\"Completed count: {completed_count.get()}\")  # Prints: Completed count: 2\n</code></pre>"},{"location":"reference/proxy/computed/#aggregation-and-statistics","title":"Aggregation and Statistics","text":"<p>Computed fields can be used to calculate aggregations and statistics:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import List\nimport statistics\n\n@dataclass\nclass Student:\n    name: str\n    grades: List[int]\n\n@dataclass\nclass Classroom:\n    students: List[Student]\n\n# Create a classroom\nclassroom = Classroom(students=[\n    Student(name=\"Alice\", grades=[85, 90, 95]),\n    Student(name=\"Bob\", grades=[75, 80, 85]),\n    Student(name=\"Charlie\", grades=[95, 90, 100])\n])\n\n# Create a proxy\nproxy = ObservableProxy(classroom)\n\n# Register computed properties\nproxy.register_computed(\n    \"all_grades\",\n    lambda: [grade for student in proxy.observable_list(Student, \"students\") for grade in student.grades],\n    [\"students\"]\n)\n\nproxy.register_computed(\n    \"average_grade\",\n    lambda: statistics.mean(proxy.computed(list, \"all_grades\").get()) if proxy.computed(list, \"all_grades\").get() else 0,\n    [\"all_grades\"]\n)\n\nproxy.register_computed(\n    \"median_grade\",\n    lambda: statistics.median(proxy.computed(list, \"all_grades\").get()) if proxy.computed(list, \"all_grades\").get() else 0,\n    [\"all_grades\"]\n)\n\nproxy.register_computed(\n    \"top_student\",\n    lambda: max(proxy.observable_list(Student, \"students\"), key=lambda s: statistics.mean(s.grades)).name if proxy.observable_list(Student, \"students\") else \"\",\n    [\"students\"]\n)\n\n# Access computed properties\nall_grades = proxy.computed(list, \"all_grades\")\naverage_grade = proxy.computed(float, \"average_grade\")\nmedian_grade = proxy.computed(float, \"median_grade\")\ntop_student = proxy.computed(str, \"top_student\")\n\nprint(f\"All grades: {all_grades.get()}\")\n# Prints: All grades: [85, 90, 95, 75, 80, 85, 95, 90, 100]\n\nprint(f\"Average grade: {average_grade.get()}\")  # Prints: Average grade: 88.33\nprint(f\"Median grade: {median_grade.get()}\")  # Prints: Median grade: 90.0\nprint(f\"Top student: {top_student.get()}\")  # Prints: Top student: Charlie\n\n# Update a student's grades\nstudents = proxy.observable_list(Student, \"students\")\nstudents[1].grades = [95, 100, 100]\n\n# Computed properties are automatically updated\nprint(f\"Average grade: {average_grade.get()}\")  # Prints: Average grade: 94.44\nprint(f\"Median grade: {median_grade.get()}\")  # Prints: Median grade: 95.0\nprint(f\"Top student: {top_student.get()}\")  # Prints: Top student: Bob\n</code></pre>"},{"location":"reference/proxy/computed/#api-reference","title":"API Reference","text":""},{"location":"reference/proxy/computed/#register_computed","title":"<code>register_computed()</code>","text":"<pre><code>def register_computed(\n    self,\n    attr: str,\n    compute_fn: Callable[[], T],\n    dependencies: list[str],\n) -&gt; None\n</code></pre> <p>Registers a computed field.</p> <ul> <li><code>attr</code>: The name of the computed field</li> <li><code>compute_fn</code>: A function that computes the value of the field</li> <li><code>dependencies</code>: A list of field names that the computed field depends on</li> </ul>"},{"location":"reference/proxy/computed/#computed","title":"<code>computed()</code>","text":"<pre><code>def computed(self, type_: Type[T], attr: str) -&gt; IObservable[T]\n</code></pre> <p>Gets an observable for a computed field.</p> <ul> <li><code>type_</code>: The type of the computed field</li> <li><code>attr</code>: The name of the computed field</li> </ul>"},{"location":"reference/proxy/computed/#has_computed","title":"<code>has_computed()</code>","text":"<pre><code>def has_computed(self, attr: str) -&gt; bool\n</code></pre> <p>Checks if a computed field exists.</p> <ul> <li><code>attr</code>: The name of the computed field</li> </ul>"},{"location":"reference/proxy/sync/","title":"Syncing &amp; Dirty State","text":"<p><code>ObservableProxy</code> provides features for tracking which fields have been modified (dirty state) and synchronizing changes back to the original object. This page explains how to use these features.</p>"},{"location":"reference/proxy/sync/#dirty-state-tracking","title":"Dirty State Tracking","text":"<p>When you modify a field in an <code>ObservableProxy</code>, it keeps track of which fields have been changed. You can check if a field is dirty (has been modified) using the <code>is_dirty()</code> method.</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user\nuser = User(name=\"Ada\", age=36)\n\n# Create a proxy\nproxy = ObservableProxy(user)\n\n# Check if the proxy is dirty\nprint(proxy.is_dirty())  # Prints: False\n\n# Modify a field\nproxy.observable(str, \"name\").set(\"Grace\")\n\n# Check if the proxy is dirty\nprint(proxy.is_dirty())  # Prints: True\n\n# Check if a specific field is dirty\nprint(proxy.is_dirty(\"name\"))  # Prints: True\nprint(proxy.is_dirty(\"age\"))  # Prints: False\n</code></pre>"},{"location":"reference/proxy/sync/#dirty-state-for-collections","title":"Dirty State for Collections","text":"<p>Dirty state tracking also works for list and dictionary fields:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import List, Dict\n\n@dataclass\nclass User:\n    name: str\n    friends: List[str]\n    preferences: Dict[str, str]\n\n# Create a user\nuser = User(\n    name=\"Ada\",\n    friends=[\"Charles\", \"Grace\"],\n    preferences={\"theme\": \"dark\"}\n)\n\n# Create a proxy\nproxy = ObservableProxy(user)\n\n# Modify a list field\nfriends = proxy.observable_list(str, \"friends\")\nfriends.append(\"Alan\")\n\n# Check if the list field is dirty\nprint(proxy.is_dirty(\"friends\"))  # Prints: True\n\n# Modify a dictionary field\nprefs = proxy.observable_dict((str, str), \"preferences\")\nprefs[\"notifications\"] = \"on\"\n\n# Check if the dictionary field is dirty\nprint(proxy.is_dirty(\"preferences\"))  # Prints: True\n</code></pre>"},{"location":"reference/proxy/sync/#dirty-state-observable","title":"Dirty State Observable","text":"<p>You can also get an observable that tracks the dirty state of the proxy or a specific field:</p> <pre><code># Get an observable for the dirty state of the entire proxy\nis_dirty = proxy.dirty()\nis_dirty.on_change(lambda dirty: print(f\"Proxy is {'dirty' if dirty else 'clean'}\"))\n\n# Get an observable for the dirty state of a specific field\nname_dirty = proxy.dirty_for(\"name\")\nname_dirty.on_change(lambda dirty: print(f\"Name is {'dirty' if dirty else 'clean'}\"))\n\n# Modify a field\nproxy.observable(str, \"name\").set(\"Grace\")  # Prints: Name is dirty, Proxy is dirty\n</code></pre>"},{"location":"reference/proxy/sync/#saving-changes","title":"Saving Changes","text":"<p>You can save the changes made to the proxy back to the original object using the <code>save_to()</code> method:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user\nuser = User(name=\"Ada\", age=36)\n\n# Create a proxy\nproxy = ObservableProxy(user)\n\n# Modify a field\nproxy.observable(str, \"name\").set(\"Grace\")\n\n# Save changes back to the original object\nproxy.save_to(user)\n\nprint(user)  # Prints: User(name='Grace', age=36)\n\n# The proxy is no longer dirty after saving\nprint(proxy.is_dirty())  # Prints: False\n</code></pre> <p>You can also save changes to a different object:</p> <pre><code># Create a new user\nnew_user = User(name=\"\", age=0)\n\n# Save changes to the new user\nproxy.save_to(new_user)\n\nprint(new_user)  # Prints: User(name='Grace', age=36)\n</code></pre>"},{"location":"reference/proxy/sync/#automatic-syncing","title":"Automatic Syncing","text":"<p>You can enable automatic syncing when creating the proxy. When sync is enabled, changes are immediately synced back to the original object:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user\nuser = User(name=\"Ada\", age=36)\n\n# Create a proxy with sync enabled\nproxy = ObservableProxy(user, sync=True)\n\n# Modify a field\nproxy.observable(str, \"name\").set(\"Grace\")\n\n# The change is immediately synced to the original object\nprint(user)  # Prints: User(name='Grace', age=36)\n</code></pre> <p>Note</p> <p>Even with sync enabled, the proxy still tracks dirty state. The dirty state is reset when you call <code>save_to()</code> or when you create a new proxy.</p>"},{"location":"reference/proxy/sync/#resetting-changes","title":"Resetting Changes","text":"<p>You can reset changes made to the proxy using the <code>reset()</code> method:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user\nuser = User(name=\"Ada\", age=36)\n\n# Create a proxy\nproxy = ObservableProxy(user)\n\n# Modify a field\nproxy.observable(str, \"name\").set(\"Grace\")\n\n# Reset changes\nproxy.reset()\n\n# The field is back to its original value\nprint(proxy.observable(str, \"name\").get())  # Prints: Ada\n\n# The proxy is no longer dirty\nprint(proxy.is_dirty())  # Prints: False\n</code></pre> <p>You can also reset a specific field:</p> <pre><code># Modify multiple fields\nproxy.observable(str, \"name\").set(\"Grace\")\nproxy.observable(int, \"age\").set(52)\n\n# Reset only the name field\nproxy.reset(\"name\")\n\n# The name field is back to its original value\nprint(proxy.observable(str, \"name\").get())  # Prints: Ada\n\n# The age field is still modified\nprint(proxy.observable(int, \"age\").get())  # Prints: 52\n\n# The proxy is still dirty because the age field is modified\nprint(proxy.is_dirty())  # Prints: True\nprint(proxy.is_dirty(\"name\"))  # Prints: False\nprint(proxy.is_dirty(\"age\"))  # Prints: True\n</code></pre>"},{"location":"reference/proxy/sync/#dirty-state-with-validation","title":"Dirty State with Validation","text":"<p>Dirty state tracking works with validation. You can check if a field is both dirty and valid:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    username: str\n    email: str\n\n# Create a user\nuser = User(username=\"ada\", email=\"ada@example.com\")\n\n# Create a proxy\nproxy = ObservableProxy(user)\n\n# Add validators\nproxy.add_validator(\"username\", lambda v: \"Username is required\" if not v else None)\nproxy.add_validator(\"email\", lambda v: \"Email is required\" if not v else None)\nproxy.add_validator(\"email\", lambda v: \"Invalid email\" if v and \"@\" not in v else None)\n\n# Modify a field with a valid value\nproxy.observable(str, \"username\").set(\"grace\")\n\n# The field is dirty and valid\nprint(proxy.is_dirty(\"username\"))  # Prints: True\nprint(proxy.validation_for(\"username\").get())  # Prints: []\n\n# Modify a field with an invalid value\nproxy.observable(str, \"email\").set(\"grace\")\n\n# The field is dirty and invalid\nprint(proxy.is_dirty(\"email\"))  # Prints: True\nprint(proxy.validation_for(\"email\").get())  # Prints: ['Invalid email']\n\n# Check if the entire proxy is valid\nprint(proxy.is_valid().get())  # Prints: False\n</code></pre>"},{"location":"reference/proxy/sync/#dirty-state-with-undoredo","title":"Dirty State with Undo/Redo","text":"<p>Dirty state tracking works with undo/redo. When you undo a change, the field is no longer dirty if it's back to its original value:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user\nuser = User(name=\"Ada\", age=36)\n\n# Create a proxy with undo enabled\nproxy = ObservableProxy(user, undo=True)\n\n# Modify a field\nproxy.observable(str, \"name\").set(\"Grace\")\n\n# The field is dirty\nprint(proxy.is_dirty(\"name\"))  # Prints: True\n\n# Undo the change\nproxy.undo(\"name\")\n\n# The field is no longer dirty\nprint(proxy.is_dirty(\"name\"))  # Prints: False\n\n# Redo the change\nproxy.redo(\"name\")\n\n# The field is dirty again\nprint(proxy.is_dirty(\"name\"))  # Prints: True\n</code></pre>"},{"location":"reference/proxy/sync/#advanced-syncing-patterns","title":"Advanced Syncing Patterns","text":""},{"location":"reference/proxy/sync/#form-editing","title":"Form Editing","text":"<p>You can use dirty state tracking to implement form editing with save and cancel buttons:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass UserProfile:\n    username: str\n    email: str\n    bio: str\n\nclass ProfileEditor:\n    def __init__(self, profile: UserProfile):\n        self.original_profile = profile\n        self.proxy = ObservableProxy(profile)\n\n        # Add validators\n        self.proxy.add_validator(\"username\", lambda v: \"Username is required\" if not v else None)\n        self.proxy.add_validator(\"email\", lambda v: \"Email is required\" if not v else None)\n        self.proxy.add_validator(\"email\", lambda v: \"Invalid email\" if v and \"@\" not in v else None)\n\n        # Track dirty state\n        self.is_dirty = self.proxy.dirty()\n        self.is_valid = self.proxy.is_valid()\n\n        # Update save button state when dirty or valid state changes\n        self.is_dirty.on_change(self._update_save_button)\n        self.is_valid.on_change(self._update_save_button)\n\n    def _update_save_button(self, _):\n        # Enable save button only if the form is dirty and valid\n        save_enabled = self.is_dirty.get() and self.is_valid.get()\n        print(f\"Save button {'enabled' if save_enabled else 'disabled'}\")\n\n    def save(self):\n        \"\"\"Save changes to the original profile.\"\"\"\n        if self.is_dirty.get() and self.is_valid.get():\n            self.proxy.save_to(self.original_profile)\n            print(\"Changes saved\")\n            return True\n        return False\n\n    def cancel(self):\n        \"\"\"Cancel changes and reset the form.\"\"\"\n        self.proxy.reset()\n        print(\"Changes cancelled\")\n\n    def get_field(self, field_name: str, field_type: type):\n        \"\"\"Get an observable for a field.\"\"\"\n        return self.proxy.observable(field_type, field_name)\n\n# Usage\nprofile = UserProfile(username=\"ada\", email=\"ada@example.com\", bio=\"\")\neditor = ProfileEditor(profile)\n\n# Modify fields\neditor.get_field(\"username\", str).set(\"grace\")\neditor.get_field(\"email\", str).set(\"grace@example.com\")\neditor.get_field(\"bio\", str).set(\"Computer scientist\")\n\n# Save changes\neditor.save()\n\n# Check the original profile\nprint(profile)  # Prints: UserProfile(username='grace', email='grace@example.com', bio='Computer scientist')\n</code></pre>"},{"location":"reference/proxy/sync/#dirty-state-with-collections","title":"Dirty State with Collections","text":"<p>You can use dirty state tracking with collections to implement complex editing scenarios:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass TodoItem:\n    text: str\n    completed: bool\n\n@dataclass\nclass TodoList:\n    items: List[TodoItem]\n\nclass TodoListEditor:\n    def __init__(self, todo_list: TodoList):\n        self.original_list = todo_list\n        self.proxy = ObservableProxy(todo_list)\n\n        # Get the observable list\n        self.items = self.proxy.observable_list(TodoItem, \"items\")\n\n        # Track dirty state\n        self.is_dirty = self.proxy.dirty()\n        self.is_dirty.on_change(lambda dirty: print(f\"Todo list is {'dirty' if dirty else 'clean'}\"))\n\n    def add_item(self, text: str):\n        \"\"\"Add a new item to the list.\"\"\"\n        self.items.append(TodoItem(text=text, completed=False))\n\n    def toggle_item(self, index: int):\n        \"\"\"Toggle the completed state of an item.\"\"\"\n        item = self.items[index]\n        item_proxy = ObservableProxy(item)\n        completed = item_proxy.observable(bool, \"completed\")\n        completed.set(not completed.get())\n        item_proxy.save_to(item)\n\n    def remove_item(self, index: int):\n        \"\"\"Remove an item from the list.\"\"\"\n        self.items.pop(index)\n\n    def save(self):\n        \"\"\"Save changes to the original list.\"\"\"\n        if self.is_dirty.get():\n            self.proxy.save_to(self.original_list)\n            print(\"Changes saved\")\n            return True\n        return False\n\n    def cancel(self):\n        \"\"\"Cancel changes and reset the list.\"\"\"\n        self.proxy.reset()\n        print(\"Changes cancelled\")\n\n# Usage\ntodo_list = TodoList(items=[\n    TodoItem(text=\"Buy groceries\", completed=False),\n    TodoItem(text=\"Clean house\", completed=True)\n])\neditor = TodoListEditor(todo_list)\n\n# Modify the list\neditor.add_item(\"Write code\")\neditor.toggle_item(0)  # Toggle \"Buy groceries\" to completed\neditor.remove_item(1)  # Remove \"Clean house\"\n\n# Save changes\neditor.save()\n\n# Check the original list\nprint(todo_list)  # Prints: TodoList(items=[TodoItem(text='Buy groceries', completed=True), TodoItem(text='Write code', completed=False)])\n</code></pre>"},{"location":"reference/proxy/sync/#api-reference","title":"API Reference","text":""},{"location":"reference/proxy/sync/#dirty-state-methods","title":"Dirty State Methods","text":""},{"location":"reference/proxy/sync/#is_dirty","title":"<code>is_dirty()</code>","text":"<pre><code>def is_dirty(self, attr: str | None = None) -&gt; bool\n</code></pre> <p>Checks if the proxy or a specific field is dirty.</p> <ul> <li><code>attr</code>: The field name to check. If None, checks if any field is dirty.</li> </ul>"},{"location":"reference/proxy/sync/#dirty","title":"<code>dirty()</code>","text":"<pre><code>def dirty(self) -&gt; IObservable[bool]\n</code></pre> <p>Gets an observable that indicates whether any field is dirty.</p>"},{"location":"reference/proxy/sync/#dirty_for","title":"<code>dirty_for()</code>","text":"<pre><code>def dirty_for(self, attr: str) -&gt; IObservable[bool]\n</code></pre> <p>Gets an observable that indicates whether a specific field is dirty.</p> <ul> <li><code>attr</code>: The field name to check.</li> </ul>"},{"location":"reference/proxy/sync/#syncing-methods","title":"Syncing Methods","text":""},{"location":"reference/proxy/sync/#save_to","title":"<code>save_to()</code>","text":"<pre><code>def save_to(self, obj: T) -&gt; None\n</code></pre> <p>Saves changes to an object.</p> <ul> <li><code>obj</code>: The object to save changes to.</li> </ul>"},{"location":"reference/proxy/sync/#reset","title":"<code>reset()</code>","text":"<pre><code>def reset(self, attr: str | None = None) -&gt; None\n</code></pre> <p>Resets changes made to the proxy.</p> <ul> <li><code>attr</code>: The field name to reset. If None, resets all fields.</li> </ul>"},{"location":"reference/proxy/sync/#constructor-options","title":"Constructor Options","text":"<pre><code>ObservableProxy(\n    obj: T,\n    *,\n    sync: bool = False,\n)\n</code></pre> <ul> <li><code>sync</code>: If True, changes are immediately synced back to the original object.</li> </ul>"},{"location":"reference/proxy/undo/","title":"Undo/Redo","text":"<p><code>ObservableProxy</code> provides built-in support for undo and redo operations, allowing users to track and revert changes to any field. This page explains how to use the undo/redo features.</p>"},{"location":"reference/proxy/undo/#enabling-undoredo","title":"Enabling Undo/Redo","text":"<p>Undo/redo functionality is disabled by default. You can enable it globally when creating the proxy:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    age: int\n    preferences: dict[str, str]\n    friends: list[str]\n\n# Create a user\nuser = User(\n    name=\"Ada\",\n    age=36,\n    preferences={\"theme\": \"dark\"},\n    friends=[\"Charles\", \"Grace\"]\n)\n\n# Create a proxy with undo enabled\nproxy = ObservableProxy(user, undo=True)\n</code></pre> <p>You can also configure the maximum number of undo steps and debounce time:</p> <pre><code># Create a proxy with undo enabled and custom settings\nproxy = ObservableProxy(\n    user,\n    undo=True,\n    undo_max=50,  # Store up to 50 undo steps (default is 100)\n    undo_debounce_ms=500  # Group changes within 500ms (default is None)\n)\n</code></pre>"},{"location":"reference/proxy/undo/#basic-undoredo","title":"Basic Undo/Redo","text":"<p>Once undo is enabled, you can undo and redo changes to any field:</p> <pre><code># Get an observable for a field\nname = proxy.observable(str, \"name\")\n\n# Make some changes\nname.set(\"Grace\")\nname.set(\"Alan\")\n\n# Undo the last change\nproxy.undo(\"name\")  # name is now \"Grace\"\n\n# Redo the undone change\nproxy.redo(\"name\")  # name is now \"Alan\"\n</code></pre>"},{"location":"reference/proxy/undo/#checking-undoredo-availability","title":"Checking Undo/Redo Availability","text":"<p>You can check if undo or redo operations are available for a field:</p> <pre><code># Check if undo is available\nif proxy.can_undo(\"name\"):\n    proxy.undo(\"name\")\n\n# Check if redo is available\nif proxy.can_redo(\"name\"):\n    proxy.redo(\"name\")\n</code></pre>"},{"location":"reference/proxy/undo/#undoredo-for-collections","title":"Undo/Redo for Collections","text":"<p>Undo/redo works for list and dictionary fields as well:</p>"},{"location":"reference/proxy/undo/#lists","title":"Lists","text":"<pre><code># Get an observable list\nfriends = proxy.observable_list(str, \"friends\")\n\n# Make some changes\nfriends.append(\"Alan\")\nfriends.pop(0)  # Remove \"Charles\"\n\n# Undo the last change\nproxy.undo(\"friends\")  # \"Charles\" is back\n\n# Redo the undone change\nproxy.redo(\"friends\")  # \"Charles\" is removed again\n</code></pre>"},{"location":"reference/proxy/undo/#dictionaries","title":"Dictionaries","text":"<pre><code># Get an observable dictionary\nprefs = proxy.observable_dict((str, str), \"preferences\")\n\n# Make some changes\nprefs[\"theme\"] = \"light\"\nprefs[\"notifications\"] = \"on\"\n\n# Undo the last change\nproxy.undo(\"preferences\")  # \"notifications\" is removed\n\n# Redo the undone change\nproxy.redo(\"preferences\")  # \"notifications\" is back\n</code></pre>"},{"location":"reference/proxy/undo/#configuring-undoredo-for-specific-fields","title":"Configuring Undo/Redo for Specific Fields","text":"<p>You can configure undo/redo settings for specific fields:</p> <pre><code># Enable undo for a specific field\nproxy.set_undo_config(\"name\", enabled=True)\n\n# Disable undo for a specific field\nproxy.set_undo_config(\"age\", enabled=False)\n\n# Set custom undo settings for a field\nproxy.set_undo_config(\n    \"preferences\",\n    enabled=True,\n    undo_max=20,\n    undo_debounce_ms=1000\n)\n</code></pre> <p>You can also set undo configuration when getting an observable:</p> <pre><code># Get an observable with custom undo settings\nname = proxy.observable(\n    str,\n    \"name\",\n    undo_max=10,\n    undo_debounce_ms=200\n)\n</code></pre>"},{"location":"reference/proxy/undo/#debouncing-changes","title":"Debouncing Changes","text":"<p>When debounce is enabled, changes made within the debounce window are grouped into a single undo step:</p> <pre><code># Create a proxy with debouncing\nproxy = ObservableProxy(user, undo=True, undo_debounce_ms=500)\n\n# Get an observable\nname = proxy.observable(str, \"name\")\n\n# Make rapid changes\nname.set(\"Grace\")\nname.set(\"Alan\")\nname.set(\"John\")  # All within 500ms\n\n# Undo will revert all changes in one step\nproxy.undo(\"name\")  # name is back to \"Ada\"\n</code></pre> <p>This is particularly useful for fields that might change rapidly, such as text fields during typing.</p>"},{"location":"reference/proxy/undo/#undoredo-with-validation","title":"Undo/Redo with Validation","text":"<p>Undo/redo operations automatically trigger validation:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    username: str\n\n# Create a proxy with undo enabled\nuser = User(username=\"alice\")\nproxy = ObservableProxy(user, undo=True)\n\n# Add a validator\nproxy.add_validator(\"username\", lambda v: \"Username is required\" if not v else None)\n\n# Get the observable\nusername = proxy.observable(str, \"username\")\n\n# Make a change that will be valid\nusername.set(\"bob\")  # Valid\n\n# Make a change that will be invalid\nusername.set(\"\")  # Invalid\n\n# Undo to the valid state\nproxy.undo(\"username\")  # Validation will be triggered, and the proxy will be valid again\n\n# Check validation state\nis_valid = proxy.is_valid().get()  # True\n</code></pre>"},{"location":"reference/proxy/undo/#undoredo-with-computed-fields","title":"Undo/Redo with Computed Fields","text":"<p>Computed fields are automatically updated during undo/redo operations:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\n# Create a proxy with undo enabled\nuser = User(first_name=\"Ada\", last_name=\"Lovelace\")\nproxy = ObservableProxy(user, undo=True)\n\n# Register a computed property\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    [\"first_name\", \"last_name\"]\n)\n\n# Get observables\nfirst_name = proxy.observable(str, \"first_name\")\nfull_name = proxy.computed(str, \"full_name\")\n\n# Make a change\nfirst_name.set(\"Grace\")  # full_name becomes \"Grace Lovelace\"\n\n# Undo the change\nproxy.undo(\"first_name\")  # full_name is automatically updated to \"Ada Lovelace\"\n</code></pre>"},{"location":"reference/proxy/undo/#undoredo-with-sync","title":"Undo/Redo with Sync","text":"<p>When using undo/redo with sync enabled, changes are immediately synced back to the original object:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n\n# Create a user\nuser = User(name=\"Ada\")\n\n# Create a proxy with undo and sync enabled\nproxy = ObservableProxy(user, undo=True, sync=True)\n\n# Get an observable\nname = proxy.observable(str, \"name\")\n\n# Make a change\nname.set(\"Grace\")  # user.name is now \"Grace\"\n\n# Undo the change\nproxy.undo(\"name\")  # user.name is now \"Ada\" again\n\n# Redo the change\nproxy.redo(\"name\")  # user.name is now \"Grace\" again\n</code></pre> <p>Warning</p> <p>Using sync=True with undo=True may cause unexpected model mutations during undo/redo. Consider using sync=False and explicitly calling save_to() when needed.</p>"},{"location":"reference/proxy/undo/#advanced-undoredo-patterns","title":"Advanced Undo/Redo Patterns","text":""},{"location":"reference/proxy/undo/#implementing-a-history-stack","title":"Implementing a History Stack","text":"<p>You can implement a global undo/redo stack by tracking which fields have been modified:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Set, Tuple\n\n@dataclass\nclass Document:\n    title: str\n    content: str\n    tags: List[str]\n\nclass DocumentEditor:\n    def __init__(self, document: Document):\n        self.document = document\n        self.proxy = ObservableProxy(document, undo=True)\n\n        # Track which fields have been modified\n        self.modified_fields: List[Tuple[str, int]] = []  # (field_name, timestamp)\n\n        # Set up change tracking for all fields\n        self._track_field(\"title\")\n        self._track_field(\"content\")\n        self._track_field(\"tags\")\n\n    def _track_field(self, field_name: str):\n        # Get the appropriate observable based on field type\n        if field_name == \"tags\":\n            obs = self.proxy.observable_list(str, field_name)\n        else:\n            obs = self.proxy.observable(str, field_name)\n\n        # Track changes\n        obs.on_change(lambda _: self._on_field_changed(field_name))\n\n    def _on_field_changed(self, field_name: str):\n        import time\n        # Add the field to the modified list with current timestamp\n        self.modified_fields.append((field_name, int(time.time() * 1000)))\n\n    def undo(self):\n        \"\"\"Undo the most recent change.\"\"\"\n        if not self.modified_fields:\n            return False\n\n        # Get the most recently modified field\n        field_name, _ = self.modified_fields.pop()\n\n        # Undo the change to that field\n        if self.proxy.can_undo(field_name):\n            self.proxy.undo(field_name)\n            return True\n\n        return False\n\n    def save(self):\n        \"\"\"Save changes back to the document.\"\"\"\n        self.proxy.save_to(self.document)\n        # Clear the modified fields list after saving\n        self.modified_fields.clear()\n\n# Usage\ndoc = Document(title=\"Draft\", content=\"Hello world\", tags=[\"draft\"])\neditor = DocumentEditor(doc)\n\n# Make some changes\neditor.proxy.observable(str, \"title\").set(\"Final\")\neditor.proxy.observable(str, \"content\").set(\"Hello, world!\")\neditor.proxy.observable_list(str, \"tags\").append(\"final\")\n\n# Undo the most recent change (to tags)\neditor.undo()  # Removes \"final\" from tags\n\n# Undo the next most recent change (to content)\neditor.undo()  # Content is back to \"Hello world\"\n\n# Save changes\neditor.save()\n</code></pre>"},{"location":"reference/proxy/undo/#implementing-undoredo-buttons","title":"Implementing Undo/Redo Buttons","text":"<p>You can implement undo/redo buttons in a UI application:</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\nimport tkinter as tk\nfrom typing import Set\n\n@dataclass\nclass TextDocument:\n    content: str\n\nclass TextEditor:\n    def __init__(self, root, document: TextDocument):\n        self.document = document\n        self.proxy = ObservableProxy(document, undo=True, undo_debounce_ms=500)\n\n        # Create UI\n        self.root = root\n        self.root.title(\"Text Editor\")\n\n        # Create toolbar\n        toolbar = tk.Frame(root)\n        toolbar.pack(side=tk.TOP, fill=tk.X)\n\n        # Create undo/redo buttons\n        self.undo_button = tk.Button(toolbar, text=\"Undo\", command=self.undo)\n        self.undo_button.pack(side=tk.LEFT)\n        self.redo_button = tk.Button(toolbar, text=\"Redo\", command=self.redo)\n        self.redo_button.pack(side=tk.LEFT)\n\n        # Create text area\n        self.text_area = tk.Text(root)\n        self.text_area.pack(fill=tk.BOTH, expand=True)\n        self.text_area.insert(tk.END, document.content)\n\n        # Bind text changes\n        self.text_area.bind(\"&lt;&lt;Modified&gt;&gt;\", self.on_text_changed)\n\n        # Track if we're currently updating from the model\n        self.updating_from_model = False\n\n        # Update button states\n        self.update_button_states()\n\n        # Set up content observable\n        self.content_obs = self.proxy.observable(str, \"content\")\n        self.content_obs.on_change(self.update_text_area)\n\n    def on_text_changed(self, event):\n        if not self.updating_from_model:\n            content = self.text_area.get(\"1.0\", tk.END).rstrip()\n            self.content_obs.set(content)\n            self.update_button_states()\n        self.text_area.edit_modified(False)\n\n    def update_text_area(self, content):\n        self.updating_from_model = True\n        self.text_area.delete(\"1.0\", tk.END)\n        self.text_area.insert(\"1.0\", content)\n        self.updating_from_model = False\n        self.update_button_states()\n\n    def undo(self):\n        if self.proxy.can_undo(\"content\"):\n            self.proxy.undo(\"content\")\n            self.update_button_states()\n\n    def redo(self):\n        if self.proxy.can_redo(\"content\"):\n            self.proxy.redo(\"content\")\n            self.update_button_states()\n\n    def update_button_states(self):\n        self.undo_button[\"state\"] = tk.NORMAL if self.proxy.can_undo(\"content\") else tk.DISABLED\n        self.redo_button[\"state\"] = tk.NORMAL if self.proxy.can_redo(\"content\") else tk.DISABLED\n\n    def save(self):\n        self.proxy.save_to(self.document)\n\n# Usage\nif __name__ == \"__main__\":\n    root = tk.Tk()\n    doc = TextDocument(content=\"Hello, world!\")\n    editor = TextEditor(root, doc)\n    root.mainloop()\n</code></pre>"},{"location":"reference/proxy/undo/#api-reference","title":"API Reference","text":""},{"location":"reference/proxy/undo/#constructor-options","title":"Constructor Options","text":"<pre><code>ObservableProxy(\n    obj: T,\n    *,\n    undo: bool = False,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n)\n</code></pre> <ul> <li><code>undo</code>: If True, enables undo/redo functionality for all fields</li> <li><code>undo_max</code>: Maximum number of undo steps to store (None means unlimited)</li> <li><code>undo_debounce_ms</code>: Time window in milliseconds to group changes (None means no debouncing)</li> </ul>"},{"location":"reference/proxy/undo/#undoredo-methods","title":"Undo/Redo Methods","text":""},{"location":"reference/proxy/undo/#undo","title":"<code>undo()</code>","text":"<pre><code>def undo(self, attr: str) -&gt; None\n</code></pre> <p>Undoes the most recent change to a field.</p> <ul> <li><code>attr</code>: The field name to undo changes for</li> </ul>"},{"location":"reference/proxy/undo/#redo","title":"<code>redo()</code>","text":"<pre><code>def redo(self, attr: str) -&gt; None\n</code></pre> <p>Redoes the most recently undone change to a field.</p> <ul> <li><code>attr</code>: The field name to redo changes for</li> </ul>"},{"location":"reference/proxy/undo/#can_undo","title":"<code>can_undo()</code>","text":"<pre><code>def can_undo(self, attr: str) -&gt; bool\n</code></pre> <p>Checks if there are changes that can be undone for a field.</p> <ul> <li><code>attr</code>: The field name to check</li> </ul>"},{"location":"reference/proxy/undo/#can_redo","title":"<code>can_redo()</code>","text":"<pre><code>def can_redo(self, attr: str) -&gt; bool\n</code></pre> <p>Checks if there are changes that can be redone for a field.</p> <ul> <li><code>attr</code>: The field name to check</li> </ul>"},{"location":"reference/proxy/undo/#set_undo_config","title":"<code>set_undo_config()</code>","text":"<pre><code>def set_undo_config(\n    self,\n    attr: str,\n    *,\n    enabled: bool | None = None,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; None\n</code></pre> <p>Sets the undo configuration for a specific field.</p> <ul> <li><code>attr</code>: The field name to configure</li> <li><code>enabled</code>: Whether undo/redo functionality is enabled for this field</li> <li><code>undo_max</code>: Maximum number of undo steps to store</li> <li><code>undo_debounce_ms</code>: Time window in milliseconds to group changes</li> </ul>"},{"location":"reference/proxy/validation/","title":"Validation","text":"<p><code>ObservableProxy</code> provides a powerful validation system that allows you to ensure data integrity by adding validators to fields. This page explains how to use validation features.</p>"},{"location":"reference/proxy/validation/#basic-validation","title":"Basic Validation","text":"<p>You can add validators to any field in an <code>ObservableProxy</code>. A validator is a function that takes a value and returns an error message (as a string) if the value is invalid, or <code>None</code> if the value is valid.</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    username: str\n    email: str\n    age: int\n\n# Create a user\nuser = User(username=\"\", email=\"\", age=0)\n\n# Create a proxy\nproxy = ObservableProxy(user)\n\n# Add validators\nproxy.add_validator(\"username\", lambda v: \"Username is required\" if not v else None)\nproxy.add_validator(\"username\", lambda v: \"Username too short\" if len(v) &lt; 3 else None)\nproxy.add_validator(\"email\", lambda v: \"Email is required\" if not v else None)\nproxy.add_validator(\"email\", lambda v: \"Invalid email\" if v and \"@\" not in v else None)\nproxy.add_validator(\"age\", lambda v: \"Age must be positive\" if v &lt;= 0 else None)\n\n# Check if the proxy is valid\nif not proxy.is_valid().get():\n    print(\"User is invalid\")\n</code></pre>"},{"location":"reference/proxy/validation/#multiple-validators","title":"Multiple Validators","text":"<p>You can add multiple validators to a single field. All validators will be run, and all error messages will be collected.</p> <pre><code># Add multiple validators to a field\nproxy.add_validator(\"password\", lambda v: \"Password is required\" if not v else None)\nproxy.add_validator(\"password\", lambda v: \"Password too short\" if len(v) &lt; 8 else None)\nproxy.add_validator(\"password\", lambda v: \"Password needs a number\" if not any(c.isdigit() for c in v) else None)\nproxy.add_validator(\"password\", lambda v: \"Password needs a special character\" if not any(c in \"!@#$%^&amp;*\" for c in v) else None)\n\n# Set an invalid password\nproxy.observable(str, \"password\").set(\"abc\")\n\n# Get all validation errors for the password field\nerrors = proxy.validation_for(\"password\").get()\nprint(errors)  # ['Password too short', 'Password needs a number', 'Password needs a special character']\n</code></pre>"},{"location":"reference/proxy/validation/#validation-events","title":"Validation Events","text":"<p>You can listen for changes to the validation state of the entire proxy or individual fields.</p> <pre><code># Listen for changes to the overall validation state\nproxy.is_valid().on_change(lambda valid: print(f\"Form is {'valid' if valid else 'invalid'}\"))\n\n# Listen for changes to validation errors for a specific field\nproxy.validation_for(\"username\").on_change(\n    lambda errors: print(f\"Username errors: {errors}\")\n)\n\n# Listen for all validation errors\nproxy.validation_errors().on_change(\n    lambda errors_dict: print(f\"All errors: {errors_dict}\")\n)\n</code></pre>"},{"location":"reference/proxy/validation/#validating-collections","title":"Validating Collections","text":"<p>You can also validate list and dictionary fields.</p>"},{"location":"reference/proxy/validation/#validating-lists","title":"Validating Lists","text":"<pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass TodoList:\n    items: List[str]\n\ntodo_list = TodoList(items=[])\nproxy = ObservableProxy(todo_list)\n\n# Validate the entire list\nproxy.add_validator(\"items\", lambda items: \"List cannot be empty\" if len(items) == 0 else None)\n\n# Validate individual items in the list\nproxy.add_validator(\"items\", lambda items: \"All items must be non-empty\" if any(not item for item in items) else None)\n\n# Get the observable list\nitems = proxy.observable_list(str, \"items\")\n\n# Add some items\nitems.append(\"Buy groceries\")\nitems.append(\"\")  # This will trigger the \"All items must be non-empty\" validator\n\n# Check validation errors\nerrors = proxy.validation_for(\"items\").get()\nprint(errors)  # ['All items must be non-empty']\n</code></pre>"},{"location":"reference/proxy/validation/#validating-dictionaries","title":"Validating Dictionaries","text":"<pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import Dict\n\n@dataclass\nclass Settings:\n    preferences: Dict[str, str]\n\nsettings = Settings(preferences={})\nproxy = ObservableProxy(settings)\n\n# Validate the entire dictionary\nproxy.add_validator(\"preferences\", lambda prefs: \"Theme must be set\" if \"theme\" not in prefs else None)\n\n# Validate specific values in the dictionary\nproxy.add_validator(\"preferences\", lambda prefs: \"Invalid theme\" if prefs.get(\"theme\") not in [\"light\", \"dark\"] else None)\n\n# Get the observable dictionary\nprefs = proxy.observable_dict((str, str), \"preferences\")\n\n# Set some preferences\nprefs[\"notifications\"] = \"on\"  # This will trigger the \"Theme must be set\" validator\nprefs[\"theme\"] = \"blue\"  # This will trigger the \"Invalid theme\" validator\n\n# Check validation errors\nerrors = proxy.validation_for(\"preferences\").get()\nprint(errors)  # ['Invalid theme']\n</code></pre>"},{"location":"reference/proxy/validation/#validation-with-computed-fields","title":"Validation with Computed Fields","text":"<p>Computed fields can also be validated.</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\nuser = User(first_name=\"\", last_name=\"\")\nproxy = ObservableProxy(user)\n\n# Register a computed property for the full name\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\".strip(),\n    [\"first_name\", \"last_name\"]\n)\n\n# Add a validator to the computed property\nproxy.add_validator(\"full_name\", lambda v: \"Full name is required\" if not v else None)\n\n# Set values that will make the computed property invalid\nproxy.observable(str, \"first_name\").set(\"\")\nproxy.observable(str, \"last_name\").set(\"\")\n\n# Check validation errors\nerrors = proxy.validation_for(\"full_name\").get()\nprint(errors)  # ['Full name is required']\n</code></pre>"},{"location":"reference/proxy/validation/#resetting-validation","title":"Resetting Validation","text":"<p>You can reset validation errors for a specific field or all fields.</p> <pre><code># Reset validation for a specific field\nproxy.reset_validation(\"username\")\n\n# Reset validation for all fields\nproxy.reset_validation()\n\n# Reset and revalidate\nproxy.reset_validation(\"username\", revalidate=True)\nproxy.reset_validation(revalidate=True)\n</code></pre>"},{"location":"reference/proxy/validation/#validation-during-undoredo","title":"Validation During Undo/Redo","text":"<p>Validation is automatically triggered during undo and redo operations.</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    username: str\n\nuser = User(username=\"alice\")\nproxy = ObservableProxy(user, undo=True)\n\n# Add a validator\nproxy.add_validator(\"username\", lambda v: \"Username is required\" if not v else None)\n\n# Get the observable\nusername = proxy.observable(str, \"username\")\n\n# Make a change that will be valid\nusername.set(\"bob\")  # Valid\n\n# Make a change that will be invalid\nusername.set(\"\")  # Invalid\n\n# Undo to the valid state\nproxy.undo(\"username\")  # Validation will be triggered, and the proxy will be valid again\n\n# Redo to the invalid state\nproxy.redo(\"username\")  # Validation will be triggered, and the proxy will be invalid again\n</code></pre>"},{"location":"reference/proxy/validation/#validation-with-load-and-save","title":"Validation with Load and Save","text":"<p>Validation is triggered when loading values from a dictionary or saving to an object.</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    username: str\n    email: str\n\nuser = User(username=\"alice\", email=\"alice@example.com\")\nproxy = ObservableProxy(user)\n\n# Add validators\nproxy.add_validator(\"username\", lambda v: \"Username is required\" if not v else None)\nproxy.add_validator(\"email\", lambda v: \"Email is required\" if not v else None)\n\n# Load invalid values\nproxy.load_dict({\n    \"username\": \"\",\n    \"email\": \"\"\n})\n\n# Check if the proxy is valid\nif not proxy.is_valid().get():\n    print(\"User is invalid after loading\")\n\n# Fix the values\nproxy.update(username=\"alice\", email=\"alice@example.com\")\n\n# Save to a new object\nnew_user = User(username=\"\", email=\"\")\nproxy.save_to(new_user)\n\nprint(new_user)  # User(username='alice', email='alice@example.com')\n</code></pre>"},{"location":"reference/proxy/validation/#advanced-validation-patterns","title":"Advanced Validation Patterns","text":""},{"location":"reference/proxy/validation/#cross-field-validation","title":"Cross-Field Validation","text":"<p>You can implement cross-field validation using computed properties.</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\n\n@dataclass\nclass User:\n    password: str\n    confirm_password: str\n\nuser = User(password=\"\", confirm_password=\"\")\nproxy = ObservableProxy(user)\n\n# Register a computed property that checks if passwords match\nproxy.register_computed(\n    \"passwords_match\",\n    lambda: proxy.observable(str, \"password\").get() == proxy.observable(str, \"confirm_password\").get(),\n    [\"password\", \"confirm_password\"]\n)\n\n# Add a validator to the computed property\nproxy.add_validator(\"passwords_match\", lambda match: \"Passwords do not match\" if not match else None)\n\n# Set different passwords\nproxy.observable(str, \"password\").set(\"secret123\")\nproxy.observable(str, \"confirm_password\").set(\"secret456\")\n\n# Check validation errors\nerrors = proxy.validation_for(\"passwords_match\").get()\nprint(errors)  # ['Passwords do not match']\n</code></pre>"},{"location":"reference/proxy/validation/#custom-validator-classes","title":"Custom Validator Classes","text":"<p>For more complex validation logic, you can create custom validator classes.</p> <pre><code>from observant import ObservableProxy\nfrom dataclasses import dataclass\nfrom typing import Optional\n\nclass EmailValidator:\n    def __call__(self, value: str) -&gt; Optional[str]:\n        if not value:\n            return \"Email is required\"\n        if \"@\" not in value:\n            return \"Invalid email format\"\n        if not value.endswith((\".com\", \".org\", \".net\")):\n            return \"Email must end with .com, .org, or .net\"\n        return None\n\n@dataclass\nclass User:\n    email: str\n\nuser = User(email=\"\")\nproxy = ObservableProxy(user)\n\n# Add the custom validator\nproxy.add_validator(\"email\", EmailValidator())\n\n# Set an invalid email\nproxy.observable(str, \"email\").set(\"alice@example\")\n\n# Check validation errors\nerrors = proxy.validation_for(\"email\").get()\nprint(errors)  # ['Email must end with .com, .org, or .net']\n</code></pre>"},{"location":"reference/proxy/validation/#api-reference","title":"API Reference","text":""},{"location":"reference/proxy/validation/#add_validator","title":"<code>add_validator()</code>","text":"<pre><code>def add_validator(\n    self,\n    attr: str,\n    validator: Callable[[Any], str | None],\n) -&gt; None\n</code></pre> <p>Adds a validator function for a field.</p> <ul> <li><code>attr</code>: The field name to validate</li> <li><code>validator</code>: A function that takes the field value and returns an error message if invalid, or None if valid</li> </ul>"},{"location":"reference/proxy/validation/#is_valid","title":"<code>is_valid()</code>","text":"<pre><code>def is_valid(self) -&gt; IObservable[bool]\n</code></pre> <p>Gets an observable that indicates whether all fields are valid.</p>"},{"location":"reference/proxy/validation/#validation_errors","title":"<code>validation_errors()</code>","text":"<pre><code>def validation_errors(self) -&gt; IObservableDict[str, list[str]]\n</code></pre> <p>Gets an observable dictionary of validation errors.</p>"},{"location":"reference/proxy/validation/#validation_for","title":"<code>validation_for()</code>","text":"<pre><code>def validation_for(self, attr: str) -&gt; IObservable[list[str]]\n</code></pre> <p>Gets an observable list of validation errors for a specific field.</p>"},{"location":"reference/proxy/validation/#reset_validation","title":"<code>reset_validation()</code>","text":"<pre><code>def reset_validation(self, attr: str | None = None, *, revalidate: bool = False) -&gt; None\n</code></pre> <p>Resets validation errors for a specific field or all fields.</p> <ul> <li><code>attr</code>: The field name to reset validation for. If None, reset all fields.</li> <li><code>revalidate</code>: Whether to re-run validators after clearing errors.</li> </ul>"}]}