{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#observant","title":"Observant","text":"<p>A reactive state management library for Python with observable objects, validation, undo/redo, and computed properties.</p>"},{"location":"#what-is-observant","title":"What is Observant?","text":"<p>Observant is a Python library that brings reactive programming to your data models. It allows you to:</p> <ul> <li>Track changes to your data</li> <li>Validate data as it changes</li> <li>Implement undo/redo functionality</li> <li>Create computed properties that update automatically</li> <li>Keep track of \"dirty\" state for unsaved changes</li> </ul> <p>At its core, Observant provides observable objects that notify listeners when their values change, making it easy to build reactive applications.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install observant\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#observable-objects","title":"Observable Objects","text":"<pre><code>from observant import Observable\n\n# Create an observable value\ncounter = Observable[int](0)\n\n# Listen for changes\ncounter.on_change(lambda value: print(f\"Counter changed to {value}\"))\n\n# Update the value\ncounter.set(1)  # Prints: \"Counter changed to 1\"\n</code></pre>"},{"location":"#observable-collections","title":"Observable Collections","text":"<pre><code>from observant import ObservableList, ObservableDict\n\n# Observable list\ntasks = ObservableList[str]([\"Buy milk\"])\ntasks.on_change(lambda change: print(f\"Tasks changed: {change}\"))\ntasks.append(\"Write docs\")\n\n# Observable dictionary\nsettings = ObservableDict[str, str]({\"theme\": \"dark\"})\nsettings.on_change(lambda change: print(f\"Settings changed: {change}\"))\nsettings[\"language\"] = \"en\"\n</code></pre>"},{"location":"#observable-proxy","title":"Observable Proxy","text":"<pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user)\n\n# Get observable for a field\nname_obs = proxy.observable(str, \"name\")\nname_obs.on_change(lambda value: print(f\"Name changed to {value}\"))\n\n# Update the field\nname_obs.set(\"Alicia\")  # Prints: \"Name changed to Alicia\"\n\n# Save changes back to the model\nproxy.save_to(user)\nprint(user.name)  # Prints: \"Alicia\"\n</code></pre>"},{"location":"#validation","title":"Validation","text":"<pre><code>from observant import ObservableProxy\n\n# Add validators\nproxy.add_validator(\"age\", lambda age: \"Must be positive\" if age &lt;= 0 else None)\nproxy.add_validator(\"name\", lambda name: \"Name too short\" if len(name) &lt; 3 else None)\n\n# Check validation state\nprint(proxy.is_valid())  # True or False\nprint(proxy.validation_errors())  # Dictionary of field errors\n</code></pre>"},{"location":"#undoredo","title":"Undo/Redo","text":"<pre><code>from observant import ObservableProxy\n\n# Enable undo\nproxy = ObservableProxy(user, undo=True)\n\n# Make changes\nproxy.observable(str, \"name\").set(\"Bob\")\nproxy.observable(int, \"age\").set(25)\n\n# Undo changes\nproxy.undo(\"name\")  # Reverts name to \"Alicia\"\nproxy.undo(\"age\")   # Reverts age to 30\n\n# Redo changes\nproxy.redo(\"name\")  # Sets name back to \"Bob\"\n</code></pre>"},{"location":"#computed-properties","title":"Computed Properties","text":"<pre><code>from observant import ObservableProxy\n\n# Register a computed property\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\n\n# Access the computed value\nprint(proxy.computed(str, \"full_name\").get())\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass FormData:\n    username: str\n    email: str\n    age: int\n\n# Create a model and proxy\nform = FormData(username=\"\", email=\"\", age=0)\nproxy = ObservableProxy(form, undo=True)\n\n# Add validation\nproxy.add_validator(\"username\", lambda v: \"Required\" if not v else None)\nproxy.add_validator(\"email\", lambda v: \"Invalid email\" if \"@\" not in v else None)\nproxy.add_validator(\"age\", lambda v: \"Must be 18+\" if v &lt; 18 else None)\n\n# Update fields\nproxy.observable(str, \"username\").set(\"alice\")\nproxy.observable(str, \"email\").set(\"alice@example.com\")\nproxy.observable(int, \"age\").set(25)\n\n# Check if valid\nif proxy.is_valid():\n    # Save changes\n    proxy.save_to(form)\n    print(\"Form saved!\")\nelse:\n    # Show errors\n    print(\"Validation errors:\", proxy.validation_errors())\n</code></pre>"},{"location":"#where-to-go-next","title":"Where to Go Next","text":"<ul> <li>Getting Started - Learn the basics</li> <li>Change Tracking - Understand how observables work</li> <li>API Reference - Detailed API documentation</li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":"<p>This guide will help you get started with Observant, a reactive state management library for Python.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<p>Install Observant using pip:</p> <pre><code>pip install observant\n</code></pre>"},{"location":"getting_started/#basic-concepts","title":"Basic Concepts","text":"<p>Before diving into code examples, let's understand the core concepts of Observant.</p>"},{"location":"getting_started/#observable","title":"Observable","text":"<p>An <code>Observable</code> is a wrapper around a value that notifies listeners when the value changes. It's the simplest building block in Observant.</p> <pre><code>from observant import Observable\n\n# Create an observable with an initial value\nname = Observable[str](\"Alice\")\n\n# Register a callback to be notified when the value changes\nname.on_change(lambda value: print(f\"Name changed to: {value}\"))\n\n# Change the value\nname.set(\"Bob\")  # Prints: \"Name changed to: Bob\"\n\n# Get the current value\ncurrent_name = name.get()  # Returns: \"Bob\"\n</code></pre>"},{"location":"getting_started/#observablelist-and-observabledict","title":"ObservableList and ObservableDict","text":"<p>Observant also provides observable collections that notify listeners when items are added, removed, or updated.</p> <pre><code>from observant import ObservableList, ObservableDict\n\n# Observable list\ntasks = ObservableList[str]([\"Task 1\"])\ntasks.on_change(lambda change: print(f\"Tasks changed: {change}\"))\ntasks.append(\"Task 2\")  # Notifies listeners\n\n# Observable dictionary\nsettings = ObservableDict[str, str]({\"theme\": \"dark\"})\nsettings.on_change(lambda change: print(f\"Settings changed: {change}\"))\nsettings[\"language\"] = \"en\"  # Notifies listeners\n</code></pre>"},{"location":"getting_started/#observableproxy","title":"ObservableProxy","text":"<p>The <code>ObservableProxy</code> is the most powerful component in Observant. It wraps an object (typically a dataclass) and provides observable access to its fields.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n    email: str\n\n# Create a user and wrap it with a proxy\nuser = User(name=\"Alice\", age=30, email=\"alice@example.com\")\nproxy = ObservableProxy(user)\n\n# Get observables for individual fields\nname_obs = proxy.observable(str, \"name\")\nage_obs = proxy.observable(int, \"age\")\n\n# Register change listeners\nname_obs.on_change(lambda value: print(f\"Name changed to: {value}\"))\nage_obs.on_change(lambda value: print(f\"Age changed to: {value}\"))\n\n# Update fields\nname_obs.set(\"Alicia\")  # Prints: \"Name changed to: Alicia\"\nage_obs.set(31)         # Prints: \"Age changed to: 31\"\n\n# Save changes back to the original object\nproxy.save_to(user)\nprint(user.name)  # Prints: \"Alicia\"\nprint(user.age)   # Prints: 31\n</code></pre>"},{"location":"getting_started/#minimal-example","title":"Minimal Example","text":"<p>Here's a complete example showing how to use Observant with a simple form:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass LoginForm:\n    username: str\n    password: str\n    remember_me: bool\n\n# Create a form and proxy\nform = LoginForm(username=\"\", password=\"\", remember_me=False)\nproxy = ObservableProxy(form)\n\n# Add validation\nproxy.add_validator(\"username\", lambda v: \"Username required\" if not v else None)\nproxy.add_validator(\"password\", lambda v: \"Password too short\" if len(v) &lt; 8 else None)\n\n# Track changes\nproxy.observable(str, \"username\").on_change(lambda v: print(f\"Username: {v}\"))\nproxy.observable(str, \"password\").on_change(lambda v: print(f\"Password: {'*' * len(v)}\"))\nproxy.observable(bool, \"remember_me\").on_change(lambda v: print(f\"Remember me: {v}\"))\n\n# Update fields\nproxy.observable(str, \"username\").set(\"alice\")\nproxy.observable(str, \"password\").set(\"securepassword\")\nproxy.observable(bool, \"remember_me\").set(True)\n\n# Check validation\nif proxy.is_valid():\n    print(\"Form is valid!\")\n    proxy.save_to(form)\nelse:\n    print(\"Validation errors:\", proxy.validation_errors())\n</code></pre>"},{"location":"getting_started/#anatomy-of-a-proxy","title":"Anatomy of a Proxy","text":"<p>The <code>ObservableProxy</code> is the central component of Observant. Here's what it provides:</p> <ol> <li> <p>Field Observables: Access individual fields as observables    <pre><code>name_obs = proxy.observable(str, \"name\")\n</code></pre></p> </li> <li> <p>Collection Observables: Access lists and dictionaries as observable collections    <pre><code>tasks_list = proxy.observable_list(str, \"tasks\")\nsettings_dict = proxy.observable_dict((str, str), \"settings\")\n</code></pre></p> </li> <li> <p>Validation: Add validators to fields and check validation state    <pre><code>proxy.add_validator(\"email\", lambda v: \"Invalid email\" if \"@\" not in v else None)\nis_valid = proxy.is_valid()\nerrors = proxy.validation_errors()\n</code></pre></p> </li> <li> <p>Computed Properties: Define properties that depend on other fields    <pre><code>proxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\nfull_name = proxy.computed(str, \"full_name\").get()\n</code></pre></p> </li> <li> <p>Undo/Redo: Track changes and undo/redo them    <pre><code>proxy = ObservableProxy(user, undo=True)\nproxy.observable(str, \"name\").set(\"Bob\")\nproxy.undo(\"name\")  # Reverts to previous value\n</code></pre></p> </li> <li> <p>Dirty Tracking: Track unsaved changes    <pre><code>is_dirty = proxy.is_dirty()\ndirty_fields = proxy.dirty_fields()\nproxy.reset_dirty()\n</code></pre></p> </li> <li> <p>Saving and Loading: Save changes back to the model or load from a dictionary    <pre><code>proxy.save_to(user)\nproxy.load_dict({\"name\": \"Charlie\", \"age\": 25})\n</code></pre></p> </li> </ol>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, you can explore more advanced features:</p> <ul> <li>Change Tracking: Learn more about observables and change notifications</li> <li>Validation: Add validation to your models</li> <li>Computed Properties: Create properties that depend on other fields</li> <li>Undo and Redo: Implement undo/redo functionality</li> <li>Dirty Tracking: Track unsaved changes</li> <li>Sync vs Non-Sync: Understand immediate vs. deferred updates</li> <li>Saving and Loading: Save changes and load data</li> </ul>"},{"location":"api_reference/","title":"API Reference","text":"<p>This section provides detailed documentation for the Observant API. It covers all the classes, methods, and types available in the library.</p>"},{"location":"api_reference/#core-classes","title":"Core Classes","text":"<ul> <li>Observable: The base observable class for scalar values</li> <li>ObservableList: An observable list that notifies listeners when items are added, removed, or modified</li> <li>ObservableDict: An observable dictionary that notifies listeners when items are added, updated, or removed</li> <li>ObservableProxy: An observable proxy that wraps an object and provides observable access to its fields</li> <li>UndoableObservable: An observable with undo/redo functionality</li> </ul>"},{"location":"api_reference/#types","title":"Types","text":"<p>The Types section documents the various types used throughout the library:</p> <ul> <li>ObservableCollectionChangeType: An enum that represents the type of change that occurred in a collection</li> <li>ObservableListChange: A class that represents a change to an observable list</li> <li>ObservableDictChange: A class that represents a change to an observable dictionary</li> <li>ProxyFieldKey: A class that represents a field key in an ObservableProxy</li> <li>UndoConfig: A class that represents the configuration for undo/redo functionality</li> </ul>"},{"location":"api_reference/#interfaces","title":"Interfaces","text":"<p>The Interfaces section documents the interfaces that define the contract for observable objects:</p> <ul> <li>IObservable: The base interface for observable objects</li> <li>IObservableList: The interface for observable lists</li> <li>IObservableDict: The interface for observable dictionaries</li> <li>IObservableProxy: The interface for observable proxies</li> </ul>"},{"location":"api_reference/observable/","title":"Observable","text":""},{"location":"api_reference/observable/#observant.observable.Observable","title":"<code>observant.observable.Observable</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>IObservable[T]</code></p> Source code in <code>observant\\observable.py</code> <pre><code>class Observable(Generic[T], IObservable[T]):\n    _value: T\n    _callbacks: list[Callable[[T], None]]\n    _on_change_enabled: bool = True\n\n    def __init__(self, value: T, *, on_change: Callable[[T], None] | None = None, on_change_enabled: bool = True) -&gt; None:\n        \"\"\"\n        Initialize the Observable with a value.\n\n        Args:\n            value: The initial value of the observable.\n        \"\"\"\n        print(f\"DEBUG: Observable.__init__ called with value {value}\")\n        self._value = value\n        self._callbacks = []\n        self._on_change_enabled = on_change_enabled\n        print(\"DEBUG: Observable.__init__ - Initialized with empty callbacks list\")\n\n    @override\n    def get(self) -&gt; T:\n        \"\"\"\n        Get the current value of the observable.\n\n        Returns:\n            The current value.\n        \"\"\"\n        return self._value\n\n    @override\n    def set(self, value: T, notify: bool = True) -&gt; None:\n        \"\"\"\n        Set a new value for the observable and notify all registered callbacks.\n\n        Args:\n            value: The new value to set.\n            notify: Whether to notify the callbacks after setting the value.\n        \"\"\"\n        print(f\"DEBUG: Observable.set called with value {value}\")\n        self._value = value\n\n        if not notify or not self._on_change_enabled:\n            print(\"DEBUG: Observable.set - on_change is disabled, skipping callbacks\")\n            return\n\n        print(f\"DEBUG: Observable.set - Notifying {len(self._callbacks)} callbacks\")\n        for i, callback in enumerate(self._callbacks):\n            print(f\"DEBUG: Observable.set - Calling callback {i}\")\n            callback(value)\n            print(f\"DEBUG: Observable.set - Callback {i} completed\")\n        print(\"DEBUG: Observable.set - Completed\")\n\n    @override\n    def on_change(self, callback: Callable[[T], None]) -&gt; None:\n        \"\"\"\n        Register a callback function to be called when the value changes.\n\n        Args:\n            callback: A function that takes the new value as its argument.\n        \"\"\"\n        print(f\"DEBUG: Observable.on_change called, current callbacks: {len(self._callbacks)}\")\n        # Check if this callback is already registered to avoid duplicates\n        for existing_cb in self._callbacks:\n            if existing_cb == callback:\n                print(\"DEBUG: Observable.on_change - Callback already registered, skipping\")\n                return\n\n        self._callbacks.append(callback)\n        print(f\"DEBUG: Observable.on_change - Added callback, now have {len(self._callbacks)} callbacks\")\n\n    @override\n    def enable(self) -&gt; None:\n        \"\"\"\n        Enable the observable to notify changes.\n        \"\"\"\n        print(\"DEBUG: Observable.enable called\")\n        self._on_change_enabled = True\n\n    @override\n    def disable(self) -&gt; None:\n        \"\"\"\n        Disable the observable from notifying changes.\n        \"\"\"\n        print(\"DEBUG: Observable.disable called\")\n        self._on_change_enabled = False\n\n    def __bool__(self) -&gt; bool:\n        \"\"\"\n        Convert the observable to a boolean.\n\n        Returns:\n            The boolean value of the current value.\n        \"\"\"\n        return bool(self.get())\n\n    @override\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Convert the observable to a string.\n\n        Returns:\n            The string representation of the current value.\n        \"\"\"\n        return str(self.get())\n\n    @override\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Get the representation of the observable.\n\n        Returns:\n            A string representation of the observable.\n        \"\"\"\n        return f\"{self.__class__.__name__}({self.get()!r})\"\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.__bool__","title":"<code>__bool__()</code>","text":"<p>Convert the observable to a boolean.</p> <p>Returns:</p> Type Description <code>bool</code> <p>The boolean value of the current value.</p> Source code in <code>observant\\observable.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"\n    Convert the observable to a boolean.\n\n    Returns:\n        The boolean value of the current value.\n    \"\"\"\n    return bool(self.get())\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.__init__","title":"<code>__init__(value, *, on_change=None, on_change_enabled=True)</code>","text":"<p>Initialize the Observable with a value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The initial value of the observable.</p> required Source code in <code>observant\\observable.py</code> <pre><code>def __init__(self, value: T, *, on_change: Callable[[T], None] | None = None, on_change_enabled: bool = True) -&gt; None:\n    \"\"\"\n    Initialize the Observable with a value.\n\n    Args:\n        value: The initial value of the observable.\n    \"\"\"\n    print(f\"DEBUG: Observable.__init__ called with value {value}\")\n    self._value = value\n    self._callbacks = []\n    self._on_change_enabled = on_change_enabled\n    print(\"DEBUG: Observable.__init__ - Initialized with empty callbacks list\")\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.__repr__","title":"<code>__repr__()</code>","text":"<p>Get the representation of the observable.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the observable.</p> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef __repr__(self) -&gt; str:\n    \"\"\"\n    Get the representation of the observable.\n\n    Returns:\n        A string representation of the observable.\n    \"\"\"\n    return f\"{self.__class__.__name__}({self.get()!r})\"\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.__str__","title":"<code>__str__()</code>","text":"<p>Convert the observable to a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string representation of the current value.</p> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef __str__(self) -&gt; str:\n    \"\"\"\n    Convert the observable to a string.\n\n    Returns:\n        The string representation of the current value.\n    \"\"\"\n    return str(self.get())\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.disable","title":"<code>disable()</code>","text":"<p>Disable the observable from notifying changes.</p> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef disable(self) -&gt; None:\n    \"\"\"\n    Disable the observable from notifying changes.\n    \"\"\"\n    print(\"DEBUG: Observable.disable called\")\n    self._on_change_enabled = False\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.enable","title":"<code>enable()</code>","text":"<p>Enable the observable to notify changes.</p> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef enable(self) -&gt; None:\n    \"\"\"\n    Enable the observable to notify changes.\n    \"\"\"\n    print(\"DEBUG: Observable.enable called\")\n    self._on_change_enabled = True\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.get","title":"<code>get()</code>","text":"<p>Get the current value of the observable.</p> <p>Returns:</p> Type Description <code>T</code> <p>The current value.</p> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef get(self) -&gt; T:\n    \"\"\"\n    Get the current value of the observable.\n\n    Returns:\n        The current value.\n    \"\"\"\n    return self._value\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.on_change","title":"<code>on_change(callback)</code>","text":"<p>Register a callback function to be called when the value changes.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[T], None]</code> <p>A function that takes the new value as its argument.</p> required Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef on_change(self, callback: Callable[[T], None]) -&gt; None:\n    \"\"\"\n    Register a callback function to be called when the value changes.\n\n    Args:\n        callback: A function that takes the new value as its argument.\n    \"\"\"\n    print(f\"DEBUG: Observable.on_change called, current callbacks: {len(self._callbacks)}\")\n    # Check if this callback is already registered to avoid duplicates\n    for existing_cb in self._callbacks:\n        if existing_cb == callback:\n            print(\"DEBUG: Observable.on_change - Callback already registered, skipping\")\n            return\n\n    self._callbacks.append(callback)\n    print(f\"DEBUG: Observable.on_change - Added callback, now have {len(self._callbacks)} callbacks\")\n</code></pre>"},{"location":"api_reference/observable/#observant.observable.Observable.set","title":"<code>set(value, notify=True)</code>","text":"<p>Set a new value for the observable and notify all registered callbacks.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The new value to set.</p> required <code>notify</code> <code>bool</code> <p>Whether to notify the callbacks after setting the value.</p> <code>True</code> Source code in <code>observant\\observable.py</code> <pre><code>@override\ndef set(self, value: T, notify: bool = True) -&gt; None:\n    \"\"\"\n    Set a new value for the observable and notify all registered callbacks.\n\n    Args:\n        value: The new value to set.\n        notify: Whether to notify the callbacks after setting the value.\n    \"\"\"\n    print(f\"DEBUG: Observable.set called with value {value}\")\n    self._value = value\n\n    if not notify or not self._on_change_enabled:\n        print(\"DEBUG: Observable.set - on_change is disabled, skipping callbacks\")\n        return\n\n    print(f\"DEBUG: Observable.set - Notifying {len(self._callbacks)} callbacks\")\n    for i, callback in enumerate(self._callbacks):\n        print(f\"DEBUG: Observable.set - Calling callback {i}\")\n        callback(value)\n        print(f\"DEBUG: Observable.set - Callback {i} completed\")\n    print(\"DEBUG: Observable.set - Completed\")\n</code></pre>"},{"location":"api_reference/observable_dict/","title":"ObservableDict","text":""},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict","title":"<code>observant.observable_dict.ObservableDict</code>","text":"<p>               Bases: <code>Generic[TKey, TValue]</code>, <code>IObservableDict[TKey, TValue]</code></p> <p>Base implementation that can work with an external dict or create its own.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>class ObservableDict(Generic[TKey, TValue], IObservableDict[TKey, TValue]):\n    \"\"\"Base implementation that can work with an external dict or create its own.\"\"\"\n\n    def __init__(self, items: dict[TKey, TValue] | None = None, *, copy: bool = False) -&gt; None:\n        \"\"\"\n        Initialize with optional external dict reference.\n\n        Args:\n            items: Optional external dict to observe. If None, creates a new dict.\n        \"\"\"\n        if copy:\n            self._items: dict[TKey, TValue] = dict(items) if items is not None else {}\n        else:\n            self._items = items if items is not None else {}\n        self._change_callbacks: list[Callable[[ObservableDictChange[TKey, TValue]], None]] = []\n        self._add_callbacks: list[Callable[[TKey, TValue], None]] = []\n        self._remove_callbacks: list[Callable[[TKey, TValue], None]] = []\n        self._update_callbacks: list[Callable[[TKey, TValue], None]] = []\n        self._clear_callbacks: list[Callable[[dict[TKey, TValue]], None]] = []\n\n    @override\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of items in the dictionary.\"\"\"\n        return len(self._items)\n\n    @override\n    def __getitem__(self, key: TKey) -&gt; TValue:\n        \"\"\"Get an item from the dictionary.\"\"\"\n        return self._items[key]\n\n    @override\n    def __setitem__(self, key: TKey, value: TValue) -&gt; None:\n        \"\"\"Set an item in the dictionary.\"\"\"\n        if key in self._items:\n            self._items[key] = value\n            self._notify_update(key, value)\n        else:\n            self._items[key] = value\n            self._notify_add(key, value)\n\n    @override\n    def __delitem__(self, key: TKey) -&gt; None:\n        \"\"\"Delete an item from the dictionary.\"\"\"\n        value = self._items[key]\n        del self._items[key]\n        self._notify_remove(key, value)\n\n    @override\n    def __iter__(self) -&gt; Iterator[TKey]:\n        \"\"\"Return an iterator over the keys in the dictionary.\"\"\"\n        return iter(self._items)\n\n    @override\n    def __contains__(self, key: TKey) -&gt; bool:\n        \"\"\"Check if a key is in the dictionary.\"\"\"\n        return key in self._items\n\n    @override\n    def get(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"\n        Return the value for a key if it exists, otherwise return a default value.\n\n        Args:\n            key: The key to look up\n            default: The default value to return if the key is not found\n\n        Returns:\n            The value for the key, or the default value\n        \"\"\"\n        return self._items.get(key, default)\n\n    @override\n    def setdefault(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"\n        Return the value for a key if it exists, otherwise set and return the default value.\n\n        Args:\n            key: The key to look up\n            default: The default value to set and return if the key is not found\n\n        Returns:\n            The value for the key, or the default value\n        \"\"\"\n        if key not in self._items:\n            self._items[key] = cast(TValue, default)  # Cast to V since we know it's a value\n            self._notify_add(key, cast(TValue, default))\n            return default\n        return self._items[key]\n\n    @override\n    def pop(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"\n        Remove and return the value for a key if it exists, otherwise return a default value.\n\n        Args:\n            key: The key to look up\n            default: The default value to return if the key is not found\n\n        Returns:\n            The value for the key, or the default value\n\n        Raises:\n            KeyError: If the key is not found and no default value is provided\n        \"\"\"\n        if key in self._items:\n            value = self._items.pop(key)\n            self._notify_remove(key, value)\n            return value\n        if default is not None:\n            return default\n        raise KeyError(key)\n\n    @override\n    def popitem(self) -&gt; tuple[TKey, TValue]:\n        \"\"\"\n        Remove and return a (key, value) pair from the dictionary.\n\n        Returns:\n            A (key, value) pair\n\n        Raises:\n            KeyError: If the dictionary is empty\n        \"\"\"\n        key, value = self._items.popitem()\n        self._notify_remove(key, value)\n        return key, value\n\n    @override\n    def clear(self) -&gt; None:\n        \"\"\"Remove all items from the dictionary.\"\"\"\n        if not self._items:\n            return\n        items = self._items.copy()\n        self._items.clear()\n        self._notify_clear(items)\n\n    @override\n    def update(self, other: dict[TKey, TValue]) -&gt; None:\n        \"\"\"\n        Update the dictionary with the key/value pairs from another dictionary.\n\n        Args:\n            other: Another dictionary to update from\n        \"\"\"\n        if not other:\n            return\n        added_items: dict[TKey, TValue] = {}\n        updated_items: dict[TKey, TValue] = {}\n        for key, value in other.items():\n            if key in self._items:\n                updated_items[key] = value\n            else:\n                added_items[key] = value\n        self._items.update(other)\n\n        # Notify for added items\n        if added_items:\n            for key, value in added_items.items():\n                self._notify_add(key, value)\n\n        # Notify for updated items\n        if updated_items:\n            for key, value in updated_items.items():\n                self._notify_update(key, value)\n\n    @override\n    def keys(self) -&gt; list[TKey]:\n        \"\"\"\n        Return a list of all keys in the dictionary.\n\n        Returns:\n            A list of keys\n        \"\"\"\n        return list(self._items.keys())\n\n    @override\n    def values(self) -&gt; list[TValue]:\n        \"\"\"\n        Return a list of all values in the dictionary.\n\n        Returns:\n            A list of values\n        \"\"\"\n        return list(self._items.values())\n\n    @override\n    def items(self) -&gt; list[tuple[TKey, TValue]]:\n        \"\"\"\n        Return a list of all (key, value) pairs in the dictionary.\n\n        Returns:\n            A list of (key, value) pairs\n        \"\"\"\n        return list(self._items.items())\n\n    @override\n    def copy(self) -&gt; dict[TKey, TValue]:\n        \"\"\"\n        Return a shallow copy of the dictionary.\n\n        Returns:\n            A copy of the dictionary\n        \"\"\"\n        return self._items.copy()\n\n    @override\n    def on_change(self, callback: Callable[[ObservableDictChange[TKey, TValue]], None]) -&gt; None:\n        \"\"\"\n        Add a callback to be called when the dictionary changes.\n\n        Args:\n            callback: A function that takes a DictChange object\n        \"\"\"\n        self._change_callbacks.append(callback)\n\n    @override\n    def on_add(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"\n        Register for add events with key and value.\n\n        Args:\n            callback: A function that takes a key and value\n        \"\"\"\n        self._add_callbacks.append(callback)\n\n    @override\n    def on_remove(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"\n        Register for remove events with key and value.\n\n        Args:\n            callback: A function that takes a key and value\n        \"\"\"\n        self._remove_callbacks.append(callback)\n\n    @override\n    def on_update(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"\n        Register for update events with key and new value.\n\n        Args:\n            callback: A function that takes a key and new value\n        \"\"\"\n        self._update_callbacks.append(callback)\n\n    @override\n    def on_clear(self, callback: Callable[[dict[TKey, TValue]], None]) -&gt; None:\n        \"\"\"\n        Register for clear events with the cleared items.\n\n        Args:\n            callback: A function that takes a dict of cleared items\n        \"\"\"\n        self._clear_callbacks.append(callback)\n\n    def _notify_add(self, key: TKey, value: TValue) -&gt; None:\n        \"\"\"\n        Notify all callbacks of an item being added.\n\n        Args:\n            key: The key that was added\n            value: The value that was added\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._add_callbacks:\n            callback(key, value)\n\n        # Create a dictionary with the single item for the items field\n        items_dict = {key: value}\n\n        # Call general change callbacks\n        change = ObservableDictChange(\n            type=ObservableCollectionChangeType.ADD,\n            key=key,\n            value=value,\n            items=items_dict,\n        )\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_remove(self, key: TKey, value: TValue) -&gt; None:\n        \"\"\"\n        Notify all callbacks of an item being removed.\n\n        Args:\n            key: The key that was removed\n            value: The value that was removed\n        \"\"\"\n        print(f\"DEBUG: ObservableDict._notify_remove called with key={key}, value={value}\")\n\n        # Call specific callbacks\n        for callback in self._remove_callbacks:\n            callback(key, value)\n\n        # Create a dictionary with the single item for the items field\n        items_dict = {key: value}\n\n        # Call general change callbacks\n        change = ObservableDictChange(\n            type=ObservableCollectionChangeType.REMOVE,\n            key=key,\n            value=value,\n            items=items_dict,\n        )\n        print(f\"DEBUG: ObservableDict._notify_remove - Created change object: type={change.type}, key={change.key}, value={change.value}\")\n        for callback in self._change_callbacks:\n            callback(change)\n        print(\"DEBUG: ObservableDict._notify_remove - Completed\")\n\n    def _notify_update(self, key: TKey, value: TValue) -&gt; None:\n        \"\"\"\n        Notify all callbacks of an item being updated.\n\n        Args:\n            key: The key that was updated\n            value: The new value\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._update_callbacks:\n            callback(key, value)\n\n        # Create a dictionary with the single item for the items field\n        items_dict = {key: value}\n\n        # Call general change callbacks\n        change = ObservableDictChange(\n            type=ObservableCollectionChangeType.UPDATE,\n            key=key,\n            value=value,\n            items=items_dict,\n        )\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_clear(self, items: dict[TKey, TValue]) -&gt; None:\n        \"\"\"\n        Notify all callbacks of the dictionary being cleared.\n\n        Args:\n            items: The items that were cleared\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._clear_callbacks:\n            callback(items)\n\n        # Call general change callbacks\n        change = ObservableDictChange(type=ObservableCollectionChangeType.CLEAR, items=items)\n        for callback in self._change_callbacks:\n            callback(change)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Check if a key is in the dictionary.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __contains__(self, key: TKey) -&gt; bool:\n    \"\"\"Check if a key is in the dictionary.\"\"\"\n    return key in self._items\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Delete an item from the dictionary.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __delitem__(self, key: TKey) -&gt; None:\n    \"\"\"Delete an item from the dictionary.\"\"\"\n    value = self._items[key]\n    del self._items[key]\n    self._notify_remove(key, value)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Get an item from the dictionary.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __getitem__(self, key: TKey) -&gt; TValue:\n    \"\"\"Get an item from the dictionary.\"\"\"\n    return self._items[key]\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__init__","title":"<code>__init__(items=None, *, copy=False)</code>","text":"<p>Initialize with optional external dict reference.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>dict[TKey, TValue] | None</code> <p>Optional external dict to observe. If None, creates a new dict.</p> <code>None</code> Source code in <code>observant\\observable_dict.py</code> <pre><code>def __init__(self, items: dict[TKey, TValue] | None = None, *, copy: bool = False) -&gt; None:\n    \"\"\"\n    Initialize with optional external dict reference.\n\n    Args:\n        items: Optional external dict to observe. If None, creates a new dict.\n    \"\"\"\n    if copy:\n        self._items: dict[TKey, TValue] = dict(items) if items is not None else {}\n    else:\n        self._items = items if items is not None else {}\n    self._change_callbacks: list[Callable[[ObservableDictChange[TKey, TValue]], None]] = []\n    self._add_callbacks: list[Callable[[TKey, TValue], None]] = []\n    self._remove_callbacks: list[Callable[[TKey, TValue], None]] = []\n    self._update_callbacks: list[Callable[[TKey, TValue], None]] = []\n    self._clear_callbacks: list[Callable[[dict[TKey, TValue]], None]] = []\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the keys in the dictionary.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __iter__(self) -&gt; Iterator[TKey]:\n    \"\"\"Return an iterator over the keys in the dictionary.\"\"\"\n    return iter(self._items)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of items in the dictionary.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __len__(self) -&gt; int:\n    \"\"\"Return the number of items in the dictionary.\"\"\"\n    return len(self._items)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set an item in the dictionary.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef __setitem__(self, key: TKey, value: TValue) -&gt; None:\n    \"\"\"Set an item in the dictionary.\"\"\"\n    if key in self._items:\n        self._items[key] = value\n        self._notify_update(key, value)\n    else:\n        self._items[key] = value\n        self._notify_add(key, value)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.clear","title":"<code>clear()</code>","text":"<p>Remove all items from the dictionary.</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef clear(self) -&gt; None:\n    \"\"\"Remove all items from the dictionary.\"\"\"\n    if not self._items:\n        return\n    items = self._items.copy()\n    self._items.clear()\n    self._notify_clear(items)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.copy","title":"<code>copy()</code>","text":"<p>Return a shallow copy of the dictionary.</p> <p>Returns:</p> Type Description <code>dict[TKey, TValue]</code> <p>A copy of the dictionary</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef copy(self) -&gt; dict[TKey, TValue]:\n    \"\"\"\n    Return a shallow copy of the dictionary.\n\n    Returns:\n        A copy of the dictionary\n    \"\"\"\n    return self._items.copy()\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.get","title":"<code>get(key, default=None)</code>","text":"<p>Return the value for a key if it exists, otherwise return a default value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TKey</code> <p>The key to look up</p> required <code>default</code> <code>TValue | None</code> <p>The default value to return if the key is not found</p> <code>None</code> <p>Returns:</p> Type Description <code>TValue | None</code> <p>The value for the key, or the default value</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef get(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"\n    Return the value for a key if it exists, otherwise return a default value.\n\n    Args:\n        key: The key to look up\n        default: The default value to return if the key is not found\n\n    Returns:\n        The value for the key, or the default value\n    \"\"\"\n    return self._items.get(key, default)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.items","title":"<code>items()</code>","text":"<p>Return a list of all (key, value) pairs in the dictionary.</p> <p>Returns:</p> Type Description <code>list[tuple[TKey, TValue]]</code> <p>A list of (key, value) pairs</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef items(self) -&gt; list[tuple[TKey, TValue]]:\n    \"\"\"\n    Return a list of all (key, value) pairs in the dictionary.\n\n    Returns:\n        A list of (key, value) pairs\n    \"\"\"\n    return list(self._items.items())\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.keys","title":"<code>keys()</code>","text":"<p>Return a list of all keys in the dictionary.</p> <p>Returns:</p> Type Description <code>list[TKey]</code> <p>A list of keys</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef keys(self) -&gt; list[TKey]:\n    \"\"\"\n    Return a list of all keys in the dictionary.\n\n    Returns:\n        A list of keys\n    \"\"\"\n    return list(self._items.keys())\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.on_add","title":"<code>on_add(callback)</code>","text":"<p>Register for add events with key and value.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[TKey, TValue], None]</code> <p>A function that takes a key and value</p> required Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef on_add(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"\n    Register for add events with key and value.\n\n    Args:\n        callback: A function that takes a key and value\n    \"\"\"\n    self._add_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.on_change","title":"<code>on_change(callback)</code>","text":"<p>Add a callback to be called when the dictionary changes.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ObservableDictChange[TKey, TValue]], None]</code> <p>A function that takes a DictChange object</p> required Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef on_change(self, callback: Callable[[ObservableDictChange[TKey, TValue]], None]) -&gt; None:\n    \"\"\"\n    Add a callback to be called when the dictionary changes.\n\n    Args:\n        callback: A function that takes a DictChange object\n    \"\"\"\n    self._change_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.on_clear","title":"<code>on_clear(callback)</code>","text":"<p>Register for clear events with the cleared items.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[dict[TKey, TValue]], None]</code> <p>A function that takes a dict of cleared items</p> required Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef on_clear(self, callback: Callable[[dict[TKey, TValue]], None]) -&gt; None:\n    \"\"\"\n    Register for clear events with the cleared items.\n\n    Args:\n        callback: A function that takes a dict of cleared items\n    \"\"\"\n    self._clear_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.on_remove","title":"<code>on_remove(callback)</code>","text":"<p>Register for remove events with key and value.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[TKey, TValue], None]</code> <p>A function that takes a key and value</p> required Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef on_remove(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"\n    Register for remove events with key and value.\n\n    Args:\n        callback: A function that takes a key and value\n    \"\"\"\n    self._remove_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.on_update","title":"<code>on_update(callback)</code>","text":"<p>Register for update events with key and new value.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[TKey, TValue], None]</code> <p>A function that takes a key and new value</p> required Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef on_update(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"\n    Register for update events with key and new value.\n\n    Args:\n        callback: A function that takes a key and new value\n    \"\"\"\n    self._update_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.pop","title":"<code>pop(key, default=None)</code>","text":"<p>Remove and return the value for a key if it exists, otherwise return a default value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TKey</code> <p>The key to look up</p> required <code>default</code> <code>TValue | None</code> <p>The default value to return if the key is not found</p> <code>None</code> <p>Returns:</p> Type Description <code>TValue | None</code> <p>The value for the key, or the default value</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found and no default value is provided</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef pop(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"\n    Remove and return the value for a key if it exists, otherwise return a default value.\n\n    Args:\n        key: The key to look up\n        default: The default value to return if the key is not found\n\n    Returns:\n        The value for the key, or the default value\n\n    Raises:\n        KeyError: If the key is not found and no default value is provided\n    \"\"\"\n    if key in self._items:\n        value = self._items.pop(key)\n        self._notify_remove(key, value)\n        return value\n    if default is not None:\n        return default\n    raise KeyError(key)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.popitem","title":"<code>popitem()</code>","text":"<p>Remove and return a (key, value) pair from the dictionary.</p> <p>Returns:</p> Type Description <code>tuple[TKey, TValue]</code> <p>A (key, value) pair</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the dictionary is empty</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef popitem(self) -&gt; tuple[TKey, TValue]:\n    \"\"\"\n    Remove and return a (key, value) pair from the dictionary.\n\n    Returns:\n        A (key, value) pair\n\n    Raises:\n        KeyError: If the dictionary is empty\n    \"\"\"\n    key, value = self._items.popitem()\n    self._notify_remove(key, value)\n    return key, value\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.setdefault","title":"<code>setdefault(key, default=None)</code>","text":"<p>Return the value for a key if it exists, otherwise set and return the default value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>TKey</code> <p>The key to look up</p> required <code>default</code> <code>TValue | None</code> <p>The default value to set and return if the key is not found</p> <code>None</code> <p>Returns:</p> Type Description <code>TValue | None</code> <p>The value for the key, or the default value</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef setdefault(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"\n    Return the value for a key if it exists, otherwise set and return the default value.\n\n    Args:\n        key: The key to look up\n        default: The default value to set and return if the key is not found\n\n    Returns:\n        The value for the key, or the default value\n    \"\"\"\n    if key not in self._items:\n        self._items[key] = cast(TValue, default)  # Cast to V since we know it's a value\n        self._notify_add(key, cast(TValue, default))\n        return default\n    return self._items[key]\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.update","title":"<code>update(other)</code>","text":"<p>Update the dictionary with the key/value pairs from another dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>dict[TKey, TValue]</code> <p>Another dictionary to update from</p> required Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef update(self, other: dict[TKey, TValue]) -&gt; None:\n    \"\"\"\n    Update the dictionary with the key/value pairs from another dictionary.\n\n    Args:\n        other: Another dictionary to update from\n    \"\"\"\n    if not other:\n        return\n    added_items: dict[TKey, TValue] = {}\n    updated_items: dict[TKey, TValue] = {}\n    for key, value in other.items():\n        if key in self._items:\n            updated_items[key] = value\n        else:\n            added_items[key] = value\n    self._items.update(other)\n\n    # Notify for added items\n    if added_items:\n        for key, value in added_items.items():\n            self._notify_add(key, value)\n\n    # Notify for updated items\n    if updated_items:\n        for key, value in updated_items.items():\n            self._notify_update(key, value)\n</code></pre>"},{"location":"api_reference/observable_dict/#observant.observable_dict.ObservableDict.values","title":"<code>values()</code>","text":"<p>Return a list of all values in the dictionary.</p> <p>Returns:</p> Type Description <code>list[TValue]</code> <p>A list of values</p> Source code in <code>observant\\observable_dict.py</code> <pre><code>@override\ndef values(self) -&gt; list[TValue]:\n    \"\"\"\n    Return a list of all values in the dictionary.\n\n    Returns:\n        A list of values\n    \"\"\"\n    return list(self._items.values())\n</code></pre>"},{"location":"api_reference/observable_list/","title":"ObservableList","text":""},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList","title":"<code>observant.observable_list.ObservableList</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>IObservableList[T]</code></p> <p>Base implementation that can work with an external list or create its own.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>class ObservableList(Generic[T], IObservableList[T]):\n    \"\"\"Base implementation that can work with an external list or create its own.\"\"\"\n\n    def __init__(self, items: list[T] | None = None, *, copy: bool = False):\n        \"\"\"\n        Initialize with optional external list reference.\n\n        Args:\n            items: Optional external list to observe. If None, creates a new list.\n        \"\"\"\n        if copy:\n            self._items: list[T] = list(items) if items is not None else []\n        else:\n            self._items: list[T] = items if items is not None else []\n        self._change_callbacks: list[Callable[[ObservableListChange[T]], None]] = []\n        self._add_callbacks: list[Callable[[T, int], None]] = []\n        self._remove_callbacks: list[Callable[[T, int], None]] = []\n        self._clear_callbacks: list[Callable[[list[T]], None]] = []\n\n    @override\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of items in the list.\"\"\"\n        return len(self._items)\n\n    @override\n    def __getitem__(self, index: int | slice) -&gt; T | list[T]:\n        \"\"\"Get an item or slice of items from the list.\"\"\"\n        return self._items[index]\n\n    @override\n    def __setitem__(self, index: int | slice, value: T | list[T]) -&gt; None:\n        \"\"\"Set an item or slice of items in the list.\"\"\"\n        if isinstance(index, slice):\n            # Remove old items\n            old_items = self._items[index]\n            if old_items:\n                self._notify_remove_items(old_items, index.start)\n\n            # Add new items\n            if isinstance(value, list):\n                # Explicitly cast to list[C] to help Pylance\n                self._items[index] = value\n                if value:\n                    typed_value: list[T] = cast(list[T], value)\n                    self._notify_add_items(typed_value, index.start)\n            else:\n                # Handle single item assigned to slice\n                single_value: T = cast(T, value)\n                items_list: list[T] = [single_value]\n                self._items[index] = items_list\n                self._notify_add_items(items_list, index.start)\n        else:\n            # Remove old item\n            old_item = self._items[index]\n            self._notify_remove(old_item, index)\n\n            # Add new item\n            new_value: T = cast(T, value)  # Cast to T since we know it's a single item\n            self._items[index] = new_value\n            self._notify_add(new_value, index)\n\n    @override\n    def __delitem__(self, index: int | slice) -&gt; None:\n        \"\"\"Delete an item or slice of items from the list.\"\"\"\n        if isinstance(index, slice):\n            items = self._items[index]\n            if items:\n                self._notify_remove_items(items, index.start)\n        else:\n            item = self._items[index]\n            self._notify_remove(item, index)\n        del self._items[index]\n\n    @override\n    def __iter__(self) -&gt; Iterator[T]:\n        \"\"\"Return an iterator over the items in the list.\"\"\"\n        return iter(self._items)\n\n    @override\n    def __contains__(self, item: T) -&gt; bool:\n        \"\"\"Check if an item is in the list.\"\"\"\n        return item in self._items\n\n    @override\n    def append(self, item: T) -&gt; None:\n        \"\"\"\n        Add an item to the end of the list.\n\n        Args:\n            item: The item to add\n        \"\"\"\n        self._items.append(item)\n        self._notify_add(item, len(self._items) - 1)\n\n    @override\n    def extend(self, items: list[T]) -&gt; None:\n        \"\"\"\n        Extend the list by appending all items from the iterable.\n\n        Args:\n            items: The items to add\n        \"\"\"\n        if not items:\n            return\n        start_index = len(self._items)\n        self._items.extend(items)\n        self._notify_add_items(items, start_index)\n\n    @override\n    def insert(self, index: int, item: T) -&gt; None:\n        \"\"\"\n        Insert an item at a given position.\n\n        Args:\n            index: The position to insert the item\n            item: The item to insert\n        \"\"\"\n        self._items.insert(index, item)\n        self._notify_add(item, index)\n\n    @override\n    def remove(self, item: T) -&gt; None:\n        \"\"\"\n        Remove the first occurrence of an item from the list.\n\n        Args:\n            item: The item to remove\n\n        Raises:\n            ValueError: If the item is not in the list\n        \"\"\"\n        index = self._items.index(item)\n        self._items.remove(item)\n        self._notify_remove(item, index)\n\n    @override\n    def pop(self, index: int = -1) -&gt; T:\n        \"\"\"\n        Remove and return an item at a given position.\n\n        Args:\n            index: The position to remove the item from (default is -1, which is the last item)\n\n        Returns:\n            The removed item\n        \"\"\"\n        item = self._items[index]\n        self._items.pop(index)\n        self._notify_remove(item, index)\n        return item\n\n    @override\n    def clear(self) -&gt; None:\n        \"\"\"Remove all items from the list.\"\"\"\n        if not self._items:\n            return\n        items = self._items.copy()\n        self._items.clear()\n        self._notify_clear(items)\n\n    @override\n    def index(self, item: T, start: int = 0, end: int | None = None) -&gt; int:\n        \"\"\"\n        Return the index of the first occurrence of an item.\n\n        Args:\n            item: The item to find\n            start: The start index to search from\n            end: The end index to search to\n\n        Returns:\n            The index of the item\n\n        Raises:\n            ValueError: If the item is not in the list\n        \"\"\"\n        if end is None:\n            return self._items.index(item, start)\n        return self._items.index(item, start, end)\n\n    @override\n    def count(self, item: T) -&gt; int:\n        \"\"\"\n        Return the number of occurrences of an item in the list.\n\n        Args:\n            item: The item to count\n\n        Returns:\n            The number of occurrences\n        \"\"\"\n        return self._items.count(item)\n\n    @override\n    def sort(\n        self,\n        *,\n        key: Callable[[T], Any] | None = None,\n        reverse: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Sort the list in place.\n\n        Args:\n            key: A function that takes an item and returns a key for sorting\n            reverse: Whether to sort in reverse order\n        \"\"\"\n\n        # Note: pylance is just WRONG about the keys being wrong types.\n\n        if key is None:\n            if reverse:\n                self._items.sort(key=None, reverse=True)  # type: ignore\n            else:\n                self._items.sort(key=None, reverse=False)  # type: ignore\n        else:\n            self._items.sort(key=key, reverse=reverse)\n\n    @override\n    def reverse(self) -&gt; None:\n        \"\"\"Reverse the list in place.\"\"\"\n        self._items.reverse()\n        # No notification needed as the items themselves haven't changed\n\n    @override\n    def copy(self) -&gt; list[T]:\n        \"\"\"\n        Return a shallow copy of the list.\n\n        Returns:\n            A copy of the list\n        \"\"\"\n        return self._items.copy()\n\n    @override\n    def on_change(self, callback: Callable[[ObservableListChange[T]], None]) -&gt; None:\n        \"\"\"\n        Add a callback to be called when the list changes.\n\n        Args:\n            callback: A function that takes a ListChange object\n        \"\"\"\n        self._change_callbacks.append(callback)\n\n    @override\n    def on_add(self, callback: Callable[[T, int], None]) -&gt; None:\n        \"\"\"\n        Register for add events with item and index.\n\n        Args:\n            callback: A function that takes an item and its index\n        \"\"\"\n        self._add_callbacks.append(callback)\n\n    @override\n    def on_remove(self, callback: Callable[[T, int], None]) -&gt; None:\n        \"\"\"\n        Register for remove events with item and index.\n\n        Args:\n            callback: A function that takes an item and its index\n        \"\"\"\n        self._remove_callbacks.append(callback)\n\n    @override\n    def on_clear(self, callback: Callable[[list[T]], None]) -&gt; None:\n        \"\"\"\n        Register for clear events with the cleared items.\n\n        Args:\n            callback: A function that takes a list of cleared items\n        \"\"\"\n        self._clear_callbacks.append(callback)\n\n    def _notify_add(self, item: T, index: int) -&gt; None:\n        \"\"\"\n        Notify all callbacks of an item being added.\n\n        Args:\n            item: The item that was added\n            index: The index where the item was added\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._add_callbacks:\n            callback(item, index)\n\n        # Call general change callbacks\n        change = ObservableListChange(type=ObservableCollectionChangeType.ADD, index=index, item=item)\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_add_items(self, items: list[T], start_index: int) -&gt; None:\n        \"\"\"\n        Notify all callbacks of multiple items being added.\n\n        Args:\n            items: The items that were added\n            start_index: The index where the items were added\n        \"\"\"\n        # Call specific callbacks for each item\n        for i, item in enumerate(items):\n            index = start_index + i\n            for callback in self._add_callbacks:\n                callback(item, index)\n\n        # Call general change callbacks\n        change = ObservableListChange(type=ObservableCollectionChangeType.ADD, index=start_index, items=items)\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_remove(self, item: T, index: int) -&gt; None:\n        \"\"\"\n        Notify all callbacks of an item being removed.\n\n        Args:\n            item: The item that was removed\n            index: The index where the item was removed\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._remove_callbacks:\n            callback(item, index)\n\n        # Call general change callbacks\n        change = ObservableListChange(type=ObservableCollectionChangeType.REMOVE, index=index, item=item)\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_remove_items(self, items: list[T], start_index: int) -&gt; None:\n        \"\"\"\n        Notify all callbacks of multiple items being removed.\n\n        Args:\n            items: The items that were removed\n            start_index: The index where the items were removed\n        \"\"\"\n        # Call specific callbacks for each item\n        for i, item in enumerate(items):\n            index = start_index + i\n            for callback in self._remove_callbacks:\n                callback(item, index)\n\n        # Call general change callbacks\n        change = ObservableListChange(type=ObservableCollectionChangeType.REMOVE, index=start_index, items=items)\n        for callback in self._change_callbacks:\n            callback(change)\n\n    def _notify_clear(self, items: list[T]) -&gt; None:\n        \"\"\"\n        Notify all callbacks of the list being cleared.\n\n        Args:\n            items: The items that were cleared\n        \"\"\"\n        # Call specific callbacks\n        for callback in self._clear_callbacks:\n            callback(items)\n\n        # Call general change callbacks\n        change = ObservableListChange(type=ObservableCollectionChangeType.CLEAR, items=items)\n        for callback in self._change_callbacks:\n            callback(change)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__contains__","title":"<code>__contains__(item)</code>","text":"<p>Check if an item is in the list.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __contains__(self, item: T) -&gt; bool:\n    \"\"\"Check if an item is in the list.\"\"\"\n    return item in self._items\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__delitem__","title":"<code>__delitem__(index)</code>","text":"<p>Delete an item or slice of items from the list.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __delitem__(self, index: int | slice) -&gt; None:\n    \"\"\"Delete an item or slice of items from the list.\"\"\"\n    if isinstance(index, slice):\n        items = self._items[index]\n        if items:\n            self._notify_remove_items(items, index.start)\n    else:\n        item = self._items[index]\n        self._notify_remove(item, index)\n    del self._items[index]\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Get an item or slice of items from the list.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __getitem__(self, index: int | slice) -&gt; T | list[T]:\n    \"\"\"Get an item or slice of items from the list.\"\"\"\n    return self._items[index]\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__init__","title":"<code>__init__(items=None, *, copy=False)</code>","text":"<p>Initialize with optional external list reference.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[T] | None</code> <p>Optional external list to observe. If None, creates a new list.</p> <code>None</code> Source code in <code>observant\\observable_list.py</code> <pre><code>def __init__(self, items: list[T] | None = None, *, copy: bool = False):\n    \"\"\"\n    Initialize with optional external list reference.\n\n    Args:\n        items: Optional external list to observe. If None, creates a new list.\n    \"\"\"\n    if copy:\n        self._items: list[T] = list(items) if items is not None else []\n    else:\n        self._items: list[T] = items if items is not None else []\n    self._change_callbacks: list[Callable[[ObservableListChange[T]], None]] = []\n    self._add_callbacks: list[Callable[[T, int], None]] = []\n    self._remove_callbacks: list[Callable[[T, int], None]] = []\n    self._clear_callbacks: list[Callable[[list[T]], None]] = []\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the items in the list.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __iter__(self) -&gt; Iterator[T]:\n    \"\"\"Return an iterator over the items in the list.\"\"\"\n    return iter(self._items)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of items in the list.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __len__(self) -&gt; int:\n    \"\"\"Return the number of items in the list.\"\"\"\n    return len(self._items)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.__setitem__","title":"<code>__setitem__(index, value)</code>","text":"<p>Set an item or slice of items in the list.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef __setitem__(self, index: int | slice, value: T | list[T]) -&gt; None:\n    \"\"\"Set an item or slice of items in the list.\"\"\"\n    if isinstance(index, slice):\n        # Remove old items\n        old_items = self._items[index]\n        if old_items:\n            self._notify_remove_items(old_items, index.start)\n\n        # Add new items\n        if isinstance(value, list):\n            # Explicitly cast to list[C] to help Pylance\n            self._items[index] = value\n            if value:\n                typed_value: list[T] = cast(list[T], value)\n                self._notify_add_items(typed_value, index.start)\n        else:\n            # Handle single item assigned to slice\n            single_value: T = cast(T, value)\n            items_list: list[T] = [single_value]\n            self._items[index] = items_list\n            self._notify_add_items(items_list, index.start)\n    else:\n        # Remove old item\n        old_item = self._items[index]\n        self._notify_remove(old_item, index)\n\n        # Add new item\n        new_value: T = cast(T, value)  # Cast to T since we know it's a single item\n        self._items[index] = new_value\n        self._notify_add(new_value, index)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.append","title":"<code>append(item)</code>","text":"<p>Add an item to the end of the list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to add</p> required Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef append(self, item: T) -&gt; None:\n    \"\"\"\n    Add an item to the end of the list.\n\n    Args:\n        item: The item to add\n    \"\"\"\n    self._items.append(item)\n    self._notify_add(item, len(self._items) - 1)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.clear","title":"<code>clear()</code>","text":"<p>Remove all items from the list.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef clear(self) -&gt; None:\n    \"\"\"Remove all items from the list.\"\"\"\n    if not self._items:\n        return\n    items = self._items.copy()\n    self._items.clear()\n    self._notify_clear(items)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.copy","title":"<code>copy()</code>","text":"<p>Return a shallow copy of the list.</p> <p>Returns:</p> Type Description <code>list[T]</code> <p>A copy of the list</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef copy(self) -&gt; list[T]:\n    \"\"\"\n    Return a shallow copy of the list.\n\n    Returns:\n        A copy of the list\n    \"\"\"\n    return self._items.copy()\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.count","title":"<code>count(item)</code>","text":"<p>Return the number of occurrences of an item in the list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to count</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of occurrences</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef count(self, item: T) -&gt; int:\n    \"\"\"\n    Return the number of occurrences of an item in the list.\n\n    Args:\n        item: The item to count\n\n    Returns:\n        The number of occurrences\n    \"\"\"\n    return self._items.count(item)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.extend","title":"<code>extend(items)</code>","text":"<p>Extend the list by appending all items from the iterable.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[T]</code> <p>The items to add</p> required Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef extend(self, items: list[T]) -&gt; None:\n    \"\"\"\n    Extend the list by appending all items from the iterable.\n\n    Args:\n        items: The items to add\n    \"\"\"\n    if not items:\n        return\n    start_index = len(self._items)\n    self._items.extend(items)\n    self._notify_add_items(items, start_index)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.index","title":"<code>index(item, start=0, end=None)</code>","text":"<p>Return the index of the first occurrence of an item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to find</p> required <code>start</code> <code>int</code> <p>The start index to search from</p> <code>0</code> <code>end</code> <code>int | None</code> <p>The end index to search to</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The index of the item</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the item is not in the list</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef index(self, item: T, start: int = 0, end: int | None = None) -&gt; int:\n    \"\"\"\n    Return the index of the first occurrence of an item.\n\n    Args:\n        item: The item to find\n        start: The start index to search from\n        end: The end index to search to\n\n    Returns:\n        The index of the item\n\n    Raises:\n        ValueError: If the item is not in the list\n    \"\"\"\n    if end is None:\n        return self._items.index(item, start)\n    return self._items.index(item, start, end)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.insert","title":"<code>insert(index, item)</code>","text":"<p>Insert an item at a given position.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The position to insert the item</p> required <code>item</code> <code>T</code> <p>The item to insert</p> required Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef insert(self, index: int, item: T) -&gt; None:\n    \"\"\"\n    Insert an item at a given position.\n\n    Args:\n        index: The position to insert the item\n        item: The item to insert\n    \"\"\"\n    self._items.insert(index, item)\n    self._notify_add(item, index)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.on_add","title":"<code>on_add(callback)</code>","text":"<p>Register for add events with item and index.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[T, int], None]</code> <p>A function that takes an item and its index</p> required Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef on_add(self, callback: Callable[[T, int], None]) -&gt; None:\n    \"\"\"\n    Register for add events with item and index.\n\n    Args:\n        callback: A function that takes an item and its index\n    \"\"\"\n    self._add_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.on_change","title":"<code>on_change(callback)</code>","text":"<p>Add a callback to be called when the list changes.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ObservableListChange[T]], None]</code> <p>A function that takes a ListChange object</p> required Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef on_change(self, callback: Callable[[ObservableListChange[T]], None]) -&gt; None:\n    \"\"\"\n    Add a callback to be called when the list changes.\n\n    Args:\n        callback: A function that takes a ListChange object\n    \"\"\"\n    self._change_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.on_clear","title":"<code>on_clear(callback)</code>","text":"<p>Register for clear events with the cleared items.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[list[T]], None]</code> <p>A function that takes a list of cleared items</p> required Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef on_clear(self, callback: Callable[[list[T]], None]) -&gt; None:\n    \"\"\"\n    Register for clear events with the cleared items.\n\n    Args:\n        callback: A function that takes a list of cleared items\n    \"\"\"\n    self._clear_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.on_remove","title":"<code>on_remove(callback)</code>","text":"<p>Register for remove events with item and index.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[T, int], None]</code> <p>A function that takes an item and its index</p> required Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef on_remove(self, callback: Callable[[T, int], None]) -&gt; None:\n    \"\"\"\n    Register for remove events with item and index.\n\n    Args:\n        callback: A function that takes an item and its index\n    \"\"\"\n    self._remove_callbacks.append(callback)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.pop","title":"<code>pop(index=-1)</code>","text":"<p>Remove and return an item at a given position.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The position to remove the item from (default is -1, which is the last item)</p> <code>-1</code> <p>Returns:</p> Type Description <code>T</code> <p>The removed item</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef pop(self, index: int = -1) -&gt; T:\n    \"\"\"\n    Remove and return an item at a given position.\n\n    Args:\n        index: The position to remove the item from (default is -1, which is the last item)\n\n    Returns:\n        The removed item\n    \"\"\"\n    item = self._items[index]\n    self._items.pop(index)\n    self._notify_remove(item, index)\n    return item\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.remove","title":"<code>remove(item)</code>","text":"<p>Remove the first occurrence of an item from the list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>T</code> <p>The item to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the item is not in the list</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef remove(self, item: T) -&gt; None:\n    \"\"\"\n    Remove the first occurrence of an item from the list.\n\n    Args:\n        item: The item to remove\n\n    Raises:\n        ValueError: If the item is not in the list\n    \"\"\"\n    index = self._items.index(item)\n    self._items.remove(item)\n    self._notify_remove(item, index)\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.reverse","title":"<code>reverse()</code>","text":"<p>Reverse the list in place.</p> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef reverse(self) -&gt; None:\n    \"\"\"Reverse the list in place.\"\"\"\n    self._items.reverse()\n</code></pre>"},{"location":"api_reference/observable_list/#observant.observable_list.ObservableList.sort","title":"<code>sort(*, key=None, reverse=False)</code>","text":"<p>Sort the list in place.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], Any] | None</code> <p>A function that takes an item and returns a key for sorting</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Whether to sort in reverse order</p> <code>False</code> Source code in <code>observant\\observable_list.py</code> <pre><code>@override\ndef sort(\n    self,\n    *,\n    key: Callable[[T], Any] | None = None,\n    reverse: bool = False,\n) -&gt; None:\n    \"\"\"\n    Sort the list in place.\n\n    Args:\n        key: A function that takes an item and returns a key for sorting\n        reverse: Whether to sort in reverse order\n    \"\"\"\n\n    # Note: pylance is just WRONG about the keys being wrong types.\n\n    if key is None:\n        if reverse:\n            self._items.sort(key=None, reverse=True)  # type: ignore\n        else:\n            self._items.sort(key=None, reverse=False)  # type: ignore\n    else:\n        self._items.sort(key=key, reverse=reverse)\n</code></pre>"},{"location":"api_reference/observable_proxy/","title":"ObservableProxy","text":""},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy","title":"<code>observant.observable_proxy.ObservableProxy</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>IObservableProxy[T]</code></p> <p>Proxy for a data object that exposes its fields as Observable, ObservableList, or ObservableDict. Provides optional sync behavior to automatically write back to the source model.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>class ObservableProxy(Generic[T], IObservableProxy[T]):\n    \"\"\"\n    Proxy for a data object that exposes its fields as Observable, ObservableList, or ObservableDict.\n    Provides optional sync behavior to automatically write back to the source model.\n    \"\"\"\n\n    def __init__(\n        self,\n        obj: T,\n        *,\n        sync: bool = False,\n        undo: bool = False,  # Undo is disabled by default\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            obj: The object to proxy.\n            sync: If True, observables will sync back to the model immediately. If False, changes must be saved explicitly.\n            undo: If True, enables undo/redo functionality for all fields.\n            undo_max: Maximum number of undo steps to store. None means unlimited.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n        \"\"\"\n        self._obj = obj\n        self._sync_default = sync\n\n        # Print a warning if sync and undo are both enabled\n        if sync and undo:\n            print(\"Warning: sync=True with undo=True may cause unexpected model mutations during undo/redo.\")\n\n        self._scalars: dict[ProxyFieldKey, Observable[Any]] = {}\n        self._lists: dict[ProxyFieldKey, ObservableList[Any]] = {}\n        self._dicts: dict[ProxyFieldKey, ObservableDict[Any, Any]] = {}\n        self._computeds: dict[str, Observable[Any]] = {}\n        self._dirty_fields: set[str] = set()\n\n        # Validation related fields\n        self._validators: dict[str, list[Callable[[Any], str | None]]] = {}\n        self._validation_errors_dict = ObservableDict[str, list[str]]({})\n        self._validation_for_cache: dict[str, Observable[list[str]]] = {}\n        self._is_valid_obs = Observable[bool](True)\n\n        # Undo/redo related fields\n        self._default_undo_config = UndoConfig(enabled=undo, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n        self._field_undo_configs: dict[str, UndoConfig] = {}\n        self._undo_stacks: dict[str, list[Callable[[], None]]] = {}\n        self._redo_stacks: dict[str, list[Callable[[], None]]] = {}\n        self._last_change_times: dict[str, float] = {}\n        self._pending_undo_groups: dict[str, Callable[[], None] | None] = {}\n        self._initial_values: dict[str, Any] = {}  # Store initial values for undo\n\n    @override\n    def observable(\n        self,\n        typ: type[TValue],\n        attr: str,\n        *,\n        sync: bool | None = None,\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; IObservable[TValue]:\n        \"\"\"\n        Get or create an Observable[T] for a scalar field.\n\n        Args:\n            typ: The type of the field.\n            attr: The field name.\n            sync: Whether to sync changes back to the model immediately.\n            undo_max: Maximum number of undo steps to store. None means use the default.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n        \"\"\"\n        sync = self._sync_default if sync is None else sync\n        key = ProxyFieldKey(attr, sync)\n\n        # Set up undo config if provided\n        if undo_max is not None or undo_debounce_ms is not None:\n            self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n        # Get the initial value\n        val = getattr(self._obj, attr)\n\n        if key not in self._scalars:\n            # Create observable with callbacks disabled to prevent premature tracking\n            # obs = Observable(val, on_change_enabled=False)\n            obs = UndoableObservable(val, attr, self, on_change_enabled=False)\n\n            # Store the observable first so it can be found by _track_scalar_change\n            self._scalars[key] = obs\n\n            if sync:\n                obs.on_change(lambda v: setattr(self._obj, attr, v))\n            # Register dirty tracking callback\n            obs.on_change(lambda _: self._dirty_fields.add(attr))\n            # Register validation callback\n            obs.on_change(lambda v: self._validate_field(attr, v))\n            # Undo tracking is now handled by UndoableObservable\n\n            # Initial value tracking is now handled by UndoableObservable\n\n            # Now enable callbacks for future changes\n            obs.enable()\n        else:\n            # Get the existing observable\n            obs = self._scalars[key]\n\n        return self._scalars[key]\n\n    @override\n    def observable_list(\n        self,\n        typ: type[TValue],\n        attr: str,\n        *,\n        sync: bool | None = None,\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; IObservableList[TValue]:\n        \"\"\"\n        Get or create an ObservableList[T] for a list field.\n\n        Args:\n            typ: The type of the list elements.\n            attr: The field name.\n            sync: Whether to sync changes back to the model immediately.\n            undo_max: Maximum number of undo steps to store. None means use the default.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n        \"\"\"\n        sync = self._sync_default if sync is None else sync\n        key = ProxyFieldKey(attr, sync)\n\n        # Set up undo config if provided\n        if undo_max is not None or undo_debounce_ms is not None:\n            self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n        if key not in self._lists:\n            val_raw = getattr(self._obj, attr)\n            val: list[T] = cast(list[T], val_raw)\n            obs = ObservableList(val, copy=not sync)\n            if sync:\n                obs.on_change(lambda _: setattr(self._obj, attr, obs.copy()))\n            # Register dirty tracking callback\n            obs.on_change(lambda _: self._dirty_fields.add(attr))\n            # Register validation callback\n            obs.on_change(lambda _: self._validate_field(attr, obs.copy()))\n            # Register undo tracking callback\n            obs.on_change(lambda c: self._track_list_change(attr, c))\n            self._lists[key] = obs\n\n        return self._lists[key]\n\n    @override\n    def observable_dict(\n        self,\n        typ: tuple[type[TDictKey], type[TDictValue]],\n        attr: str,\n        *,\n        sync: bool | None = None,\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; IObservableDict[TDictKey, TDictValue]:\n        \"\"\"\n        Get or create an ObservableDict for a dict field.\n\n        Args:\n            typ: A tuple of (key_type, value_type).\n            attr: The field name.\n            sync: Whether to sync changes back to the model immediately.\n            undo_max: Maximum number of undo steps to store. None means use the default.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n        \"\"\"\n        sync = self._sync_default if sync is None else sync\n        key = ProxyFieldKey(attr, sync)\n\n        # Set up undo config if provided\n        if undo_max is not None or undo_debounce_ms is not None:\n            self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n        if key not in self._dicts:\n            val_raw = getattr(self._obj, attr)\n            val: dict[Any, Any] = cast(dict[Any, Any], val_raw)\n            obs = ObservableDict(val, copy=not sync)\n            if sync:\n                obs.on_change(lambda _: setattr(self._obj, attr, obs.copy()))\n            # Register dirty tracking callback\n            obs.on_change(lambda _: self._dirty_fields.add(attr))\n            # Register validation callback\n            obs.on_change(lambda _: self._validate_field(attr, obs.copy()))\n            # Register undo tracking callback\n            obs.on_change(lambda c: self._track_dict_change(attr, c))\n            self._dicts[key] = obs\n\n        return self._dicts[key]\n\n    @override\n    def get(self) -&gt; T:\n        \"\"\"\n        Get the original object being proxied.\n        \"\"\"\n        return self._obj\n\n    @override\n    def update(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Set one or more scalar observable values.\n        \"\"\"\n        for attr, value in kwargs.items():\n            self.observable(object, attr).set(value)\n\n    @override\n    def load_dict(self, values: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Set multiple scalar observable values from a dict.\n        \"\"\"\n        for attr, value in values.items():\n            self.observable(object, attr).set(value)\n\n    @override\n    def save_to(self, obj: T) -&gt; None:\n        \"\"\"\n        Write all observable values back into the given object.\n        \"\"\"\n        for key, obs in self._scalars.items():\n            setattr(obj, key.attr, obs.get())\n\n        for key, obs in self._lists.items():\n            setattr(obj, key.attr, obs.copy())\n\n        for key, obs in self._dicts.items():\n            setattr(obj, key.attr, obs.copy())\n\n        # Save computed fields that shadow real fields\n        for name, obs in self._computeds.items():\n            try:\n                # Check if the target object has this field\n                getattr(obj, name)\n                # If we get here, the field exists, so save the computed value\n                setattr(obj, name, obs.get())\n            except (AttributeError, TypeError):\n                # Field doesn't exist in the target object, skip it\n                pass\n\n        # Reset dirty state after saving\n        self.reset_dirty()\n\n    @override\n    def is_dirty(self) -&gt; bool:\n        \"\"\"\n        Check if any fields have been modified since initialization or last reset.\n\n        Returns:\n            True if any fields have been modified, False otherwise.\n        \"\"\"\n        return bool(self._dirty_fields)\n\n    @override\n    def dirty_fields(self) -&gt; set[str]:\n        \"\"\"\n        Get the set of field names that have been modified.\n\n        Returns:\n            A set of field names that have been modified.\n        \"\"\"\n        return set(self._dirty_fields)\n\n    @override\n    def reset_dirty(self) -&gt; None:\n        \"\"\"\n        Reset the dirty state of all fields.\n        \"\"\"\n        self._dirty_fields.clear()\n\n    @override\n    def register_computed(\n        self,\n        name: str,\n        compute: Callable[[], TValue],\n        dependencies: list[str],\n    ) -&gt; None:\n        \"\"\"\n        Register a computed property that depends on other observables.\n\n        Args:\n            name: The name of the computed property.\n            compute: A function that returns the computed value.\n            dependencies: List of field names that this computed property depends on.\n        \"\"\"\n        # Create an observable for the computed property\n        initial_value = compute()\n        obs = Observable(initial_value)\n        self._computeds[name] = obs\n\n        # Register callbacks for each dependency\n        for dep in dependencies:\n            # For scalar dependencies\n            def update_computed(_: Any) -&gt; None:\n                new_value = compute()\n                current = obs.get()\n                if new_value != current:\n                    obs.set(new_value)\n\n            # Try to find the dependency in scalars, lists, or dicts\n            for sync in [True, False]:\n                key = ProxyFieldKey(dep, sync)\n\n                if key in self._scalars:\n                    self._scalars[key].on_change(update_computed)\n                    break\n\n                if key in self._lists:\n                    self._lists[key].on_change(update_computed)\n                    break\n\n                if key in self._dicts:\n                    self._dicts[key].on_change(update_computed)\n                    break\n\n            # Check if the dependency is another computed property\n            if dep in self._computeds:\n                self._computeds[dep].on_change(update_computed)\n\n        # Validate the computed property when it changes\n        def validate_computed(_: Any) -&gt; None:\n            value = compute()\n            self._validate_field(name, value)\n\n        obs.on_change(validate_computed)\n\n    @override\n    def computed(\n        self,\n        typ: type[TValue],\n        name: str,\n    ) -&gt; IObservable[TValue]:\n        \"\"\"\n        Get a computed property by name.\n\n        Args:\n            typ: The type of the computed property.\n            name: The name of the computed property.\n\n        Returns:\n            An observable containing the computed value.\n        \"\"\"\n        if name not in self._computeds:\n            raise KeyError(f\"Computed property '{name}' not found\")\n\n        return self._computeds[name]\n\n    @override\n    def add_validator(\n        self,\n        attr: str,\n        validator: Callable[[Any], str | None],\n    ) -&gt; None:\n        \"\"\"\n        Add a validator function for a field.\n\n        Args:\n            attr: The field name to validate.\n            validator: A function that takes the field value and returns an error message\n                       if invalid, or None if valid.\n        \"\"\"\n        if attr not in self._validators:\n            self._validators[attr] = []\n\n        self._validators[attr].append(validator)\n\n        # Validate the current value if it exists\n        self._validate_field_if_exists(attr)\n\n    def _validate_field_if_exists(self, attr: str) -&gt; None:\n        \"\"\"\n        Validate a field if it exists in any of the observable collections.\n        \"\"\"\n        # Check in scalars\n        for key in self._scalars:\n            if key.attr == attr:\n                value = self._scalars[key].get()\n                self._validate_field(attr, value)\n                return\n\n        # Check in lists\n        for key in self._lists:\n            if key.attr == attr:\n                value = self._lists[key].copy()\n                self._validate_field(attr, value)\n                return\n\n        # Check in dicts\n        for key in self._dicts:\n            if key.attr == attr:\n                value = self._dicts[key].copy()\n                self._validate_field(attr, value)\n                return\n\n        # If we get here, the field doesn't exist in any observable collection yet\n        # Try to get it directly from the object\n        try:\n            value = getattr(self._obj, attr)\n            self._validate_field(attr, value)\n        except (AttributeError, TypeError):\n            # If we can't get the value, we can't validate it yet\n            pass\n\n    def _validate_field(self, attr: str, value: Any) -&gt; None:\n        \"\"\"\n        Validate a field value against all its validators.\n\n        Args:\n            attr: The field name.\n            value: The value to validate.\n        \"\"\"\n        if attr not in self._validators:\n            # No validators for this field, it's always valid\n            if attr in self._validation_errors_dict:\n                del self._validation_errors_dict[attr]\n            return\n\n        errors: list[str] = []\n\n        for validator in self._validators[attr]:\n            try:\n                result = validator(value)\n                if result is not None:\n                    errors.append(result)\n            except Exception as e:\n                errors.append(f\"Validation error: {str(e)}\")\n\n        if errors:\n            self._validation_errors_dict[attr] = errors\n        elif attr in self._validation_errors_dict:\n            del self._validation_errors_dict[attr]\n\n        # Update the is_valid observable\n        self._is_valid_obs.set(len(self._validation_errors_dict) == 0)\n\n    @override\n    def is_valid(self) -&gt; IObservable[bool]:\n        \"\"\"\n        Get an observable that indicates whether all fields are valid.\n\n        Returns:\n            An observable that emits True if all fields are valid, False otherwise.\n        \"\"\"\n        return self._is_valid_obs\n\n    @override\n    def validation_errors(self) -&gt; IObservableDict[str, list[str]]:\n        \"\"\"\n        Get an observable dictionary of validation errors.\n\n        Returns:\n            An observable dictionary mapping field names to lists of error messages.\n        \"\"\"\n        return self._validation_errors_dict\n\n    @override\n    def validation_for(self, attr: str) -&gt; IObservable[list[str]]:\n        \"\"\"\n        Get an observable list of validation errors for a specific field.\n\n        Args:\n            attr: The field name to get validation errors for.\n\n        Returns:\n            An observable that emits a list of error messages for the field.\n            An empty list means the field is valid.\n        \"\"\"\n        if attr not in self._validation_for_cache:\n            # Create a computed observable that depends on the validation errors dict\n            initial_value = self._validation_errors_dict.get(attr) or []\n            obs = Observable[list[str]](initial_value)\n\n            # Update the observable when the validation errors dict changes\n            def update_validation(_: Any) -&gt; None:\n                new_value = self._validation_errors_dict.get(attr) or []\n                current = obs.get()\n                if new_value != current:\n                    obs.set(new_value)\n\n            self._validation_errors_dict.on_change(update_validation)\n            self._validation_for_cache[attr] = obs\n\n        return self._validation_for_cache[attr]\n\n    @override\n    def reset_validation(self, attr: str | None = None, *, revalidate: bool = False) -&gt; None:\n        \"\"\"\n        Reset validation errors for a specific field or all fields.\n\n        Args:\n            attr: The field name to reset validation for. If None, reset all fields.\n            revalidate: Whether to re-run validators after clearing errors.\n        \"\"\"\n        if attr is None:\n            # Reset all validation errors\n            self._validation_errors_dict.clear()\n            # Update the is_valid observable\n            self._is_valid_obs.set(True)\n\n            # Re-run all validators if requested\n            if revalidate:\n                for field_name in self._validators.keys():\n                    self._validate_field_if_exists(field_name)\n        else:\n            # Reset validation errors for a specific field\n            if attr in self._validation_errors_dict:\n                del self._validation_errors_dict[attr]\n                # Update the is_valid observable\n                self._is_valid_obs.set(len(self._validation_errors_dict) == 0)\n\n            # Re-run validator for this field if requested\n            if revalidate:\n                self._validate_field_if_exists(attr)\n\n    @override\n    def set_undo_config(\n        self,\n        attr: str,\n        *,\n        enabled: bool | None = None,\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Set the undo configuration for a specific field.\n\n        Args:\n            attr: The field name to configure.\n            enabled: Whether undo/redo functionality is enabled for this field.\n            undo_max: Maximum number of undo steps to store. None means unlimited.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n        \"\"\"\n        # Get the current config or create a new one\n        config = self._field_undo_configs.get(attr, UndoConfig())\n\n        # Update the config with the provided values\n        if enabled is not None:\n            config.enabled = enabled\n        elif attr not in self._field_undo_configs:\n            # If this is a new config and enabled wasn't specified, inherit from default\n            config.enabled = self._default_undo_config.enabled\n\n        if undo_max is not None:\n            config.undo_max = undo_max\n        if undo_debounce_ms is not None:\n            config.undo_debounce_ms = undo_debounce_ms\n\n        # Store the updated config\n        self._field_undo_configs[attr] = config\n\n        # Enforce the max size if it's been reduced\n        if attr in self._undo_stacks and config.undo_max is not None:\n            while len(self._undo_stacks[attr]) &gt; config.undo_max:\n                self._undo_stacks[attr].pop(0)\n\n    def _get_undo_config(self, attr: str) -&gt; UndoConfig:\n        \"\"\"\n        Get the undo configuration for a field.\n\n        Args:\n            attr: The field name.\n\n        Returns:\n            The undo configuration for the field, or the default if not set.\n        \"\"\"\n        config = self._field_undo_configs.get(attr, self._default_undo_config)\n\n        # If undo_max is None, use the default from UndoConfig\n        if config.undo_max is None:\n            from observant.types.undo_config import UndoConfig as DefaultUndoConfig\n\n            config.undo_max = DefaultUndoConfig.undo_max\n\n        # Make sure the enabled flag is set correctly\n        # If this is a field-specific config, check if it has an explicit enabled flag\n        if attr in self._field_undo_configs:\n            # If the field has a specific config but no explicit enabled flag,\n            # inherit from the default config\n            if not hasattr(config, \"enabled\"):\n                config.enabled = self._default_undo_config.enabled\n\n        return config\n\n    # _track_scalar_change has been removed - UndoableObservable now handles this\n\n    def _track_list_change(self, attr: str, change: Any) -&gt; None:\n        \"\"\"\n        Track a change to a list field for undo/redo.\n\n        Args:\n            attr: The field name.\n            change: The change object.\n        \"\"\"\n        # Get the observable for this field\n        obs = None\n        for key, o in self._lists.items():\n            if key.attr == attr:\n                obs = o\n                break\n\n        if obs is None:\n            return  # Field not found\n\n        # Create a flag to prevent recursive tracking\n        tracking_enabled = [True]\n\n        # We don't need a tracking function here since it's already registered\n        # when the observable_list is created\n\n        # We don't need to add a new tracking callback here\n        # The callback is already registered when the observable_list is created\n\n        # Helper function to temporarily disable tracking\n        def with_tracking_disabled(action: Callable[[], None]) -&gt; None:\n            print(f\"DEBUG: with_tracking_disabled - Disabling tracking for {attr}\")\n            # Disable tracking during this operation\n            tracking_enabled[0] = False\n            # Perform the action\n            print(\"DEBUG: with_tracking_disabled - Executing action\")\n            action()\n            print(\"DEBUG: with_tracking_disabled - Action executed\")\n            # Re-enable tracking\n            tracking_enabled[0] = True\n            print(f\"DEBUG: with_tracking_disabled - Tracking re-enabled for {attr}\")\n\n        # Create undo/redo functions based on the change type\n        if hasattr(change, \"type\") and change.type == ObservableCollectionChangeType.CLEAR:\n            # This is a clear operation\n            old_items = change.items\n\n            def undo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs.extend(old_items)\n\n                with_tracking_disabled(action)\n\n            def redo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs.clear()\n\n                with_tracking_disabled(action)\n\n        elif hasattr(change, \"index\") and hasattr(change, \"item\"):\n            # This could be an append/insert or a remove operation\n            index = change.index\n            item = change.item\n\n            if change.type == ObservableCollectionChangeType.ADD:\n                # This is an append or insert\n                def undo_func() -&gt; None:\n                    def action() -&gt; None:\n                        if index is not None and index &lt; len(obs):  # Check if index is valid\n                            obs.pop(index)\n\n                    with_tracking_disabled(action)\n\n                def redo_func() -&gt; None:\n                    def action() -&gt; None:\n                        if index is not None:\n                            obs.insert(index, item)\n                        else:\n                            obs.append(item)\n\n                    with_tracking_disabled(action)\n            else:\n                # This is a remove operation\n                def undo_func() -&gt; None:\n                    def action() -&gt; None:\n                        if index is not None:\n                            obs.insert(index, item)\n                        else:\n                            obs.append(item)\n\n                    with_tracking_disabled(action)\n\n                def redo_func() -&gt; None:\n                    def action() -&gt; None:\n                        if index is not None and index &lt; len(obs):  # Check if index is valid\n                            obs.pop(index)\n\n                    with_tracking_disabled(action)\n\n        else:\n            # Unknown change type\n            return\n\n        # Add to the undo stack\n        self._add_to_undo_stack(attr, undo_func, redo_func, from_undo=True)\n\n    def _track_dict_change(self, attr: str, change: Any) -&gt; None:\n        \"\"\"\n        Track a change to a dict field for undo/redo.\n\n        Args:\n            attr: The field name.\n            change: The change object.\n        \"\"\"\n        # Get the observable for this field\n        obs = None\n        for key, o in self._dicts.items():\n            if key.attr == attr:\n                obs = o\n                break\n\n        if obs is None:\n            return  # Field not found\n\n        # Create a flag to prevent recursive tracking\n        tracking_enabled = [True]\n\n        # We don't need a tracking function here since it's already registered\n        # when the observable_dict is created\n\n        # We don't need to add a new tracking callback here\n        # The callback is already registered when the observable_dict is created\n\n        # Helper function to temporarily disable tracking\n        def with_tracking_disabled(action: Callable[[], None]) -&gt; None:\n            print(f\"DEBUG: dict with_tracking_disabled - Disabling tracking for {attr}\")\n            # Disable tracking during this operation\n            tracking_enabled[0] = False\n            # Perform the action\n            print(\"DEBUG: dict with_tracking_disabled - Executing action\")\n            action()\n            print(\"DEBUG: dict with_tracking_disabled - Action executed\")\n            # Re-enable tracking\n            tracking_enabled[0] = True\n            print(f\"DEBUG: dict with_tracking_disabled - Tracking re-enabled for {attr}\")\n\n        # Create undo/redo functions based on the change type\n        if hasattr(change, \"key\") and hasattr(change, \"value\") and hasattr(change, \"old_value\"):\n            # This is a key update\n            dict_key = change.key\n            value = change.value\n            old_value = change.old_value\n\n            def undo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs[dict_key] = old_value\n\n                with_tracking_disabled(action)\n\n            def redo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs[dict_key] = value\n\n                with_tracking_disabled(action)\n\n        elif hasattr(change, \"key\") and hasattr(change, \"value\") and not hasattr(change, \"old_value\"):\n            # This is a new key\n            dict_key = change.key\n            value = change.value\n\n            def undo_func() -&gt; None:\n                def action() -&gt; None:\n                    if dict_key in obs:  # Check if key exists\n                        del obs[dict_key]\n\n                with_tracking_disabled(action)\n\n            def redo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs[dict_key] = value\n\n                with_tracking_disabled(action)\n\n        elif hasattr(change, \"key\") and hasattr(change, \"value\") and change.type == ObservableCollectionChangeType.REMOVE:\n            # This is a key deletion\n            dict_key = change.key\n            old_value = change.value\n\n            print(f\"DEBUG: _track_dict_change - Creating undo/redo functions for key deletion: {dict_key}={old_value}\")\n\n            def undo_func() -&gt; None:\n                print(f\"DEBUG: dict undo_func - Starting undo for key {dict_key}\")\n                print(f\"DEBUG: dict undo_func - Observable dict: {obs}\")\n                print(f\"DEBUG: dict undo_func - Observable dict keys: {list(obs.keys())}\")\n                print(f\"DEBUG: dict undo_func - Setting key {dict_key} to value {old_value}\")\n\n                # Directly set the key in the dictionary\n                obs[dict_key] = old_value\n\n                print(f\"DEBUG: dict undo_func - After restore, keys: {list(obs.keys())}\")\n                print(f\"DEBUG: dict undo_func - Completed undo for key {dict_key}\")\n\n            def redo_func() -&gt; None:\n                print(f\"DEBUG: dict redo_func - Starting redo for key {dict_key}\")\n                print(f\"DEBUG: dict redo_func - Observable dict: {obs}\")\n                print(f\"DEBUG: dict redo_func - Observable dict keys: {list(obs.keys())}\")\n                print(f\"DEBUG: dict redo_func - Deleting key {dict_key}\")\n\n                # Directly delete the key without using the action function\n                if dict_key in obs:  # Check if key exists\n                    del obs[dict_key]\n\n                print(f\"DEBUG: dict redo_func - After delete, keys: {list(obs.keys())}\")\n                print(f\"DEBUG: dict redo_func - Completed redo for key {dict_key}\")\n\n        elif hasattr(change, \"old_items\"):\n            # This is a clear\n            old_items = change.old_items\n\n            def undo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs.update(old_items)\n\n                with_tracking_disabled(action)\n\n            def redo_func() -&gt; None:\n                def action() -&gt; None:\n                    obs.clear()\n\n                with_tracking_disabled(action)\n\n        else:\n            # Unknown change type\n            return\n\n        # Add to the undo stack\n        self._add_to_undo_stack(attr, undo_func, redo_func, from_undo=True)\n\n    def _add_to_undo_stack(self, attr: str, undo_func: Callable[[], None], redo_func: Callable[[], None], from_undo: bool = False) -&gt; None:\n        \"\"\"\n        Add an undo/redo pair to the undo stack for a field.\n\n        Args:\n            attr: The field name.\n            undo_func: The function to call to undo the change.\n            redo_func: The function to call to redo the change.\n            from_undo: Whether this is being called from the undo method.\n        \"\"\"\n        print(f\"DEBUG: _add_to_undo_stack called for {attr}, from_undo={from_undo}\")\n\n        # Initialize stacks if they don't exist\n        if attr not in self._undo_stacks:\n            self._undo_stacks[attr] = []\n            print(f\"DEBUG: _add_to_undo_stack - Initialized undo stack for {attr}\")\n        if attr not in self._redo_stacks:\n            self._redo_stacks[attr] = []\n            print(f\"DEBUG: _add_to_undo_stack - Initialized redo stack for {attr}\")\n\n        # Get the undo config for this field\n        config = self._get_undo_config(attr)\n        print(f\"DEBUG: _add_to_undo_stack - Got undo config for {attr}: undo_max={config.undo_max}, undo_debounce_ms={config.undo_debounce_ms}\")\n\n        # Check if we should debounce this change\n        now = time.monotonic() * 1000  # Convert to milliseconds\n        last_change_time = self._last_change_times.get(attr, 0)\n        debounce_window = config.undo_debounce_ms\n        time_since_last_change = now - last_change_time\n\n        print(f\"DEBUG: _add_to_undo_stack - now={now}, last_change_time={last_change_time}, time_since_last_change={time_since_last_change}ms, debounce_window={debounce_window}ms\")\n        print(f\"DEBUG: _add_to_undo_stack - pending_undo_groups for {attr}: {attr in self._pending_undo_groups}\")\n        if attr in self._pending_undo_groups:\n            print(f\"DEBUG: _add_to_undo_stack - pending_undo_groups[{attr}] is None: {self._pending_undo_groups[attr] is None}\")\n\n        if debounce_window is not None and attr in self._pending_undo_groups and self._pending_undo_groups[attr] is not None and time_since_last_change &lt; debounce_window:\n            # We're within the debounce window, update the pending group\n            # The pending group is the redo function from the previous change\n            # We replace it with the new redo function\n            print(f\"DEBUG: _add_to_undo_stack - Within debounce window, updating pending group for {attr}\")\n            self._pending_undo_groups[attr] = redo_func\n        else:\n            # We're outside the debounce window or there's no pending group\n            print(f\"DEBUG: _add_to_undo_stack - Outside debounce window or no pending group for {attr}\")\n\n            # Clear the redo stack when a new change is made, but not if we're undoing\n            if not from_undo:\n                self._redo_stacks[attr].clear()\n                print(f\"DEBUG: _add_to_undo_stack - Cleared redo stack for {attr}\")\n\n            # Add the undo function to the stack\n            self._undo_stacks[attr].append(undo_func)\n            print(f\"DEBUG: _add_to_undo_stack - Added undo function to stack for {attr}, stack size: {len(self._undo_stacks[attr])}\")\n\n            # Enforce the max size\n            if config.undo_max is not None:\n                while len(self._undo_stacks[attr]) &gt; config.undo_max:\n                    self._undo_stacks[attr].pop(0)\n                    print(f\"DEBUG: _add_to_undo_stack - Enforced max size for {attr}, removed oldest undo function\")\n\n            # Set the pending group\n            self._pending_undo_groups[attr] = redo_func\n            print(f\"DEBUG: _add_to_undo_stack - Set pending group for {attr}\")\n\n        # Update the last change time\n        self._last_change_times[attr] = now\n        print(f\"DEBUG: _add_to_undo_stack - Updated last change time for {attr} to {now}\")\n        print(f\"DEBUG: _add_to_undo_stack - Completed for {attr}\")\n\n    @override\n    def undo(self, attr: str) -&gt; None:\n        \"\"\"\n        Undo the most recent change to a field.\n\n        Args:\n            attr: The field name to undo changes for.\n        \"\"\"\n        print(f\"DEBUG: undo called for {attr}\")\n\n        if attr not in self._undo_stacks or not self._undo_stacks[attr]:\n            print(f\"DEBUG: undo - Nothing to undo for {attr}\")\n            return  # Nothing to undo\n\n        # Pop the most recent undo function\n        undo_func = self._undo_stacks[attr].pop()\n        print(f\"DEBUG: undo - Popped undo function from stack for {attr}, remaining: {len(self._undo_stacks[attr])}\")\n\n        # Get the pending redo function\n        redo_func = self._pending_undo_groups.get(attr)\n        print(f\"DEBUG: undo - Got pending redo function for {attr}: {redo_func is not None}\")\n\n        # Add to the redo stack if it exists\n        if redo_func is not None:\n            self._redo_stacks[attr].append(redo_func)\n            print(f\"DEBUG: undo - Added redo function to stack for {attr}\")\n            self._pending_undo_groups[attr] = None\n            print(f\"DEBUG: undo - Cleared pending undo group for {attr}\")\n\n        # Find the observable for this field to set the undoing flag\n        obs = None\n        for key, o in self._scalars.items():\n            if key.attr == attr:\n                obs = o\n                break\n\n        # Execute the undo function with undoing flag set\n        print(f\"DEBUG: undo - Executing undo function for {attr}\")\n        print(f\"DEBUG: undo - undo_func: {undo_func}\")\n\n        # Set the undoing flag if we found the observable and it's a UndoableObservable\n        from observant.undoable_observable import UndoableObservable\n\n        if obs is not None and isinstance(obs, UndoableObservable):\n            obs.set_undoing(True)\n\n        try:\n            undo_func()\n        finally:\n            # Reset the undoing flag\n            if obs is not None and isinstance(obs, UndoableObservable):\n                obs.set_undoing(False)\n\n        print(f\"DEBUG: undo - Completed for {attr}\")\n\n        # If sync is enabled for this field, update the model\n        for key in self._scalars:\n            if key.attr == attr and key.sync:\n                value = self._scalars[key].get()\n                setattr(self._obj, attr, value)\n                print(f\"DEBUG: undo - Synced {attr} to model with value {value}\")\n                break\n\n    @override\n    def redo(self, attr: str) -&gt; None:\n        \"\"\"\n        Redo the most recently undone change to a field.\n\n        Args:\n            attr: The field name to redo changes for.\n        \"\"\"\n        print(f\"DEBUG: redo called for {attr}\")\n        if attr not in self._redo_stacks or not self._redo_stacks[attr]:\n            print(f\"DEBUG: redo - Nothing to redo for {attr}\")\n            return  # Nothing to redo\n\n        # Pop the most recent redo function\n        redo_func = self._redo_stacks[attr].pop()\n        print(f\"DEBUG: redo - Popped redo function from stack for {attr}, remaining: {len(self._redo_stacks[attr])}\")\n\n        # Get the undo function that will undo this redo operation\n        # This is the function that was popped from the undo stack when undo was called\n        undo_func = None\n        if attr in self._pending_undo_groups:\n            undo_func = self._pending_undo_groups[attr]\n            print(f\"DEBUG: redo - Got pending undo function for {attr}: {undo_func is not None}\")\n\n        # Find the observable for this field to manually track changes\n        # We need to do this because the redo function disables tracking\n        obs_list = None\n        obs_dict = None\n\n        # Check if this is a list field\n        for key, o in self._lists.items():\n            if key.attr == attr:\n                obs_list = o\n                print(f\"DEBUG: redo - Found list observable for {attr}\")\n                break\n\n        # Check if this is a dict field\n        if obs_list is None:\n            for key, o in self._dicts.items():\n                if key.attr == attr:\n                    obs_dict = o\n                    print(f\"DEBUG: redo - Found dict observable for {attr}\")\n                    break\n\n        # We don't need to simulate change objects anymore\n\n        # Find the scalar observable for this field to set the undoing flag\n        obs_scalar = None\n        for key, o in self._scalars.items():\n            if key.attr == attr:\n                obs_scalar = o\n                break\n\n        # Execute the redo function with undoing flag set\n        print(f\"DEBUG: redo - Executing redo function for {attr}\")\n\n        # Set the undoing flag if we found the observable and it's a UndoableObservable\n        from observant.undoable_observable import UndoableObservable\n\n        if obs_scalar is not None and isinstance(obs_scalar, UndoableObservable):\n            obs_scalar.set_undoing(True)\n\n        try:\n            redo_func()\n        finally:\n            # Reset the undoing flag\n            if obs_scalar is not None and isinstance(obs_scalar, UndoableObservable):\n                obs_scalar.set_undoing(False)\n\n        print(f\"DEBUG: redo - Redo function executed for {attr}\")\n\n        # Add the undo function back to the undo stack\n        # This is necessary because the redo function disables tracking\n        if undo_func is not None:\n            self._undo_stacks.setdefault(attr, []).append(undo_func)\n            print(f\"DEBUG: redo - Added undo function back to stack for {attr}, stack size: {len(self._undo_stacks[attr])}\")\n            # Clear the pending undo group since we've used it\n            self._pending_undo_groups[attr] = None\n            print(f\"DEBUG: redo - Cleared pending undo group for {attr}\")\n        else:\n            # If we don't have an undo function from the pending group,\n            # we need to create one based on the current state\n            print(\"DEBUG: redo - No pending undo function, creating one\")\n\n            # For scalar fields\n            for key, o in self._scalars.items():\n                if key.attr == attr:\n                    # Create an undo function that will restore the current value\n                    current_value = o.get()\n\n                    def new_undo_func() -&gt; None:\n                        print(f\"DEBUG: new_undo_func called for {attr}\")\n                        o.set(current_value, notify=False)\n                        print(f\"DEBUG: new_undo_func completed for {attr}\")\n\n                    # Add it to the undo stack\n                    self._undo_stacks.setdefault(attr, []).append(new_undo_func)\n                    print(f\"DEBUG: redo - Created and added new undo function for scalar {attr}\")\n                    break\n\n            # For list fields\n            if obs_list is not None:\n                # Create an undo function that will restore the current list state\n                current_list = obs_list.copy()\n\n                def new_list_undo_func() -&gt; None:\n                    print(f\"DEBUG: new_list_undo_func called for {attr}\")\n                    # Clear the list and add all items back\n                    obs_list.clear()\n                    obs_list.extend(current_list)\n                    print(f\"DEBUG: new_list_undo_func completed for {attr}\")\n\n                # Add it to the undo stack\n                self._undo_stacks.setdefault(attr, []).append(new_list_undo_func)\n                print(f\"DEBUG: redo - Created and added new undo function for list {attr}\")\n\n            # For dict fields\n            if obs_dict is not None:\n                # Create an undo function that will restore the current dict state\n                current_dict = obs_dict.copy()\n\n                def new_dict_undo_func() -&gt; None:\n                    print(f\"DEBUG: new_dict_undo_func called for {attr}\")\n                    # Clear the dict and add all items back\n                    obs_dict.clear()\n                    obs_dict.update(current_dict)\n                    print(f\"DEBUG: new_dict_undo_func completed for {attr}\")\n\n                # Add it to the undo stack\n                self._undo_stacks.setdefault(attr, []).append(new_dict_undo_func)\n                print(f\"DEBUG: redo - Created and added new undo function for dict {attr}\")\n\n        print(f\"DEBUG: redo - Completed for {attr}\")\n\n        # If sync is enabled for this field, update the model\n        for key in self._scalars:\n            if key.attr == attr and key.sync:\n                value = self._scalars[key].get()\n                setattr(self._obj, attr, value)\n                print(f\"DEBUG: redo - Synced {attr} to model with value {value}\")\n                break\n\n    @override\n    def can_undo(self, attr: str) -&gt; bool:\n        \"\"\"\n        Check if there are changes that can be undone for a field.\n\n        Args:\n            attr: The field name to check.\n\n        Returns:\n            True if there are changes that can be undone, False otherwise.\n        \"\"\"\n        return attr in self._undo_stacks and bool(self._undo_stacks[attr])\n\n    @override\n    def can_redo(self, attr: str) -&gt; bool:\n        \"\"\"\n        Check if there are changes that can be redone for a field.\n\n        Args:\n            attr: The field name to check.\n\n        Returns:\n            True if there are changes that can be redone, False otherwise.\n        \"\"\"\n        return attr in self._redo_stacks and bool(self._redo_stacks[attr])\n\n    @override\n    def track_scalar_change(self, attr: str, old_value: Any, new_value: Any) -&gt; None:\n        \"\"\"\n        Track a scalar change for undo/redo functionality.\n\n        Args:\n            attr: The field name that changed.\n            old_value: The old value before the change.\n            new_value: The new value after the change.\n        \"\"\"\n        print(f\"DEBUG: track_scalar_change called for {attr} with old={old_value}, new={new_value}\")\n        if old_value == new_value:\n            print(\"DEBUG: values are the same, skipping\")\n            return\n\n        # Check if undo is enabled for this field\n        config = self._get_undo_config(attr)\n        if not config.enabled:\n            print(f\"DEBUG: undo is disabled for {attr}, skipping\")\n            return\n\n        # Get the observable for this field\n        obs = None\n        for key, o in self._scalars.items():\n            if key.attr == attr:\n                obs = o\n                break\n\n        if obs is None:\n            print(f\"DEBUG: track_scalar_change - Field {attr} not found\")\n            return  # Field not found\n\n        # Create undo/redo functions\n        def undo_func() -&gt; None:\n            print(f\"DEBUG: undo_func called for {attr}, setting value to {old_value}\")\n            # Set the old value with triggering callbacks to ensure computed properties update\n            obs.set(old_value)\n\n            # If we're undoing to the original value, clear the dirty state\n            if old_value == self._initial_values.get(attr):\n                self._dirty_fields.discard(attr)\n\n            print(f\"DEBUG: undo_func completed for {attr}\")\n\n        def redo_func() -&gt; None:\n            print(f\"DEBUG: redo_func called for {attr}, setting value to {new_value}\")\n            # Set the new value with triggering callbacks to ensure computed properties update\n            obs.set(new_value)\n\n            # If we're redoing to a non-original value, mark as dirty\n            if new_value != self._initial_values.get(attr):\n                self._dirty_fields.add(attr)\n\n            print(f\"DEBUG: redo_func completed for {attr}\")\n\n        # Add to the undo stack\n        print(f\"DEBUG: track_scalar_change - Calling _add_to_undo_stack for {attr}\")\n        self._add_to_undo_stack(attr, undo_func, redo_func)\n        print(f\"DEBUG: track_scalar_change - Completed for {attr}\")\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.__init__","title":"<code>__init__(obj, *, sync=False, undo=False, undo_max=None, undo_debounce_ms=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>obj</code> <code>T</code> <p>The object to proxy.</p> required <code>sync</code> <code>bool</code> <p>If True, observables will sync back to the model immediately. If False, changes must be saved explicitly.</p> <code>False</code> <code>undo</code> <code>bool</code> <p>If True, enables undo/redo functionality for all fields.</p> <code>False</code> <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means unlimited.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means no debouncing.</p> <code>None</code> Source code in <code>observant\\observable_proxy.py</code> <pre><code>def __init__(\n    self,\n    obj: T,\n    *,\n    sync: bool = False,\n    undo: bool = False,  # Undo is disabled by default\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Args:\n        obj: The object to proxy.\n        sync: If True, observables will sync back to the model immediately. If False, changes must be saved explicitly.\n        undo: If True, enables undo/redo functionality for all fields.\n        undo_max: Maximum number of undo steps to store. None means unlimited.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n    \"\"\"\n    self._obj = obj\n    self._sync_default = sync\n\n    # Print a warning if sync and undo are both enabled\n    if sync and undo:\n        print(\"Warning: sync=True with undo=True may cause unexpected model mutations during undo/redo.\")\n\n    self._scalars: dict[ProxyFieldKey, Observable[Any]] = {}\n    self._lists: dict[ProxyFieldKey, ObservableList[Any]] = {}\n    self._dicts: dict[ProxyFieldKey, ObservableDict[Any, Any]] = {}\n    self._computeds: dict[str, Observable[Any]] = {}\n    self._dirty_fields: set[str] = set()\n\n    # Validation related fields\n    self._validators: dict[str, list[Callable[[Any], str | None]]] = {}\n    self._validation_errors_dict = ObservableDict[str, list[str]]({})\n    self._validation_for_cache: dict[str, Observable[list[str]]] = {}\n    self._is_valid_obs = Observable[bool](True)\n\n    # Undo/redo related fields\n    self._default_undo_config = UndoConfig(enabled=undo, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n    self._field_undo_configs: dict[str, UndoConfig] = {}\n    self._undo_stacks: dict[str, list[Callable[[], None]]] = {}\n    self._redo_stacks: dict[str, list[Callable[[], None]]] = {}\n    self._last_change_times: dict[str, float] = {}\n    self._pending_undo_groups: dict[str, Callable[[], None] | None] = {}\n    self._initial_values: dict[str, Any] = {}  # Store initial values for undo\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.add_validator","title":"<code>add_validator(attr, validator)</code>","text":"<p>Add a validator function for a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to validate.</p> required <code>validator</code> <code>Callable[[Any], str | None]</code> <p>A function that takes the field value and returns an error message        if invalid, or None if valid.</p> required Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef add_validator(\n    self,\n    attr: str,\n    validator: Callable[[Any], str | None],\n) -&gt; None:\n    \"\"\"\n    Add a validator function for a field.\n\n    Args:\n        attr: The field name to validate.\n        validator: A function that takes the field value and returns an error message\n                   if invalid, or None if valid.\n    \"\"\"\n    if attr not in self._validators:\n        self._validators[attr] = []\n\n    self._validators[attr].append(validator)\n\n    # Validate the current value if it exists\n    self._validate_field_if_exists(attr)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.can_redo","title":"<code>can_redo(attr)</code>","text":"<p>Check if there are changes that can be redone for a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there are changes that can be redone, False otherwise.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef can_redo(self, attr: str) -&gt; bool:\n    \"\"\"\n    Check if there are changes that can be redone for a field.\n\n    Args:\n        attr: The field name to check.\n\n    Returns:\n        True if there are changes that can be redone, False otherwise.\n    \"\"\"\n    return attr in self._redo_stacks and bool(self._redo_stacks[attr])\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.can_undo","title":"<code>can_undo(attr)</code>","text":"<p>Check if there are changes that can be undone for a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there are changes that can be undone, False otherwise.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef can_undo(self, attr: str) -&gt; bool:\n    \"\"\"\n    Check if there are changes that can be undone for a field.\n\n    Args:\n        attr: The field name to check.\n\n    Returns:\n        True if there are changes that can be undone, False otherwise.\n    \"\"\"\n    return attr in self._undo_stacks and bool(self._undo_stacks[attr])\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.computed","title":"<code>computed(typ, name)</code>","text":"<p>Get a computed property by name.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>type[TValue]</code> <p>The type of the computed property.</p> required <code>name</code> <code>str</code> <p>The name of the computed property.</p> required <p>Returns:</p> Type Description <code>IObservable[TValue]</code> <p>An observable containing the computed value.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef computed(\n    self,\n    typ: type[TValue],\n    name: str,\n) -&gt; IObservable[TValue]:\n    \"\"\"\n    Get a computed property by name.\n\n    Args:\n        typ: The type of the computed property.\n        name: The name of the computed property.\n\n    Returns:\n        An observable containing the computed value.\n    \"\"\"\n    if name not in self._computeds:\n        raise KeyError(f\"Computed property '{name}' not found\")\n\n    return self._computeds[name]\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.dirty_fields","title":"<code>dirty_fields()</code>","text":"<p>Get the set of field names that have been modified.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of field names that have been modified.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef dirty_fields(self) -&gt; set[str]:\n    \"\"\"\n    Get the set of field names that have been modified.\n\n    Returns:\n        A set of field names that have been modified.\n    \"\"\"\n    return set(self._dirty_fields)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.get","title":"<code>get()</code>","text":"<p>Get the original object being proxied.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef get(self) -&gt; T:\n    \"\"\"\n    Get the original object being proxied.\n    \"\"\"\n    return self._obj\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.is_dirty","title":"<code>is_dirty()</code>","text":"<p>Check if any fields have been modified since initialization or last reset.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if any fields have been modified, False otherwise.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef is_dirty(self) -&gt; bool:\n    \"\"\"\n    Check if any fields have been modified since initialization or last reset.\n\n    Returns:\n        True if any fields have been modified, False otherwise.\n    \"\"\"\n    return bool(self._dirty_fields)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.is_valid","title":"<code>is_valid()</code>","text":"<p>Get an observable that indicates whether all fields are valid.</p> <p>Returns:</p> Type Description <code>IObservable[bool]</code> <p>An observable that emits True if all fields are valid, False otherwise.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef is_valid(self) -&gt; IObservable[bool]:\n    \"\"\"\n    Get an observable that indicates whether all fields are valid.\n\n    Returns:\n        An observable that emits True if all fields are valid, False otherwise.\n    \"\"\"\n    return self._is_valid_obs\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.load_dict","title":"<code>load_dict(values)</code>","text":"<p>Set multiple scalar observable values from a dict.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef load_dict(self, values: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Set multiple scalar observable values from a dict.\n    \"\"\"\n    for attr, value in values.items():\n        self.observable(object, attr).set(value)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.observable","title":"<code>observable(typ, attr, *, sync=None, undo_max=None, undo_debounce_ms=None)</code>","text":"<p>Get or create an Observable[T] for a scalar field.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>type[TValue]</code> <p>The type of the field.</p> required <code>attr</code> <code>str</code> <p>The field name.</p> required <code>sync</code> <code>bool | None</code> <p>Whether to sync changes back to the model immediately.</p> <code>None</code> <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means use the default.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means use the default.</p> <code>None</code> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef observable(\n    self,\n    typ: type[TValue],\n    attr: str,\n    *,\n    sync: bool | None = None,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; IObservable[TValue]:\n    \"\"\"\n    Get or create an Observable[T] for a scalar field.\n\n    Args:\n        typ: The type of the field.\n        attr: The field name.\n        sync: Whether to sync changes back to the model immediately.\n        undo_max: Maximum number of undo steps to store. None means use the default.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n    \"\"\"\n    sync = self._sync_default if sync is None else sync\n    key = ProxyFieldKey(attr, sync)\n\n    # Set up undo config if provided\n    if undo_max is not None or undo_debounce_ms is not None:\n        self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n    # Get the initial value\n    val = getattr(self._obj, attr)\n\n    if key not in self._scalars:\n        # Create observable with callbacks disabled to prevent premature tracking\n        # obs = Observable(val, on_change_enabled=False)\n        obs = UndoableObservable(val, attr, self, on_change_enabled=False)\n\n        # Store the observable first so it can be found by _track_scalar_change\n        self._scalars[key] = obs\n\n        if sync:\n            obs.on_change(lambda v: setattr(self._obj, attr, v))\n        # Register dirty tracking callback\n        obs.on_change(lambda _: self._dirty_fields.add(attr))\n        # Register validation callback\n        obs.on_change(lambda v: self._validate_field(attr, v))\n        # Undo tracking is now handled by UndoableObservable\n\n        # Initial value tracking is now handled by UndoableObservable\n\n        # Now enable callbacks for future changes\n        obs.enable()\n    else:\n        # Get the existing observable\n        obs = self._scalars[key]\n\n    return self._scalars[key]\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.observable_dict","title":"<code>observable_dict(typ, attr, *, sync=None, undo_max=None, undo_debounce_ms=None)</code>","text":"<p>Get or create an ObservableDict for a dict field.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>tuple[type[TDictKey], type[TDictValue]]</code> <p>A tuple of (key_type, value_type).</p> required <code>attr</code> <code>str</code> <p>The field name.</p> required <code>sync</code> <code>bool | None</code> <p>Whether to sync changes back to the model immediately.</p> <code>None</code> <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means use the default.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means use the default.</p> <code>None</code> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef observable_dict(\n    self,\n    typ: tuple[type[TDictKey], type[TDictValue]],\n    attr: str,\n    *,\n    sync: bool | None = None,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; IObservableDict[TDictKey, TDictValue]:\n    \"\"\"\n    Get or create an ObservableDict for a dict field.\n\n    Args:\n        typ: A tuple of (key_type, value_type).\n        attr: The field name.\n        sync: Whether to sync changes back to the model immediately.\n        undo_max: Maximum number of undo steps to store. None means use the default.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n    \"\"\"\n    sync = self._sync_default if sync is None else sync\n    key = ProxyFieldKey(attr, sync)\n\n    # Set up undo config if provided\n    if undo_max is not None or undo_debounce_ms is not None:\n        self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n    if key not in self._dicts:\n        val_raw = getattr(self._obj, attr)\n        val: dict[Any, Any] = cast(dict[Any, Any], val_raw)\n        obs = ObservableDict(val, copy=not sync)\n        if sync:\n            obs.on_change(lambda _: setattr(self._obj, attr, obs.copy()))\n        # Register dirty tracking callback\n        obs.on_change(lambda _: self._dirty_fields.add(attr))\n        # Register validation callback\n        obs.on_change(lambda _: self._validate_field(attr, obs.copy()))\n        # Register undo tracking callback\n        obs.on_change(lambda c: self._track_dict_change(attr, c))\n        self._dicts[key] = obs\n\n    return self._dicts[key]\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.observable_list","title":"<code>observable_list(typ, attr, *, sync=None, undo_max=None, undo_debounce_ms=None)</code>","text":"<p>Get or create an ObservableList[T] for a list field.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>type[TValue]</code> <p>The type of the list elements.</p> required <code>attr</code> <code>str</code> <p>The field name.</p> required <code>sync</code> <code>bool | None</code> <p>Whether to sync changes back to the model immediately.</p> <code>None</code> <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means use the default.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means use the default.</p> <code>None</code> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef observable_list(\n    self,\n    typ: type[TValue],\n    attr: str,\n    *,\n    sync: bool | None = None,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; IObservableList[TValue]:\n    \"\"\"\n    Get or create an ObservableList[T] for a list field.\n\n    Args:\n        typ: The type of the list elements.\n        attr: The field name.\n        sync: Whether to sync changes back to the model immediately.\n        undo_max: Maximum number of undo steps to store. None means use the default.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means use the default.\n    \"\"\"\n    sync = self._sync_default if sync is None else sync\n    key = ProxyFieldKey(attr, sync)\n\n    # Set up undo config if provided\n    if undo_max is not None or undo_debounce_ms is not None:\n        self.set_undo_config(attr, undo_max=undo_max, undo_debounce_ms=undo_debounce_ms)\n\n    if key not in self._lists:\n        val_raw = getattr(self._obj, attr)\n        val: list[T] = cast(list[T], val_raw)\n        obs = ObservableList(val, copy=not sync)\n        if sync:\n            obs.on_change(lambda _: setattr(self._obj, attr, obs.copy()))\n        # Register dirty tracking callback\n        obs.on_change(lambda _: self._dirty_fields.add(attr))\n        # Register validation callback\n        obs.on_change(lambda _: self._validate_field(attr, obs.copy()))\n        # Register undo tracking callback\n        obs.on_change(lambda c: self._track_list_change(attr, c))\n        self._lists[key] = obs\n\n    return self._lists[key]\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.redo","title":"<code>redo(attr)</code>","text":"<p>Redo the most recently undone change to a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to redo changes for.</p> required Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef redo(self, attr: str) -&gt; None:\n    \"\"\"\n    Redo the most recently undone change to a field.\n\n    Args:\n        attr: The field name to redo changes for.\n    \"\"\"\n    print(f\"DEBUG: redo called for {attr}\")\n    if attr not in self._redo_stacks or not self._redo_stacks[attr]:\n        print(f\"DEBUG: redo - Nothing to redo for {attr}\")\n        return  # Nothing to redo\n\n    # Pop the most recent redo function\n    redo_func = self._redo_stacks[attr].pop()\n    print(f\"DEBUG: redo - Popped redo function from stack for {attr}, remaining: {len(self._redo_stacks[attr])}\")\n\n    # Get the undo function that will undo this redo operation\n    # This is the function that was popped from the undo stack when undo was called\n    undo_func = None\n    if attr in self._pending_undo_groups:\n        undo_func = self._pending_undo_groups[attr]\n        print(f\"DEBUG: redo - Got pending undo function for {attr}: {undo_func is not None}\")\n\n    # Find the observable for this field to manually track changes\n    # We need to do this because the redo function disables tracking\n    obs_list = None\n    obs_dict = None\n\n    # Check if this is a list field\n    for key, o in self._lists.items():\n        if key.attr == attr:\n            obs_list = o\n            print(f\"DEBUG: redo - Found list observable for {attr}\")\n            break\n\n    # Check if this is a dict field\n    if obs_list is None:\n        for key, o in self._dicts.items():\n            if key.attr == attr:\n                obs_dict = o\n                print(f\"DEBUG: redo - Found dict observable for {attr}\")\n                break\n\n    # We don't need to simulate change objects anymore\n\n    # Find the scalar observable for this field to set the undoing flag\n    obs_scalar = None\n    for key, o in self._scalars.items():\n        if key.attr == attr:\n            obs_scalar = o\n            break\n\n    # Execute the redo function with undoing flag set\n    print(f\"DEBUG: redo - Executing redo function for {attr}\")\n\n    # Set the undoing flag if we found the observable and it's a UndoableObservable\n    from observant.undoable_observable import UndoableObservable\n\n    if obs_scalar is not None and isinstance(obs_scalar, UndoableObservable):\n        obs_scalar.set_undoing(True)\n\n    try:\n        redo_func()\n    finally:\n        # Reset the undoing flag\n        if obs_scalar is not None and isinstance(obs_scalar, UndoableObservable):\n            obs_scalar.set_undoing(False)\n\n    print(f\"DEBUG: redo - Redo function executed for {attr}\")\n\n    # Add the undo function back to the undo stack\n    # This is necessary because the redo function disables tracking\n    if undo_func is not None:\n        self._undo_stacks.setdefault(attr, []).append(undo_func)\n        print(f\"DEBUG: redo - Added undo function back to stack for {attr}, stack size: {len(self._undo_stacks[attr])}\")\n        # Clear the pending undo group since we've used it\n        self._pending_undo_groups[attr] = None\n        print(f\"DEBUG: redo - Cleared pending undo group for {attr}\")\n    else:\n        # If we don't have an undo function from the pending group,\n        # we need to create one based on the current state\n        print(\"DEBUG: redo - No pending undo function, creating one\")\n\n        # For scalar fields\n        for key, o in self._scalars.items():\n            if key.attr == attr:\n                # Create an undo function that will restore the current value\n                current_value = o.get()\n\n                def new_undo_func() -&gt; None:\n                    print(f\"DEBUG: new_undo_func called for {attr}\")\n                    o.set(current_value, notify=False)\n                    print(f\"DEBUG: new_undo_func completed for {attr}\")\n\n                # Add it to the undo stack\n                self._undo_stacks.setdefault(attr, []).append(new_undo_func)\n                print(f\"DEBUG: redo - Created and added new undo function for scalar {attr}\")\n                break\n\n        # For list fields\n        if obs_list is not None:\n            # Create an undo function that will restore the current list state\n            current_list = obs_list.copy()\n\n            def new_list_undo_func() -&gt; None:\n                print(f\"DEBUG: new_list_undo_func called for {attr}\")\n                # Clear the list and add all items back\n                obs_list.clear()\n                obs_list.extend(current_list)\n                print(f\"DEBUG: new_list_undo_func completed for {attr}\")\n\n            # Add it to the undo stack\n            self._undo_stacks.setdefault(attr, []).append(new_list_undo_func)\n            print(f\"DEBUG: redo - Created and added new undo function for list {attr}\")\n\n        # For dict fields\n        if obs_dict is not None:\n            # Create an undo function that will restore the current dict state\n            current_dict = obs_dict.copy()\n\n            def new_dict_undo_func() -&gt; None:\n                print(f\"DEBUG: new_dict_undo_func called for {attr}\")\n                # Clear the dict and add all items back\n                obs_dict.clear()\n                obs_dict.update(current_dict)\n                print(f\"DEBUG: new_dict_undo_func completed for {attr}\")\n\n            # Add it to the undo stack\n            self._undo_stacks.setdefault(attr, []).append(new_dict_undo_func)\n            print(f\"DEBUG: redo - Created and added new undo function for dict {attr}\")\n\n    print(f\"DEBUG: redo - Completed for {attr}\")\n\n    # If sync is enabled for this field, update the model\n    for key in self._scalars:\n        if key.attr == attr and key.sync:\n            value = self._scalars[key].get()\n            setattr(self._obj, attr, value)\n            print(f\"DEBUG: redo - Synced {attr} to model with value {value}\")\n            break\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.register_computed","title":"<code>register_computed(name, compute, dependencies)</code>","text":"<p>Register a computed property that depends on other observables.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the computed property.</p> required <code>compute</code> <code>Callable[[], TValue]</code> <p>A function that returns the computed value.</p> required <code>dependencies</code> <code>list[str]</code> <p>List of field names that this computed property depends on.</p> required Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef register_computed(\n    self,\n    name: str,\n    compute: Callable[[], TValue],\n    dependencies: list[str],\n) -&gt; None:\n    \"\"\"\n    Register a computed property that depends on other observables.\n\n    Args:\n        name: The name of the computed property.\n        compute: A function that returns the computed value.\n        dependencies: List of field names that this computed property depends on.\n    \"\"\"\n    # Create an observable for the computed property\n    initial_value = compute()\n    obs = Observable(initial_value)\n    self._computeds[name] = obs\n\n    # Register callbacks for each dependency\n    for dep in dependencies:\n        # For scalar dependencies\n        def update_computed(_: Any) -&gt; None:\n            new_value = compute()\n            current = obs.get()\n            if new_value != current:\n                obs.set(new_value)\n\n        # Try to find the dependency in scalars, lists, or dicts\n        for sync in [True, False]:\n            key = ProxyFieldKey(dep, sync)\n\n            if key in self._scalars:\n                self._scalars[key].on_change(update_computed)\n                break\n\n            if key in self._lists:\n                self._lists[key].on_change(update_computed)\n                break\n\n            if key in self._dicts:\n                self._dicts[key].on_change(update_computed)\n                break\n\n        # Check if the dependency is another computed property\n        if dep in self._computeds:\n            self._computeds[dep].on_change(update_computed)\n\n    # Validate the computed property when it changes\n    def validate_computed(_: Any) -&gt; None:\n        value = compute()\n        self._validate_field(name, value)\n\n    obs.on_change(validate_computed)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.reset_dirty","title":"<code>reset_dirty()</code>","text":"<p>Reset the dirty state of all fields.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef reset_dirty(self) -&gt; None:\n    \"\"\"\n    Reset the dirty state of all fields.\n    \"\"\"\n    self._dirty_fields.clear()\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.reset_validation","title":"<code>reset_validation(attr=None, *, revalidate=False)</code>","text":"<p>Reset validation errors for a specific field or all fields.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str | None</code> <p>The field name to reset validation for. If None, reset all fields.</p> <code>None</code> <code>revalidate</code> <code>bool</code> <p>Whether to re-run validators after clearing errors.</p> <code>False</code> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef reset_validation(self, attr: str | None = None, *, revalidate: bool = False) -&gt; None:\n    \"\"\"\n    Reset validation errors for a specific field or all fields.\n\n    Args:\n        attr: The field name to reset validation for. If None, reset all fields.\n        revalidate: Whether to re-run validators after clearing errors.\n    \"\"\"\n    if attr is None:\n        # Reset all validation errors\n        self._validation_errors_dict.clear()\n        # Update the is_valid observable\n        self._is_valid_obs.set(True)\n\n        # Re-run all validators if requested\n        if revalidate:\n            for field_name in self._validators.keys():\n                self._validate_field_if_exists(field_name)\n    else:\n        # Reset validation errors for a specific field\n        if attr in self._validation_errors_dict:\n            del self._validation_errors_dict[attr]\n            # Update the is_valid observable\n            self._is_valid_obs.set(len(self._validation_errors_dict) == 0)\n\n        # Re-run validator for this field if requested\n        if revalidate:\n            self._validate_field_if_exists(attr)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.save_to","title":"<code>save_to(obj)</code>","text":"<p>Write all observable values back into the given object.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef save_to(self, obj: T) -&gt; None:\n    \"\"\"\n    Write all observable values back into the given object.\n    \"\"\"\n    for key, obs in self._scalars.items():\n        setattr(obj, key.attr, obs.get())\n\n    for key, obs in self._lists.items():\n        setattr(obj, key.attr, obs.copy())\n\n    for key, obs in self._dicts.items():\n        setattr(obj, key.attr, obs.copy())\n\n    # Save computed fields that shadow real fields\n    for name, obs in self._computeds.items():\n        try:\n            # Check if the target object has this field\n            getattr(obj, name)\n            # If we get here, the field exists, so save the computed value\n            setattr(obj, name, obs.get())\n        except (AttributeError, TypeError):\n            # Field doesn't exist in the target object, skip it\n            pass\n\n    # Reset dirty state after saving\n    self.reset_dirty()\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.set_undo_config","title":"<code>set_undo_config(attr, *, enabled=None, undo_max=None, undo_debounce_ms=None)</code>","text":"<p>Set the undo configuration for a specific field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to configure.</p> required <code>enabled</code> <code>bool | None</code> <p>Whether undo/redo functionality is enabled for this field.</p> <code>None</code> <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means unlimited.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means no debouncing.</p> <code>None</code> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef set_undo_config(\n    self,\n    attr: str,\n    *,\n    enabled: bool | None = None,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Set the undo configuration for a specific field.\n\n    Args:\n        attr: The field name to configure.\n        enabled: Whether undo/redo functionality is enabled for this field.\n        undo_max: Maximum number of undo steps to store. None means unlimited.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n    \"\"\"\n    # Get the current config or create a new one\n    config = self._field_undo_configs.get(attr, UndoConfig())\n\n    # Update the config with the provided values\n    if enabled is not None:\n        config.enabled = enabled\n    elif attr not in self._field_undo_configs:\n        # If this is a new config and enabled wasn't specified, inherit from default\n        config.enabled = self._default_undo_config.enabled\n\n    if undo_max is not None:\n        config.undo_max = undo_max\n    if undo_debounce_ms is not None:\n        config.undo_debounce_ms = undo_debounce_ms\n\n    # Store the updated config\n    self._field_undo_configs[attr] = config\n\n    # Enforce the max size if it's been reduced\n    if attr in self._undo_stacks and config.undo_max is not None:\n        while len(self._undo_stacks[attr]) &gt; config.undo_max:\n            self._undo_stacks[attr].pop(0)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.track_scalar_change","title":"<code>track_scalar_change(attr, old_value, new_value)</code>","text":"<p>Track a scalar change for undo/redo functionality.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name that changed.</p> required <code>old_value</code> <code>Any</code> <p>The old value before the change.</p> required <code>new_value</code> <code>Any</code> <p>The new value after the change.</p> required Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef track_scalar_change(self, attr: str, old_value: Any, new_value: Any) -&gt; None:\n    \"\"\"\n    Track a scalar change for undo/redo functionality.\n\n    Args:\n        attr: The field name that changed.\n        old_value: The old value before the change.\n        new_value: The new value after the change.\n    \"\"\"\n    print(f\"DEBUG: track_scalar_change called for {attr} with old={old_value}, new={new_value}\")\n    if old_value == new_value:\n        print(\"DEBUG: values are the same, skipping\")\n        return\n\n    # Check if undo is enabled for this field\n    config = self._get_undo_config(attr)\n    if not config.enabled:\n        print(f\"DEBUG: undo is disabled for {attr}, skipping\")\n        return\n\n    # Get the observable for this field\n    obs = None\n    for key, o in self._scalars.items():\n        if key.attr == attr:\n            obs = o\n            break\n\n    if obs is None:\n        print(f\"DEBUG: track_scalar_change - Field {attr} not found\")\n        return  # Field not found\n\n    # Create undo/redo functions\n    def undo_func() -&gt; None:\n        print(f\"DEBUG: undo_func called for {attr}, setting value to {old_value}\")\n        # Set the old value with triggering callbacks to ensure computed properties update\n        obs.set(old_value)\n\n        # If we're undoing to the original value, clear the dirty state\n        if old_value == self._initial_values.get(attr):\n            self._dirty_fields.discard(attr)\n\n        print(f\"DEBUG: undo_func completed for {attr}\")\n\n    def redo_func() -&gt; None:\n        print(f\"DEBUG: redo_func called for {attr}, setting value to {new_value}\")\n        # Set the new value with triggering callbacks to ensure computed properties update\n        obs.set(new_value)\n\n        # If we're redoing to a non-original value, mark as dirty\n        if new_value != self._initial_values.get(attr):\n            self._dirty_fields.add(attr)\n\n        print(f\"DEBUG: redo_func completed for {attr}\")\n\n    # Add to the undo stack\n    print(f\"DEBUG: track_scalar_change - Calling _add_to_undo_stack for {attr}\")\n    self._add_to_undo_stack(attr, undo_func, redo_func)\n    print(f\"DEBUG: track_scalar_change - Completed for {attr}\")\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.undo","title":"<code>undo(attr)</code>","text":"<p>Undo the most recent change to a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to undo changes for.</p> required Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef undo(self, attr: str) -&gt; None:\n    \"\"\"\n    Undo the most recent change to a field.\n\n    Args:\n        attr: The field name to undo changes for.\n    \"\"\"\n    print(f\"DEBUG: undo called for {attr}\")\n\n    if attr not in self._undo_stacks or not self._undo_stacks[attr]:\n        print(f\"DEBUG: undo - Nothing to undo for {attr}\")\n        return  # Nothing to undo\n\n    # Pop the most recent undo function\n    undo_func = self._undo_stacks[attr].pop()\n    print(f\"DEBUG: undo - Popped undo function from stack for {attr}, remaining: {len(self._undo_stacks[attr])}\")\n\n    # Get the pending redo function\n    redo_func = self._pending_undo_groups.get(attr)\n    print(f\"DEBUG: undo - Got pending redo function for {attr}: {redo_func is not None}\")\n\n    # Add to the redo stack if it exists\n    if redo_func is not None:\n        self._redo_stacks[attr].append(redo_func)\n        print(f\"DEBUG: undo - Added redo function to stack for {attr}\")\n        self._pending_undo_groups[attr] = None\n        print(f\"DEBUG: undo - Cleared pending undo group for {attr}\")\n\n    # Find the observable for this field to set the undoing flag\n    obs = None\n    for key, o in self._scalars.items():\n        if key.attr == attr:\n            obs = o\n            break\n\n    # Execute the undo function with undoing flag set\n    print(f\"DEBUG: undo - Executing undo function for {attr}\")\n    print(f\"DEBUG: undo - undo_func: {undo_func}\")\n\n    # Set the undoing flag if we found the observable and it's a UndoableObservable\n    from observant.undoable_observable import UndoableObservable\n\n    if obs is not None and isinstance(obs, UndoableObservable):\n        obs.set_undoing(True)\n\n    try:\n        undo_func()\n    finally:\n        # Reset the undoing flag\n        if obs is not None and isinstance(obs, UndoableObservable):\n            obs.set_undoing(False)\n\n    print(f\"DEBUG: undo - Completed for {attr}\")\n\n    # If sync is enabled for this field, update the model\n    for key in self._scalars:\n        if key.attr == attr and key.sync:\n            value = self._scalars[key].get()\n            setattr(self._obj, attr, value)\n            print(f\"DEBUG: undo - Synced {attr} to model with value {value}\")\n            break\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.update","title":"<code>update(**kwargs)</code>","text":"<p>Set one or more scalar observable values.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef update(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Set one or more scalar observable values.\n    \"\"\"\n    for attr, value in kwargs.items():\n        self.observable(object, attr).set(value)\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.validation_errors","title":"<code>validation_errors()</code>","text":"<p>Get an observable dictionary of validation errors.</p> <p>Returns:</p> Type Description <code>IObservableDict[str, list[str]]</code> <p>An observable dictionary mapping field names to lists of error messages.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef validation_errors(self) -&gt; IObservableDict[str, list[str]]:\n    \"\"\"\n    Get an observable dictionary of validation errors.\n\n    Returns:\n        An observable dictionary mapping field names to lists of error messages.\n    \"\"\"\n    return self._validation_errors_dict\n</code></pre>"},{"location":"api_reference/observable_proxy/#observant.observable_proxy.ObservableProxy.validation_for","title":"<code>validation_for(attr)</code>","text":"<p>Get an observable list of validation errors for a specific field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to get validation errors for.</p> required <p>Returns:</p> Type Description <code>IObservable[list[str]]</code> <p>An observable that emits a list of error messages for the field.</p> <code>IObservable[list[str]]</code> <p>An empty list means the field is valid.</p> Source code in <code>observant\\observable_proxy.py</code> <pre><code>@override\ndef validation_for(self, attr: str) -&gt; IObservable[list[str]]:\n    \"\"\"\n    Get an observable list of validation errors for a specific field.\n\n    Args:\n        attr: The field name to get validation errors for.\n\n    Returns:\n        An observable that emits a list of error messages for the field.\n        An empty list means the field is valid.\n    \"\"\"\n    if attr not in self._validation_for_cache:\n        # Create a computed observable that depends on the validation errors dict\n        initial_value = self._validation_errors_dict.get(attr) or []\n        obs = Observable[list[str]](initial_value)\n\n        # Update the observable when the validation errors dict changes\n        def update_validation(_: Any) -&gt; None:\n            new_value = self._validation_errors_dict.get(attr) or []\n            current = obs.get()\n            if new_value != current:\n                obs.set(new_value)\n\n        self._validation_errors_dict.on_change(update_validation)\n        self._validation_for_cache[attr] = obs\n\n    return self._validation_for_cache[attr]\n</code></pre>"},{"location":"api_reference/undoable_observable/","title":"UndoableObservable","text":""},{"location":"api_reference/undoable_observable/#observant.undoable_observable.UndoableObservable","title":"<code>observant.undoable_observable.UndoableObservable</code>","text":"<p>               Bases: <code>Observable[T]</code>, <code>Generic[T]</code></p> Source code in <code>observant\\undoable_observable.py</code> <pre><code>class UndoableObservable(Observable[T], Generic[T]):\n    def __init__(self, value: T, attr: str, proxy: IObservableProxy[TValue], *, on_change_enabled: bool = True) -&gt; None:\n        super().__init__(value, on_change_enabled=on_change_enabled)\n        self._attr = attr\n        self._proxy = proxy\n        self._is_undoing = False  # Flag to prevent recursive tracking during undo/redo\n\n    @override\n    def set(self, value: T, notify: bool = True) -&gt; None:\n        old_value = self.get()\n\n        # Only track changes if not already undoing and notify is True\n        if old_value != value and notify and not self._is_undoing:\n            self._proxy.track_scalar_change(self._attr, old_value, value)\n\n        super().set(value, notify=notify)\n\n    def set_undoing(self, is_undoing: bool) -&gt; None:\n        \"\"\"Set the undoing flag to prevent recursive tracking during undo/redo.\"\"\"\n        self._is_undoing = is_undoing\n</code></pre>"},{"location":"api_reference/undoable_observable/#observant.undoable_observable.UndoableObservable.set_undoing","title":"<code>set_undoing(is_undoing)</code>","text":"<p>Set the undoing flag to prevent recursive tracking during undo/redo.</p> Source code in <code>observant\\undoable_observable.py</code> <pre><code>def set_undoing(self, is_undoing: bool) -&gt; None:\n    \"\"\"Set the undoing flag to prevent recursive tracking during undo/redo.\"\"\"\n    self._is_undoing = is_undoing\n</code></pre>"},{"location":"api_reference/interfaces/","title":"Interfaces","text":""},{"location":"api_reference/interfaces/#observant.interfaces.observable.IObservable","title":"<code>observant.interfaces.observable.IObservable</code>","text":"<p>               Bases: <code>Generic[T]</code></p> Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>class IObservable(Generic[T]):\n    def get(self) -&gt; T:\n        \"\"\"\n        Get the current value of the observable.\n\n        Returns:\n            The current value.\n        \"\"\"\n        ...\n\n    def set(self, value: T, notify: bool = True) -&gt; None:\n        \"\"\"\n        Set a new value for the observable and notify all registered callbacks.\n\n        Args:\n            value: The new value to set.\n            notify: Whether to notify the callbacks after setting the value.\n        \"\"\"\n        ...\n\n    def on_change(self, callback: Callable[[T], None]) -&gt; None:\n        \"\"\"\n        Register a callback function to be called when the value changes.\n\n        Args:\n            callback: A function that takes the new value as its argument.\n        \"\"\"\n        ...\n\n    def enable(self) -&gt; None:\n        \"\"\"\n        Enable the observable to notify changes.\n        \"\"\"\n        ...\n\n    def disable(self) -&gt; None:\n        \"\"\"\n        Disable the observable from notifying changes.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.observable.IObservable.disable","title":"<code>disable()</code>","text":"<p>Disable the observable from notifying changes.</p> Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>def disable(self) -&gt; None:\n    \"\"\"\n    Disable the observable from notifying changes.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.observable.IObservable.enable","title":"<code>enable()</code>","text":"<p>Enable the observable to notify changes.</p> Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>def enable(self) -&gt; None:\n    \"\"\"\n    Enable the observable to notify changes.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.observable.IObservable.get","title":"<code>get()</code>","text":"<p>Get the current value of the observable.</p> <p>Returns:</p> Type Description <code>T</code> <p>The current value.</p> Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>def get(self) -&gt; T:\n    \"\"\"\n    Get the current value of the observable.\n\n    Returns:\n        The current value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.observable.IObservable.on_change","title":"<code>on_change(callback)</code>","text":"<p>Register a callback function to be called when the value changes.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[T], None]</code> <p>A function that takes the new value as its argument.</p> required Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>def on_change(self, callback: Callable[[T], None]) -&gt; None:\n    \"\"\"\n    Register a callback function to be called when the value changes.\n\n    Args:\n        callback: A function that takes the new value as its argument.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.observable.IObservable.set","title":"<code>set(value, notify=True)</code>","text":"<p>Set a new value for the observable and notify all registered callbacks.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The new value to set.</p> required <code>notify</code> <code>bool</code> <p>Whether to notify the callbacks after setting the value.</p> <code>True</code> Source code in <code>observant\\interfaces\\observable.py</code> <pre><code>def set(self, value: T, notify: bool = True) -&gt; None:\n    \"\"\"\n    Set a new value for the observable and notify all registered callbacks.\n\n    Args:\n        value: The new value to set.\n        notify: Whether to notify the callbacks after setting the value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList","title":"<code>observant.interfaces.list.IObservableList</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Interface for observable lists with specific event types.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>class IObservableList(Generic[T], ABC):\n    \"\"\"Interface for observable lists with specific event types.\"\"\"\n\n    @abstractmethod\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of items in the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def __getitem__(self, index: int | slice) -&gt; T | list[T]:\n        \"\"\"Get an item or slice of items from the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def __setitem__(self, index: int | slice, value: T | list[T]) -&gt; None:\n        \"\"\"Set an item or slice of items in the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def __delitem__(self, index: int | slice) -&gt; None:\n        \"\"\"Delete an item or slice of items from the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def __iter__(self) -&gt; Iterator[T]:\n        \"\"\"Return an iterator over the items in the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def __contains__(self, item: T) -&gt; bool:\n        \"\"\"Check if an item is in the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def append(self, item: T) -&gt; None:\n        \"\"\"Add an item to the end of the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def extend(self, items: list[T]) -&gt; None:\n        \"\"\"Extend the list by appending all items from the iterable.\"\"\"\n        ...\n\n    @abstractmethod\n    def insert(self, index: int, item: T) -&gt; None:\n        \"\"\"Insert an item at a given position.\"\"\"\n        ...\n\n    @abstractmethod\n    def remove(self, item: T) -&gt; None:\n        \"\"\"Remove the first occurrence of an item from the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def pop(self, index: int = -1) -&gt; T:\n        \"\"\"Remove and return an item at a given position.\"\"\"\n        ...\n\n    @abstractmethod\n    def clear(self) -&gt; None:\n        \"\"\"Remove all items from the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def index(self, item: T, start: int = 0, end: int | None = None) -&gt; int:\n        \"\"\"Return the index of the first occurrence of an item.\"\"\"\n        ...\n\n    @abstractmethod\n    def count(self, item: T) -&gt; int:\n        \"\"\"Return the number of occurrences of an item in the list.\"\"\"\n        ...\n\n    @overload\n    def sort(self, *, key: None = None, reverse: bool = False) -&gt; None: ...\n\n    @overload\n    def sort(self, *, key: Callable[[T], Any], reverse: bool = False) -&gt; None: ...\n\n    @abstractmethod\n    def sort(\n        self,\n        *,\n        key: Callable[[T], Any] | None = None,\n        reverse: bool = False,\n    ) -&gt; None: ...\n\n    @abstractmethod\n    def reverse(self) -&gt; None:\n        \"\"\"Reverse the list in place.\"\"\"\n        ...\n\n    @abstractmethod\n    def copy(self) -&gt; list[T]:\n        \"\"\"Return a shallow copy of the list.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_change(self, callback: Callable[[ObservableListChange[T]], None]) -&gt; None:\n        \"\"\"Register for all change events with detailed information.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_add(self, callback: Callable[[T, int], None]) -&gt; None:\n        \"\"\"Register for add events with item and index.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_remove(self, callback: Callable[[T, int], None]) -&gt; None:\n        \"\"\"Register for remove events with item and index.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_clear(self, callback: Callable[[list[T]], None]) -&gt; None:\n        \"\"\"Register for clear events with the cleared items.\"\"\"\n        ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.__contains__","title":"<code>__contains__(item)</code>  <code>abstractmethod</code>","text":"<p>Check if an item is in the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __contains__(self, item: T) -&gt; bool:\n    \"\"\"Check if an item is in the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.__delitem__","title":"<code>__delitem__(index)</code>  <code>abstractmethod</code>","text":"<p>Delete an item or slice of items from the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __delitem__(self, index: int | slice) -&gt; None:\n    \"\"\"Delete an item or slice of items from the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.__getitem__","title":"<code>__getitem__(index)</code>  <code>abstractmethod</code>","text":"<p>Get an item or slice of items from the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __getitem__(self, index: int | slice) -&gt; T | list[T]:\n    \"\"\"Get an item or slice of items from the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.__iter__","title":"<code>__iter__()</code>  <code>abstractmethod</code>","text":"<p>Return an iterator over the items in the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __iter__(self) -&gt; Iterator[T]:\n    \"\"\"Return an iterator over the items in the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.__len__","title":"<code>__len__()</code>  <code>abstractmethod</code>","text":"<p>Return the number of items in the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __len__(self) -&gt; int:\n    \"\"\"Return the number of items in the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.__setitem__","title":"<code>__setitem__(index, value)</code>  <code>abstractmethod</code>","text":"<p>Set an item or slice of items in the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef __setitem__(self, index: int | slice, value: T | list[T]) -&gt; None:\n    \"\"\"Set an item or slice of items in the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.append","title":"<code>append(item)</code>  <code>abstractmethod</code>","text":"<p>Add an item to the end of the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef append(self, item: T) -&gt; None:\n    \"\"\"Add an item to the end of the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.clear","title":"<code>clear()</code>  <code>abstractmethod</code>","text":"<p>Remove all items from the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef clear(self) -&gt; None:\n    \"\"\"Remove all items from the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.copy","title":"<code>copy()</code>  <code>abstractmethod</code>","text":"<p>Return a shallow copy of the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef copy(self) -&gt; list[T]:\n    \"\"\"Return a shallow copy of the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.count","title":"<code>count(item)</code>  <code>abstractmethod</code>","text":"<p>Return the number of occurrences of an item in the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef count(self, item: T) -&gt; int:\n    \"\"\"Return the number of occurrences of an item in the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.extend","title":"<code>extend(items)</code>  <code>abstractmethod</code>","text":"<p>Extend the list by appending all items from the iterable.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef extend(self, items: list[T]) -&gt; None:\n    \"\"\"Extend the list by appending all items from the iterable.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.index","title":"<code>index(item, start=0, end=None)</code>  <code>abstractmethod</code>","text":"<p>Return the index of the first occurrence of an item.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef index(self, item: T, start: int = 0, end: int | None = None) -&gt; int:\n    \"\"\"Return the index of the first occurrence of an item.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.insert","title":"<code>insert(index, item)</code>  <code>abstractmethod</code>","text":"<p>Insert an item at a given position.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef insert(self, index: int, item: T) -&gt; None:\n    \"\"\"Insert an item at a given position.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.on_add","title":"<code>on_add(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for add events with item and index.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef on_add(self, callback: Callable[[T, int], None]) -&gt; None:\n    \"\"\"Register for add events with item and index.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.on_change","title":"<code>on_change(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for all change events with detailed information.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef on_change(self, callback: Callable[[ObservableListChange[T]], None]) -&gt; None:\n    \"\"\"Register for all change events with detailed information.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.on_clear","title":"<code>on_clear(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for clear events with the cleared items.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef on_clear(self, callback: Callable[[list[T]], None]) -&gt; None:\n    \"\"\"Register for clear events with the cleared items.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.on_remove","title":"<code>on_remove(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for remove events with item and index.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef on_remove(self, callback: Callable[[T, int], None]) -&gt; None:\n    \"\"\"Register for remove events with item and index.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.pop","title":"<code>pop(index=-1)</code>  <code>abstractmethod</code>","text":"<p>Remove and return an item at a given position.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef pop(self, index: int = -1) -&gt; T:\n    \"\"\"Remove and return an item at a given position.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.remove","title":"<code>remove(item)</code>  <code>abstractmethod</code>","text":"<p>Remove the first occurrence of an item from the list.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef remove(self, item: T) -&gt; None:\n    \"\"\"Remove the first occurrence of an item from the list.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.list.IObservableList.reverse","title":"<code>reverse()</code>  <code>abstractmethod</code>","text":"<p>Reverse the list in place.</p> Source code in <code>observant\\interfaces\\list.py</code> <pre><code>@abstractmethod\ndef reverse(self) -&gt; None:\n    \"\"\"Reverse the list in place.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict","title":"<code>observant.interfaces.dict.IObservableDict</code>","text":"<p>               Bases: <code>Generic[TKey, TValue]</code>, <code>ABC</code></p> <p>Interface for observable dictionaries with specific event types.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>class IObservableDict(Generic[TKey, TValue], ABC):\n    \"\"\"Interface for observable dictionaries with specific event types.\"\"\"\n\n    @abstractmethod\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of items in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def __getitem__(self, key: TKey) -&gt; TValue:\n        \"\"\"Get an item from the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def __setitem__(self, key: TKey, value: TValue) -&gt; None:\n        \"\"\"Set an item in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def __delitem__(self, key: TKey) -&gt; None:\n        \"\"\"Delete an item from the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def __iter__(self) -&gt; Iterator[TKey]:\n        \"\"\"Return an iterator over the keys in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def __contains__(self, key: TKey) -&gt; bool:\n        \"\"\"Check if a key is in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def get(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"Return the value for a key if it exists, otherwise return a default value.\"\"\"\n        ...\n\n    @abstractmethod\n    def setdefault(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"Return the value for a key if it exists, otherwise set and return the default value.\"\"\"\n        ...\n\n    @abstractmethod\n    def pop(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n        \"\"\"Remove and return the value for a key if it exists, otherwise return a default value.\"\"\"\n        ...\n\n    @abstractmethod\n    def popitem(self) -&gt; tuple[TKey, TValue]:\n        \"\"\"Remove and return a (key, value) pair from the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def clear(self) -&gt; None:\n        \"\"\"Remove all items from the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def update(self, other: dict[TKey, TValue]) -&gt; None:\n        \"\"\"Update the dictionary with the key/value pairs from another dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def keys(self) -&gt; list[TKey]:\n        \"\"\"Return a list of all keys in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def values(self) -&gt; list[TValue]:\n        \"\"\"Return a list of all values in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def items(self) -&gt; list[tuple[TKey, TValue]]:\n        \"\"\"Return a list of all (key, value) pairs in the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def copy(self) -&gt; dict[TKey, TValue]:\n        \"\"\"Return a shallow copy of the dictionary.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_change(\n        self, callback: Callable[[ObservableDictChange[TKey, TValue]], None]\n    ) -&gt; None:\n        \"\"\"Register for all change events with detailed information.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_add(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"Register for add events with key and value.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_remove(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"Register for remove events with key and value.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_update(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n        \"\"\"Register for update events with key and new value.\"\"\"\n        ...\n\n    @abstractmethod\n    def on_clear(self, callback: Callable[[dict[TKey, TValue]], None]) -&gt; None:\n        \"\"\"Register for clear events with the cleared items.\"\"\"\n        ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.__contains__","title":"<code>__contains__(key)</code>  <code>abstractmethod</code>","text":"<p>Check if a key is in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __contains__(self, key: TKey) -&gt; bool:\n    \"\"\"Check if a key is in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.__delitem__","title":"<code>__delitem__(key)</code>  <code>abstractmethod</code>","text":"<p>Delete an item from the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __delitem__(self, key: TKey) -&gt; None:\n    \"\"\"Delete an item from the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.__getitem__","title":"<code>__getitem__(key)</code>  <code>abstractmethod</code>","text":"<p>Get an item from the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __getitem__(self, key: TKey) -&gt; TValue:\n    \"\"\"Get an item from the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.__iter__","title":"<code>__iter__()</code>  <code>abstractmethod</code>","text":"<p>Return an iterator over the keys in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __iter__(self) -&gt; Iterator[TKey]:\n    \"\"\"Return an iterator over the keys in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.__len__","title":"<code>__len__()</code>  <code>abstractmethod</code>","text":"<p>Return the number of items in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __len__(self) -&gt; int:\n    \"\"\"Return the number of items in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.__setitem__","title":"<code>__setitem__(key, value)</code>  <code>abstractmethod</code>","text":"<p>Set an item in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef __setitem__(self, key: TKey, value: TValue) -&gt; None:\n    \"\"\"Set an item in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.clear","title":"<code>clear()</code>  <code>abstractmethod</code>","text":"<p>Remove all items from the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef clear(self) -&gt; None:\n    \"\"\"Remove all items from the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.copy","title":"<code>copy()</code>  <code>abstractmethod</code>","text":"<p>Return a shallow copy of the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef copy(self) -&gt; dict[TKey, TValue]:\n    \"\"\"Return a shallow copy of the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.get","title":"<code>get(key, default=None)</code>  <code>abstractmethod</code>","text":"<p>Return the value for a key if it exists, otherwise return a default value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef get(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"Return the value for a key if it exists, otherwise return a default value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.items","title":"<code>items()</code>  <code>abstractmethod</code>","text":"<p>Return a list of all (key, value) pairs in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef items(self) -&gt; list[tuple[TKey, TValue]]:\n    \"\"\"Return a list of all (key, value) pairs in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.keys","title":"<code>keys()</code>  <code>abstractmethod</code>","text":"<p>Return a list of all keys in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef keys(self) -&gt; list[TKey]:\n    \"\"\"Return a list of all keys in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.on_add","title":"<code>on_add(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for add events with key and value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef on_add(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"Register for add events with key and value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.on_change","title":"<code>on_change(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for all change events with detailed information.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef on_change(\n    self, callback: Callable[[ObservableDictChange[TKey, TValue]], None]\n) -&gt; None:\n    \"\"\"Register for all change events with detailed information.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.on_clear","title":"<code>on_clear(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for clear events with the cleared items.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef on_clear(self, callback: Callable[[dict[TKey, TValue]], None]) -&gt; None:\n    \"\"\"Register for clear events with the cleared items.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.on_remove","title":"<code>on_remove(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for remove events with key and value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef on_remove(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"Register for remove events with key and value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.on_update","title":"<code>on_update(callback)</code>  <code>abstractmethod</code>","text":"<p>Register for update events with key and new value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef on_update(self, callback: Callable[[TKey, TValue], None]) -&gt; None:\n    \"\"\"Register for update events with key and new value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.pop","title":"<code>pop(key, default=None)</code>  <code>abstractmethod</code>","text":"<p>Remove and return the value for a key if it exists, otherwise return a default value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef pop(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"Remove and return the value for a key if it exists, otherwise return a default value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.popitem","title":"<code>popitem()</code>  <code>abstractmethod</code>","text":"<p>Remove and return a (key, value) pair from the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef popitem(self) -&gt; tuple[TKey, TValue]:\n    \"\"\"Remove and return a (key, value) pair from the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.setdefault","title":"<code>setdefault(key, default=None)</code>  <code>abstractmethod</code>","text":"<p>Return the value for a key if it exists, otherwise set and return the default value.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef setdefault(self, key: TKey, default: TValue | None = None) -&gt; TValue | None:\n    \"\"\"Return the value for a key if it exists, otherwise set and return the default value.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.update","title":"<code>update(other)</code>  <code>abstractmethod</code>","text":"<p>Update the dictionary with the key/value pairs from another dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef update(self, other: dict[TKey, TValue]) -&gt; None:\n    \"\"\"Update the dictionary with the key/value pairs from another dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.dict.IObservableDict.values","title":"<code>values()</code>  <code>abstractmethod</code>","text":"<p>Return a list of all values in the dictionary.</p> Source code in <code>observant\\interfaces\\dict.py</code> <pre><code>@abstractmethod\ndef values(self) -&gt; list[TValue]:\n    \"\"\"Return a list of all values in the dictionary.\"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy","title":"<code>observant.interfaces.proxy.IObservableProxy</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>ABC</code></p> <p>Proxy for a data object that exposes its fields as Observable, ObservableList, or ObservableDict. Provides optional sync behavior to automatically write back to the source model.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>class IObservableProxy(Generic[T], ABC):\n    \"\"\"\n    Proxy for a data object that exposes its fields as Observable, ObservableList, or ObservableDict.\n    Provides optional sync behavior to automatically write back to the source model.\n    \"\"\"\n\n    @abstractmethod\n    def observable(\n        self,\n        typ: type[T],\n        attr: str,\n        *,\n        sync: bool | None = None,\n    ) -&gt; IObservable[T]:\n        \"\"\"\n        Get or create an Observable[T] for a scalar field.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def observable_list(\n        self,\n        typ: type[T],\n        attr: str,\n        *,\n        sync: bool | None = None,\n    ) -&gt; IObservableList[T]:\n        \"\"\"\n        Get or create an ObservableList[T] for a list field.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def observable_dict(\n        self,\n        typ: tuple[type[TKey], type[TValue]],\n        attr: str,\n        *,\n        sync: bool | None = None,\n    ) -&gt; IObservableDict[TKey, TValue]:\n        \"\"\"\n        Get or create an ObservableDict for a dict field.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get(self) -&gt; T:\n        \"\"\"\n        Get the original object being proxied.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def update(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Set one or more scalar observable values.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def load_dict(self, values: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Set multiple scalar observable values from a dict.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def save_to(self, obj: T) -&gt; None:\n        \"\"\"\n        Write all observable values back into the given object.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def is_dirty(self) -&gt; bool:\n        \"\"\"\n        Check if any fields have been modified since initialization or last reset.\n\n        Returns:\n            True if any fields have been modified, False otherwise.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def dirty_fields(self) -&gt; set[str]:\n        \"\"\"\n        Get the set of field names that have been modified.\n\n        Returns:\n            A set of field names that have been modified.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def reset_dirty(self) -&gt; None:\n        \"\"\"\n        Reset the dirty state of all fields.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def register_computed(\n        self,\n        name: str,\n        compute: Callable[[], T],\n        dependencies: list[str],\n    ) -&gt; None:\n        \"\"\"\n        Register a computed property that depends on other observables.\n\n        Args:\n            name: The name of the computed property.\n            compute: A function that returns the computed value.\n            dependencies: List of field names that this computed property depends on.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def computed(\n        self,\n        typ: type[T],\n        name: str,\n    ) -&gt; IObservable[T]:\n        \"\"\"\n        Get a computed property by name.\n\n        Args:\n            typ: The type of the computed property.\n            name: The name of the computed property.\n\n        Returns:\n            An observable containing the computed value.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def add_validator(\n        self,\n        attr: str,\n        validator: Callable[[Any], str | None],\n    ) -&gt; None:\n        \"\"\"\n        Add a validator function for a field.\n\n        Args:\n            attr: The field name to validate.\n            validator: A function that takes the field value and returns an error message\n                       if invalid, or None if valid.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def is_valid(self) -&gt; IObservable[bool]:\n        \"\"\"\n        Get an observable that indicates whether all fields are valid.\n\n        Returns:\n            An observable that emits True if all fields are valid, False otherwise.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def validation_errors(self) -&gt; IObservableDict[str, list[str]]:\n        \"\"\"\n        Get an observable dictionary of validation errors.\n\n        Returns:\n            An observable dictionary mapping field names to lists of error messages.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def validation_for(self, attr: str) -&gt; IObservable[list[str]]:\n        \"\"\"\n        Get an observable list of validation errors for a specific field.\n\n        Args:\n            attr: The field name to get validation errors for.\n\n        Returns:\n            An observable that emits a list of error messages for the field.\n            An empty list means the field is valid.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def reset_validation(self, attr: str | None = None, *, revalidate: bool = False) -&gt; None:\n        \"\"\"\n        Reset validation errors for a specific field or all fields.\n\n        Args:\n            attr: The field name to reset validation for. If None, reset all fields.\n            revalidate: Whether to re-run validators after clearing errors.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def set_undo_config(\n        self,\n        attr: str,\n        *,\n        undo_max: int | None = None,\n        undo_debounce_ms: int | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Set the undo configuration for a specific field.\n\n        Args:\n            attr: The field name to configure.\n            undo_max: Maximum number of undo steps to store. None means unlimited.\n            undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def undo(self, attr: str) -&gt; None:\n        \"\"\"\n        Undo the most recent change to a field.\n\n        Args:\n            attr: The field name to undo changes for.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def redo(self, attr: str) -&gt; None:\n        \"\"\"\n        Redo the most recently undone change to a field.\n\n        Args:\n            attr: The field name to redo changes for.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def can_undo(self, attr: str) -&gt; bool:\n        \"\"\"\n        Check if there are changes that can be undone for a field.\n\n        Args:\n            attr: The field name to check.\n\n        Returns:\n            True if there are changes that can be undone, False otherwise.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def can_redo(self, attr: str) -&gt; bool:\n        \"\"\"\n        Check if there are changes that can be redone for a field.\n\n        Args:\n            attr: The field name to check.\n\n        Returns:\n            True if there are changes that can be redone, False otherwise.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def track_scalar_change(self, attr: str, old_value: Any, new_value: Any) -&gt; None:\n        \"\"\"\n        Track a scalar change for undo/redo functionality.\n\n        Args:\n            attr: The field name that changed.\n            old_value: The old value before the change.\n            new_value: The new value after the change.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.add_validator","title":"<code>add_validator(attr, validator)</code>  <code>abstractmethod</code>","text":"<p>Add a validator function for a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to validate.</p> required <code>validator</code> <code>Callable[[Any], str | None]</code> <p>A function that takes the field value and returns an error message        if invalid, or None if valid.</p> required Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef add_validator(\n    self,\n    attr: str,\n    validator: Callable[[Any], str | None],\n) -&gt; None:\n    \"\"\"\n    Add a validator function for a field.\n\n    Args:\n        attr: The field name to validate.\n        validator: A function that takes the field value and returns an error message\n                   if invalid, or None if valid.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.can_redo","title":"<code>can_redo(attr)</code>  <code>abstractmethod</code>","text":"<p>Check if there are changes that can be redone for a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there are changes that can be redone, False otherwise.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef can_redo(self, attr: str) -&gt; bool:\n    \"\"\"\n    Check if there are changes that can be redone for a field.\n\n    Args:\n        attr: The field name to check.\n\n    Returns:\n        True if there are changes that can be redone, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.can_undo","title":"<code>can_undo(attr)</code>  <code>abstractmethod</code>","text":"<p>Check if there are changes that can be undone for a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there are changes that can be undone, False otherwise.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef can_undo(self, attr: str) -&gt; bool:\n    \"\"\"\n    Check if there are changes that can be undone for a field.\n\n    Args:\n        attr: The field name to check.\n\n    Returns:\n        True if there are changes that can be undone, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.computed","title":"<code>computed(typ, name)</code>  <code>abstractmethod</code>","text":"<p>Get a computed property by name.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>type[T]</code> <p>The type of the computed property.</p> required <code>name</code> <code>str</code> <p>The name of the computed property.</p> required <p>Returns:</p> Type Description <code>IObservable[T]</code> <p>An observable containing the computed value.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef computed(\n    self,\n    typ: type[T],\n    name: str,\n) -&gt; IObservable[T]:\n    \"\"\"\n    Get a computed property by name.\n\n    Args:\n        typ: The type of the computed property.\n        name: The name of the computed property.\n\n    Returns:\n        An observable containing the computed value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.dirty_fields","title":"<code>dirty_fields()</code>  <code>abstractmethod</code>","text":"<p>Get the set of field names that have been modified.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of field names that have been modified.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef dirty_fields(self) -&gt; set[str]:\n    \"\"\"\n    Get the set of field names that have been modified.\n\n    Returns:\n        A set of field names that have been modified.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.get","title":"<code>get()</code>  <code>abstractmethod</code>","text":"<p>Get the original object being proxied.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef get(self) -&gt; T:\n    \"\"\"\n    Get the original object being proxied.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.is_dirty","title":"<code>is_dirty()</code>  <code>abstractmethod</code>","text":"<p>Check if any fields have been modified since initialization or last reset.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if any fields have been modified, False otherwise.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef is_dirty(self) -&gt; bool:\n    \"\"\"\n    Check if any fields have been modified since initialization or last reset.\n\n    Returns:\n        True if any fields have been modified, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.is_valid","title":"<code>is_valid()</code>  <code>abstractmethod</code>","text":"<p>Get an observable that indicates whether all fields are valid.</p> <p>Returns:</p> Type Description <code>IObservable[bool]</code> <p>An observable that emits True if all fields are valid, False otherwise.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef is_valid(self) -&gt; IObservable[bool]:\n    \"\"\"\n    Get an observable that indicates whether all fields are valid.\n\n    Returns:\n        An observable that emits True if all fields are valid, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.load_dict","title":"<code>load_dict(values)</code>  <code>abstractmethod</code>","text":"<p>Set multiple scalar observable values from a dict.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef load_dict(self, values: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Set multiple scalar observable values from a dict.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.observable","title":"<code>observable(typ, attr, *, sync=None)</code>  <code>abstractmethod</code>","text":"<p>Get or create an Observable[T] for a scalar field.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef observable(\n    self,\n    typ: type[T],\n    attr: str,\n    *,\n    sync: bool | None = None,\n) -&gt; IObservable[T]:\n    \"\"\"\n    Get or create an Observable[T] for a scalar field.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.observable_dict","title":"<code>observable_dict(typ, attr, *, sync=None)</code>  <code>abstractmethod</code>","text":"<p>Get or create an ObservableDict for a dict field.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef observable_dict(\n    self,\n    typ: tuple[type[TKey], type[TValue]],\n    attr: str,\n    *,\n    sync: bool | None = None,\n) -&gt; IObservableDict[TKey, TValue]:\n    \"\"\"\n    Get or create an ObservableDict for a dict field.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.observable_list","title":"<code>observable_list(typ, attr, *, sync=None)</code>  <code>abstractmethod</code>","text":"<p>Get or create an ObservableList[T] for a list field.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef observable_list(\n    self,\n    typ: type[T],\n    attr: str,\n    *,\n    sync: bool | None = None,\n) -&gt; IObservableList[T]:\n    \"\"\"\n    Get or create an ObservableList[T] for a list field.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.redo","title":"<code>redo(attr)</code>  <code>abstractmethod</code>","text":"<p>Redo the most recently undone change to a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to redo changes for.</p> required Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef redo(self, attr: str) -&gt; None:\n    \"\"\"\n    Redo the most recently undone change to a field.\n\n    Args:\n        attr: The field name to redo changes for.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.register_computed","title":"<code>register_computed(name, compute, dependencies)</code>  <code>abstractmethod</code>","text":"<p>Register a computed property that depends on other observables.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the computed property.</p> required <code>compute</code> <code>Callable[[], T]</code> <p>A function that returns the computed value.</p> required <code>dependencies</code> <code>list[str]</code> <p>List of field names that this computed property depends on.</p> required Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef register_computed(\n    self,\n    name: str,\n    compute: Callable[[], T],\n    dependencies: list[str],\n) -&gt; None:\n    \"\"\"\n    Register a computed property that depends on other observables.\n\n    Args:\n        name: The name of the computed property.\n        compute: A function that returns the computed value.\n        dependencies: List of field names that this computed property depends on.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.reset_dirty","title":"<code>reset_dirty()</code>  <code>abstractmethod</code>","text":"<p>Reset the dirty state of all fields.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef reset_dirty(self) -&gt; None:\n    \"\"\"\n    Reset the dirty state of all fields.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.reset_validation","title":"<code>reset_validation(attr=None, *, revalidate=False)</code>  <code>abstractmethod</code>","text":"<p>Reset validation errors for a specific field or all fields.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str | None</code> <p>The field name to reset validation for. If None, reset all fields.</p> <code>None</code> <code>revalidate</code> <code>bool</code> <p>Whether to re-run validators after clearing errors.</p> <code>False</code> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef reset_validation(self, attr: str | None = None, *, revalidate: bool = False) -&gt; None:\n    \"\"\"\n    Reset validation errors for a specific field or all fields.\n\n    Args:\n        attr: The field name to reset validation for. If None, reset all fields.\n        revalidate: Whether to re-run validators after clearing errors.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.save_to","title":"<code>save_to(obj)</code>  <code>abstractmethod</code>","text":"<p>Write all observable values back into the given object.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef save_to(self, obj: T) -&gt; None:\n    \"\"\"\n    Write all observable values back into the given object.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.set_undo_config","title":"<code>set_undo_config(attr, *, undo_max=None, undo_debounce_ms=None)</code>  <code>abstractmethod</code>","text":"<p>Set the undo configuration for a specific field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to configure.</p> required <code>undo_max</code> <code>int | None</code> <p>Maximum number of undo steps to store. None means unlimited.</p> <code>None</code> <code>undo_debounce_ms</code> <code>int | None</code> <p>Time window in milliseconds to group changes. None means no debouncing.</p> <code>None</code> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef set_undo_config(\n    self,\n    attr: str,\n    *,\n    undo_max: int | None = None,\n    undo_debounce_ms: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Set the undo configuration for a specific field.\n\n    Args:\n        attr: The field name to configure.\n        undo_max: Maximum number of undo steps to store. None means unlimited.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.track_scalar_change","title":"<code>track_scalar_change(attr, old_value, new_value)</code>  <code>abstractmethod</code>","text":"<p>Track a scalar change for undo/redo functionality.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name that changed.</p> required <code>old_value</code> <code>Any</code> <p>The old value before the change.</p> required <code>new_value</code> <code>Any</code> <p>The new value after the change.</p> required Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef track_scalar_change(self, attr: str, old_value: Any, new_value: Any) -&gt; None:\n    \"\"\"\n    Track a scalar change for undo/redo functionality.\n\n    Args:\n        attr: The field name that changed.\n        old_value: The old value before the change.\n        new_value: The new value after the change.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.undo","title":"<code>undo(attr)</code>  <code>abstractmethod</code>","text":"<p>Undo the most recent change to a field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to undo changes for.</p> required Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef undo(self, attr: str) -&gt; None:\n    \"\"\"\n    Undo the most recent change to a field.\n\n    Args:\n        attr: The field name to undo changes for.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.update","title":"<code>update(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Set one or more scalar observable values.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef update(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Set one or more scalar observable values.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.validation_errors","title":"<code>validation_errors()</code>  <code>abstractmethod</code>","text":"<p>Get an observable dictionary of validation errors.</p> <p>Returns:</p> Type Description <code>IObservableDict[str, list[str]]</code> <p>An observable dictionary mapping field names to lists of error messages.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef validation_errors(self) -&gt; IObservableDict[str, list[str]]:\n    \"\"\"\n    Get an observable dictionary of validation errors.\n\n    Returns:\n        An observable dictionary mapping field names to lists of error messages.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/interfaces/#observant.interfaces.proxy.IObservableProxy.validation_for","title":"<code>validation_for(attr)</code>  <code>abstractmethod</code>","text":"<p>Get an observable list of validation errors for a specific field.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The field name to get validation errors for.</p> required <p>Returns:</p> Type Description <code>IObservable[list[str]]</code> <p>An observable that emits a list of error messages for the field.</p> <code>IObservable[list[str]]</code> <p>An empty list means the field is valid.</p> Source code in <code>observant\\interfaces\\proxy.py</code> <pre><code>@abstractmethod\ndef validation_for(self, attr: str) -&gt; IObservable[list[str]]:\n    \"\"\"\n    Get an observable list of validation errors for a specific field.\n\n    Args:\n        attr: The field name to get validation errors for.\n\n    Returns:\n        An observable that emits a list of error messages for the field.\n        An empty list means the field is valid.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api_reference/types/","title":"Types","text":""},{"location":"api_reference/types/#observant.types.collection_change_type.ObservableCollectionChangeType","title":"<code>observant.types.collection_change_type.ObservableCollectionChangeType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Type of change that occurred in a collection.</p> Source code in <code>observant\\types\\collection_change_type.py</code> <pre><code>class ObservableCollectionChangeType(Enum):\n    \"\"\"Type of change that occurred in a collection.\"\"\"\n\n    ADD = auto()\n    REMOVE = auto()\n    CLEAR = auto()\n    UPDATE = auto()  # For dictionaries, when a value is updated\n</code></pre>"},{"location":"api_reference/types/#observant.types.list_change.ObservableListChange","title":"<code>observant.types.list_change.ObservableListChange</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Information about a change to an ObservableList.</p> Source code in <code>observant\\types\\list_change.py</code> <pre><code>@dataclass(frozen=True)\nclass ObservableListChange(Generic[T]):\n    \"\"\"Information about a change to an ObservableList.\"\"\"\n\n    type: ObservableCollectionChangeType\n    index: int | None = None  # Index where the change occurred, if applicable\n    item: T | None = None  # Item that was added or removed, if applicable\n    items: list[T] | None = None  # Multiple items that were added or removed, if applicable\n</code></pre>"},{"location":"api_reference/types/#observant.types.dict_change.ObservableDictChange","title":"<code>observant.types.dict_change.ObservableDictChange</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[TKey, TValue]</code></p> <p>Information about a change to an ObservableDict.</p> Source code in <code>observant\\types\\dict_change.py</code> <pre><code>@dataclass(frozen=True)\nclass ObservableDictChange(Generic[TKey, TValue]):\n    \"\"\"Information about a change to an ObservableDict.\"\"\"\n\n    type: ObservableCollectionChangeType\n    key: TKey | None = None  # Key where the change occurred, if applicable\n    value: TValue | None = (\n        None  # Value that was added, removed, or updated, if applicable\n    )\n    items: dict[TKey, TValue] | None = (\n        None  # Multiple items that were added, removed, or updated, if applicable\n    )\n</code></pre>"},{"location":"api_reference/types/#observant.types.proxy_field_key.ProxyFieldKey","title":"<code>observant.types.proxy_field_key.ProxyFieldKey</code>  <code>dataclass</code>","text":"Source code in <code>observant\\types\\proxy_field_key.py</code> <pre><code>@dataclass(frozen=True)\nclass ProxyFieldKey:\n    attr: str\n    sync: bool\n</code></pre>"},{"location":"api_reference/types/#observant.types.undo_config.UndoConfig","title":"<code>observant.types.undo_config.UndoConfig</code>  <code>dataclass</code>","text":"<p>Configuration for undo/redo behavior of an observable field.</p> <p>Attributes:</p> Name Type Description <code>enabled</code> <code>bool</code> <p>Whether undo/redo functionality is enabled for this field.</p> <code>undo_max</code> <code>Optional[int]</code> <p>Maximum number of undo steps to store. None means unlimited.</p> <code>undo_debounce_ms</code> <code>Optional[int]</code> <p>Time window in milliseconds to group changes. None means no debouncing.</p> Source code in <code>observant\\types\\undo_config.py</code> <pre><code>@dataclass\nclass UndoConfig:\n    \"\"\"\n    Configuration for undo/redo behavior of an observable field.\n\n    Attributes:\n        enabled: Whether undo/redo functionality is enabled for this field.\n        undo_max: Maximum number of undo steps to store. None means unlimited.\n        undo_debounce_ms: Time window in milliseconds to group changes. None means no debouncing.\n    \"\"\"\n\n    enabled: bool = False\n    undo_max: Optional[int] = 50\n    undo_debounce_ms: Optional[int] = None\n</code></pre>"},{"location":"features/change_tracking/","title":"Change Tracking","text":"<p>At the core of Observant is the ability to track changes to your data and react to those changes. This page explains how change tracking works in Observant.</p>"},{"location":"features/change_tracking/#overview","title":"Overview","text":"<p>Observant provides three main types of observable objects:</p> <ol> <li>Observable: For tracking changes to scalar values (strings, numbers, booleans, etc.)</li> <li>ObservableList: For tracking changes to lists</li> <li>ObservableDict: For tracking changes to dictionaries</li> </ol> <p>Each of these objects allows you to register callbacks that are called when the value changes.</p>"},{"location":"features/change_tracking/#scalar-observables","title":"Scalar Observables","text":"<p>The <code>Observable</code> class is the simplest form of change tracking in Observant. It wraps a single value and notifies listeners when that value changes.</p> <pre><code>from observant import Observable\n\n# Create an observable with an initial value\ncounter = Observable[int](0)\n\n# Register a callback to be notified when the value changes\ncounter.on_change(lambda value: print(f\"Counter changed to: {value}\"))\n\n# Change the value\ncounter.set(1)  # Prints: \"Counter changed to: 1\"\n\n# Get the current value\ncurrent_value = counter.get()  # Returns: 1\n</code></pre>"},{"location":"features/change_tracking/#multiple-callbacks","title":"Multiple Callbacks","text":"<p>You can register multiple callbacks for the same observable:</p> <pre><code>counter = Observable[int](0)\n\n# Register multiple callbacks\ncounter.on_change(lambda value: print(f\"Callback 1: {value}\"))\ncounter.on_change(lambda value: print(f\"Callback 2: {value}\"))\n\n# Change the value\ncounter.set(1)  # Prints both callback messages\n</code></pre>"},{"location":"features/change_tracking/#suppressing-notifications","title":"Suppressing Notifications","text":"<p>Sometimes you may want to update a value without triggering callbacks. You can do this by setting <code>notify=False</code>:</p> <pre><code>counter = Observable[int](0)\ncounter.on_change(lambda value: print(f\"Counter changed to: {value}\"))\n\n# Update without notification\ncounter.set(1, notify=False)  # No callback is triggered\n\n# The value is still updated\nprint(counter.get())  # Prints: 1\n</code></pre>"},{"location":"features/change_tracking/#list-observables","title":"List Observables","text":"<p>The <code>ObservableList</code> class tracks changes to a list, including additions, removals, and modifications.</p> <pre><code>from observant import ObservableList, ObservableCollectionChangeType\n\n# Create an observable list\ntasks = ObservableList[str]([\"Task 1\"])\n\n# Register a callback\ndef on_tasks_change(change):\n    if change.type == ObservableCollectionChangeType.ADD:\n        if hasattr(change, \"item\"):\n            print(f\"Added task: {change.item}\")\n        else:\n            print(f\"Added tasks: {change.items}\")\n    elif change.type == ObservableCollectionChangeType.REMOVE:\n        if hasattr(change, \"item\"):\n            print(f\"Removed task: {change.item}\")\n        else:\n            print(f\"Removed tasks: {change.items}\")\n    elif change.type == ObservableCollectionChangeType.CLEAR:\n        print(f\"Cleared tasks: {change.items}\")\n\ntasks.on_change(on_tasks_change)\n\n# Add an item\ntasks.append(\"Task 2\")  # Prints: \"Added task: Task 2\"\n\n# Add multiple items\ntasks.extend([\"Task 3\", \"Task 4\"])  # Prints: \"Added tasks: ['Task 3', 'Task 4']\"\n\n# Remove an item\ntasks.remove(\"Task 1\")  # Prints: \"Removed task: Task 1\"\n\n# Clear the list\ntasks.clear()  # Prints: \"Cleared tasks: ['Task 2', 'Task 3', 'Task 4']\"\n</code></pre>"},{"location":"features/change_tracking/#list-change-information","title":"List Change Information","text":"<p>When a list changes, the callback receives a <code>ObservableListChange</code> object with the following properties:</p> <ul> <li><code>type</code>: The type of change (ADD, REMOVE, CLEAR)</li> <li><code>index</code>: The index where the change occurred (for ADD and REMOVE)</li> <li><code>item</code>: The item that was added or removed (for single-item changes)</li> <li><code>items</code>: The items that were added or removed (for multi-item changes)</li> </ul>"},{"location":"features/change_tracking/#list-operations","title":"List Operations","text":"<p><code>ObservableList</code> supports all standard Python list operations, including:</p> <ul> <li><code>append(item)</code>: Add an item to the end of the list</li> <li><code>extend(items)</code>: Add multiple items to the end of the list</li> <li><code>insert(index, item)</code>: Insert an item at a specific index</li> <li><code>remove(item)</code>: Remove an item from the list</li> <li><code>pop([index])</code>: Remove and return an item at a specific index (or the last item if no index is provided)</li> <li><code>clear()</code>: Remove all items from the list</li> <li><code>sort()</code>: Sort the list in place</li> <li><code>reverse()</code>: Reverse the list in place</li> <li><code>__getitem__(index)</code>: Access an item by index (<code>list[index]</code>)</li> <li><code>__setitem__(index, value)</code>: Set an item by index (<code>list[index] = value</code>)</li> <li><code>__delitem__(index)</code>: Delete an item by index (<code>del list[index]</code>)</li> </ul>"},{"location":"features/change_tracking/#dict-observables","title":"Dict Observables","text":"<p>The <code>ObservableDict</code> class tracks changes to a dictionary, including additions, updates, and removals.</p> <pre><code>from observant import ObservableDict, ObservableCollectionChangeType\n\n# Create an observable dictionary\nsettings = ObservableDict[str, str]({\"theme\": \"dark\"})\n\n# Register a callback\ndef on_settings_change(change):\n    if change.type == ObservableCollectionChangeType.ADD:\n        if hasattr(change, \"key\"):\n            print(f\"Added setting: {change.key} = {change.value}\")\n        else:\n            print(f\"Added settings: {change.items}\")\n    elif change.type == ObservableCollectionChangeType.UPDATE:\n        if hasattr(change, \"key\"):\n            print(f\"Updated setting: {change.key} = {change.value}\")\n        else:\n            print(f\"Updated settings: {change.items}\")\n    elif change.type == ObservableCollectionChangeType.REMOVE:\n        if hasattr(change, \"key\"):\n            print(f\"Removed setting: {change.key}\")\n        else:\n            print(f\"Removed settings: {change.items}\")\n    elif change.type == ObservableCollectionChangeType.CLEAR:\n        print(f\"Cleared settings: {change.items}\")\n\nsettings.on_change(on_settings_change)\n\n# Add a new key\nsettings[\"language\"] = \"en\"  # Prints: \"Added setting: language = en\"\n\n# Update an existing key\nsettings[\"theme\"] = \"light\"  # Prints: \"Updated setting: theme = light\"\n\n# Remove a key\ndel settings[\"theme\"]  # Prints: \"Removed setting: theme\"\n\n# Update multiple keys at once\nsettings.update({\"theme\": \"dark\", \"font\": \"Arial\"})  # Prints appropriate messages\n\n# Clear the dictionary\nsettings.clear()  # Prints: \"Cleared settings: {'language': 'en'}\"\n</code></pre>"},{"location":"features/change_tracking/#dict-change-information","title":"Dict Change Information","text":"<p>When a dictionary changes, the callback receives a <code>ObservableDictChange</code> object with the following properties:</p> <ul> <li><code>type</code>: The type of change (ADD, UPDATE, REMOVE, CLEAR)</li> <li><code>key</code>: The key that was added, updated, or removed (for single-item changes)</li> <li><code>value</code>: The value that was added or updated (for single-item changes)</li> <li><code>items</code>: The items that were added, updated, or removed (for multi-item changes)</li> </ul>"},{"location":"features/change_tracking/#dict-operations","title":"Dict Operations","text":"<p><code>ObservableDict</code> supports all standard Python dictionary operations, including:</p> <ul> <li><code>__getitem__(key)</code>: Access a value by key (<code>dict[key]</code>)</li> <li><code>__setitem__(key, value)</code>: Set a value by key (<code>dict[key] = value</code>)</li> <li><code>__delitem__(key)</code>: Delete a key-value pair (<code>del dict[key]</code>)</li> <li><code>get(key, [default])</code>: Get a value by key, with an optional default value</li> <li><code>setdefault(key, [default])</code>: Get a value by key, or set it to a default value if the key doesn't exist</li> <li><code>pop(key, [default])</code>: Remove and return a value by key, with an optional default value</li> <li><code>popitem()</code>: Remove and return an arbitrary key-value pair</li> <li><code>clear()</code>: Remove all items from the dictionary</li> <li><code>update(other)</code>: Update the dictionary with key-value pairs from another dictionary</li> </ul>"},{"location":"features/change_tracking/#on_change-callbacks","title":"on_change Callbacks","text":"<p>The <code>on_change</code> method is used to register callbacks that are called when the value changes. The callback function receives different arguments depending on the type of observable:</p> <ul> <li>For <code>Observable</code>, the callback receives the new value.</li> <li>For <code>ObservableList</code>, the callback receives a <code>ObservableListChange</code> object.</li> <li>For <code>ObservableDict</code>, the callback receives a <code>ObservableDictChange</code> object.</li> </ul>"},{"location":"features/change_tracking/#callback-behavior","title":"Callback Behavior","text":"<p>Callbacks are called immediately after the value changes. If multiple callbacks are registered, they are called in the order they were registered.</p> <pre><code>counter = Observable[int](0)\n\n# Register callbacks\ncounter.on_change(lambda value: print(f\"First callback: {value}\"))\ncounter.on_change(lambda value: print(f\"Second callback: {value}\"))\n\n# Change the value\ncounter.set(1)\n# Prints:\n# First callback: 1\n# Second callback: 1\n</code></pre>"},{"location":"features/change_tracking/#reentrant-callbacks","title":"Reentrant Callbacks","text":"<p>Callbacks can trigger other changes, which can in turn trigger other callbacks. This is known as \"reentrant\" behavior.</p> <pre><code>name = Observable[str](\"Alice\")\ngreeting = Observable[str](\"Hello, Alice!\")\n\n# Update greeting when name changes\nname.on_change(lambda value: greeting.set(f\"Hello, {value}!\"))\n\n# Register callbacks\nname.on_change(lambda value: print(f\"Name changed to: {value}\"))\ngreeting.on_change(lambda value: print(f\"Greeting changed to: {value}\"))\n\n# Change the name\nname.set(\"Bob\")\n# Prints:\n# Name changed to: Bob\n# Greeting changed to: Hello, Bob!\n</code></pre>"},{"location":"features/change_tracking/#notes-on-performance","title":"Notes on Performance","text":"<p>While observables are powerful, they do come with some overhead. Here are some tips for optimizing performance:</p> <ul> <li>Minimize the number of observables: Create observables only for values that need to be tracked.</li> <li>Use batch updates: When making multiple changes, consider using batch operations like <code>extend()</code> for lists or <code>update()</code> for dictionaries, rather than individual operations.</li> <li>Be careful with reentrant callbacks: Complex chains of callbacks can lead to performance issues and hard-to-debug behavior.</li> <li>Use <code>notify=False</code> when appropriate: If you're making multiple changes and only care about the final state, consider using <code>notify=False</code> for intermediate changes.</li> </ul> <pre><code># Instead of this:\ntasks.append(\"Task 1\")\ntasks.append(\"Task 2\")\ntasks.append(\"Task 3\")\n\n# Consider this:\ntasks.extend([\"Task 1\", \"Task 2\", \"Task 3\"])\n</code></pre>"},{"location":"features/change_tracking/#next-steps","title":"Next Steps","text":"<p>Now that you understand how change tracking works in Observant, you might want to explore:</p> <ul> <li>Validation: Add validation to your models</li> <li>Computed Properties: Create properties that depend on other fields</li> <li>Undo and Redo: Implement undo/redo functionality</li> </ul>"},{"location":"features/computed/","title":"Computed Properties","text":"<p>Observant provides a powerful computed properties system that allows you to define properties that depend on other fields and automatically update when those fields change. This page explains how computed properties work in Observant.</p>"},{"location":"features/computed/#overview","title":"Overview","text":"<p>Computed properties are virtual fields that derive their values from other fields. They are useful for:</p> <ul> <li>Combining multiple fields (e.g., full name from first and last name)</li> <li>Formatting data (e.g., formatted date from a timestamp)</li> <li>Calculating derived values (e.g., total price from quantity and unit price)</li> <li>Implementing complex business logic</li> </ul> <p>Key features of computed properties in Observant:</p> <ul> <li>Automatic dependency tracking</li> <li>Observable access to computed values</li> <li>Support for validation</li> <li>Integration with the undo system</li> </ul>"},{"location":"features/computed/#registering-computed-fields","title":"Registering Computed Fields","text":"<p>You can register a computed property using the <code>register_computed</code> method of <code>ObservableProxy</code>. This method takes:</p> <ul> <li>The name of the computed property</li> <li>A function that calculates the value</li> <li>A list of field names that the computed property depends on</li> </ul> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\n# Create a user and proxy\nuser = User(first_name=\"Alice\", last_name=\"Smith\")\nproxy = ObservableProxy(user)\n\n# Register a computed property for full name\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\n\n# Access the computed value\nfull_name = proxy.computed(str, \"full_name\").get()\nprint(full_name)  # \"Alice Smith\"\n</code></pre>"},{"location":"features/computed/#accessing-computed-values","title":"Accessing Computed Values","text":"<p>You can access a computed value using the <code>computed</code> method, which returns an observable:</p> <pre><code># Get the computed value as an observable\nfull_name_obs = proxy.computed(str, \"full_name\")\n\n# Register a callback to be notified when the computed value changes\nfull_name_obs.on_change(lambda value: print(f\"Full name changed to: {value}\"))\n\n# Get the current value\ncurrent_full_name = full_name_obs.get()\n</code></pre>"},{"location":"features/computed/#updating-dependencies","title":"Updating Dependencies","text":"<p>When a dependency of a computed property changes, the computed property is automatically recalculated:</p> <pre><code># Change a dependency\nproxy.observable(str, \"first_name\").set(\"Bob\")\n\n# The computed property is automatically updated\nprint(proxy.computed(str, \"full_name\").get())  # \"Bob Smith\"\n</code></pre>"},{"location":"features/computed/#dependency-tracking","title":"Dependency Tracking","text":"<p>Observant tracks dependencies between computed properties and their source fields. When a source field changes, all computed properties that depend on it are automatically recalculated.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass Product:\n    name: str\n    price: float\n    quantity: int\n\n# Create a product and proxy\nproduct = Product(name=\"Widget\", price=10.0, quantity=2)\nproxy = ObservableProxy(product)\n\n# Register a computed property for total price\nproxy.register_computed(\n    \"total_price\",\n    lambda: proxy.observable(float, \"price\").get() * proxy.observable(int, \"quantity\").get(),\n    dependencies=[\"price\", \"quantity\"]\n)\n\n# Access the computed value\nprint(proxy.computed(float, \"total_price\").get())  # 20.0\n\n# Update a dependency\nproxy.observable(int, \"quantity\").set(3)\n\n# The computed property is automatically updated\nprint(proxy.computed(float, \"total_price\").get())  # 30.0\n</code></pre>"},{"location":"features/computed/#explicit-vs-implicit-dependencies","title":"Explicit vs. Implicit Dependencies","text":"<p>In the examples above, we explicitly listed the dependencies of each computed property. Observant also supports implicit dependency detection, where the dependencies are inferred from the fields accessed in the computation function.</p> <p>However, it's generally recommended to explicitly list dependencies for clarity and to avoid potential issues with complex computations.</p>"},{"location":"features/computed/#chained-computed-fields","title":"Chained Computed Fields","text":"<p>Computed properties can depend on other computed properties, creating a chain of dependencies:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass Order:\n    price: float\n    quantity: int\n    tax_rate: float\n\n# Create an order and proxy\norder = Order(price=10.0, quantity=2, tax_rate=0.1)\nproxy = ObservableProxy(order)\n\n# Register a computed property for subtotal\nproxy.register_computed(\n    \"subtotal\",\n    lambda: proxy.observable(float, \"price\").get() * proxy.observable(int, \"quantity\").get(),\n    dependencies=[\"price\", \"quantity\"]\n)\n\n# Register a computed property for tax amount, which depends on subtotal\nproxy.register_computed(\n    \"tax_amount\",\n    lambda: proxy.computed(float, \"subtotal\").get() * proxy.observable(float, \"tax_rate\").get(),\n    dependencies=[\"subtotal\", \"tax_rate\"]\n)\n\n# Register a computed property for total, which depends on subtotal and tax amount\nproxy.register_computed(\n    \"total\",\n    lambda: proxy.computed(float, \"subtotal\").get() + proxy.computed(float, \"tax_amount\").get(),\n    dependencies=[\"subtotal\", \"tax_amount\"]\n)\n\n# Access the computed values\nprint(proxy.computed(float, \"subtotal\").get())    # 20.0\nprint(proxy.computed(float, \"tax_amount\").get())  # 2.0\nprint(proxy.computed(float, \"total\").get())       # 22.0\n\n# Update a dependency\nproxy.observable(int, \"quantity\").set(3)\n\n# All computed properties are automatically updated\nprint(proxy.computed(float, \"subtotal\").get())    # 30.0\nprint(proxy.computed(float, \"tax_amount\").get())  # 3.0\nprint(proxy.computed(float, \"total\").get())       # 33.0\n</code></pre> <p>In this example, changing the <code>quantity</code> field triggers updates to <code>subtotal</code>, which in turn triggers updates to <code>tax_amount</code> and <code>total</code>.</p>"},{"location":"features/computed/#shadowing-real-fields","title":"Shadowing Real Fields","text":"<p>Computed properties can shadow real fields, meaning they can have the same name as a field in the underlying model. This can be useful for adding formatting or validation to existing fields.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user and proxy\nuser = User(name=\"alice\", age=30)\nproxy = ObservableProxy(user)\n\n# Register a computed property that shadows the 'name' field\nproxy.register_computed(\n    \"name\",\n    lambda: proxy.observable(str, \"name\").get().capitalize(),\n    dependencies=[\"name\"]\n)\n\n# Access the computed value\nprint(proxy.computed(str, \"name\").get())  # \"Alice\"\n\n# The original field is still accessible\nprint(proxy.observable(str, \"name\").get())  # \"alice\"\n</code></pre> <p>When shadowing a field, you need to be careful to avoid infinite recursion. In the example above, the computed property accesses the original field using <code>proxy.observable(str, \"name\")</code>, not <code>proxy.computed(str, \"name\")</code>.</p>"},{"location":"features/computed/#circular-dependencies","title":"Circular Dependencies","text":"<p>Observant detects circular dependencies between computed properties and raises an error if it finds any:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass Circular:\n    value: int\n\n# Create a model and proxy\ncircular = Circular(value=0)\nproxy = ObservableProxy(circular)\n\n# Register computed properties with a circular dependency\nproxy.register_computed(\n    \"a\",\n    lambda: proxy.computed(int, \"b\").get() + 1,\n    dependencies=[\"b\"]\n)\n\n# This will raise an error because it creates a circular dependency\nproxy.register_computed(\n    \"b\",\n    lambda: proxy.computed(int, \"a\").get() + 1,\n    dependencies=[\"a\"]\n)\n</code></pre> <p>To avoid circular dependencies, make sure that your computed properties form a directed acyclic graph (DAG), where each property only depends on properties that don't depend on it, directly or indirectly.</p>"},{"location":"features/computed/#validation-of-computed-fields","title":"Validation of Computed Fields","text":"<p>Computed properties can be validated just like regular fields:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\n# Create a user and proxy\nuser = User(first_name=\"\", last_name=\"\")\nproxy = ObservableProxy(user)\n\n# Register a computed property for full name\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\n\n# Add a validator to the computed field\nproxy.add_validator(\"full_name\", lambda v: \"Full name too short\" if len(v.strip()) &lt; 5 else None)\n\n# Check validation\nprint(proxy.is_valid())  # False\nprint(proxy.validation_for(\"full_name\").get())  # [\"Full name too short\"]\n\n# Update the dependencies\nproxy.observable(str, \"first_name\").set(\"Alice\")\nproxy.observable(str, \"last_name\").set(\"Smith\")\n\n# Validation is automatically updated\nprint(proxy.is_valid())  # True\nprint(proxy.validation_for(\"full_name\").get())  # []\n</code></pre> <p>When a dependency of a computed property changes, the computed property is recalculated and its validators are re-run.</p>"},{"location":"features/computed/#computed-fields-and-undo","title":"Computed Fields and Undo","text":"<p>Computed properties are not directly undoable, since their values are derived from other fields. However, when you undo changes to a field that a computed property depends on, the computed property will update accordingly:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\n# Create a user and proxy\nuser = User(first_name=\"Alice\", last_name=\"Smith\")\nproxy = ObservableProxy(user, undo=True)\n\n# Register a computed property for full name\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\n\n# Make a change\nproxy.observable(str, \"first_name\").set(\"Bob\")\nprint(proxy.computed(str, \"full_name\").get())  # \"Bob Smith\"\n\n# Undo the change\nproxy.undo(\"first_name\")\nprint(proxy.computed(str, \"full_name\").get())  # \"Alice Smith\"\n</code></pre>"},{"location":"features/computed/#next-steps","title":"Next Steps","text":"<p>Now that you understand how computed properties work in Observant, you might want to explore:</p> <ul> <li>Dirty Tracking: Track unsaved changes</li> <li>Sync vs Non-Sync: Understand immediate vs. deferred updates</li> <li>Saving and Loading: Save changes and load data</li> </ul>"},{"location":"features/dirty/","title":"Dirty Tracking","text":"<p>Observant provides a dirty tracking system that allows you to track which fields have been modified since the last save or reset. This page explains how dirty tracking works in Observant.</p>"},{"location":"features/dirty/#overview","title":"Overview","text":"<p>Dirty tracking is useful for:</p> <ul> <li>Knowing which fields have been modified</li> <li>Enabling/disabling save buttons based on whether there are unsaved changes</li> <li>Prompting users to save changes before navigating away</li> <li>Optimizing save operations by only saving modified fields</li> </ul> <p>Key features of dirty tracking in Observant:</p> <ul> <li>Field-level dirty tracking</li> <li>Observable dirty state</li> <li>Integration with undo/redo</li> <li>Exclusion of computed fields</li> </ul>"},{"location":"features/dirty/#what-is-dirty","title":"What is Dirty?","text":"<p>In Observant, a field is considered \"dirty\" if its value has been changed since the last save or reset. The dirty state is tracked at the field level, so you can see exactly which fields have been modified.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user and proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user)\n\n# Initially, no fields are dirty\nprint(proxy.is_dirty())  # False\nprint(proxy.dirty_fields())  # []\n\n# Modify a field\nproxy.observable(str, \"name\").set(\"Bob\")\n\n# Now the field is dirty\nprint(proxy.is_dirty())  # True\nprint(proxy.dirty_fields())  # [\"name\"]\n\n# Modify another field\nproxy.observable(int, \"age\").set(31)\n\n# Now both fields are dirty\nprint(proxy.is_dirty())  # True\nprint(proxy.dirty_fields())  # [\"name\", \"age\"]\n</code></pre>"},{"location":"features/dirty/#tracking-dirty-fields","title":"Tracking Dirty Fields","text":"<p>Observant provides several methods for tracking dirty fields:</p> <ul> <li><code>is_dirty()</code>: Returns whether any field is dirty</li> <li><code>dirty_fields()</code>: Returns a list of dirty field names</li> <li><code>is_field_dirty(field)</code>: Returns whether a specific field is dirty</li> </ul>"},{"location":"features/dirty/#is_dirty","title":"is_dirty()","text":"<p>The <code>is_dirty()</code> method returns an observable boolean indicating whether any field is dirty:</p> <pre><code># Check if any field is dirty\nis_dirty = proxy.is_dirty()\nprint(is_dirty.get())  # True or False\n\n# Listen for changes to the dirty state\nis_dirty.on_change(lambda dirty: print(f\"Dirty state changed: {dirty}\"))\n</code></pre>"},{"location":"features/dirty/#dirty_fields","title":"dirty_fields()","text":"<p>The <code>dirty_fields()</code> method returns an observable list of dirty field names:</p> <pre><code># Get a list of dirty fields\ndirty_fields = proxy.dirty_fields()\nprint(dirty_fields.get())  # [\"name\", \"age\"]\n\n# Listen for changes to the dirty fields\ndirty_fields.on_change(lambda fields: print(f\"Dirty fields changed: {fields}\"))\n</code></pre>"},{"location":"features/dirty/#is_field_dirtyfield","title":"is_field_dirty(field)","text":"<p>The <code>is_field_dirty(field)</code> method returns an observable boolean indicating whether a specific field is dirty:</p> <pre><code># Check if a specific field is dirty\nis_name_dirty = proxy.is_field_dirty(\"name\")\nprint(is_name_dirty.get())  # True or False\n\n# Listen for changes to the field's dirty state\nis_name_dirty.on_change(lambda dirty: print(f\"Name dirty state changed: {dirty}\"))\n</code></pre>"},{"location":"features/dirty/#reset_dirty","title":"reset_dirty()","text":"<p>The <code>reset_dirty()</code> method resets the dirty state for all fields or for a specific field:</p> <pre><code># Reset dirty state for all fields\nproxy.reset_dirty()\n\n# Reset dirty state for a specific field\nproxy.reset_dirty(\"name\")\n</code></pre> <p>After resetting the dirty state, the current values become the new baseline for dirty tracking. Any subsequent changes will mark the fields as dirty again.</p> <pre><code># Initially, no fields are dirty\nprint(proxy.is_dirty())  # False\n\n# Modify a field\nproxy.observable(str, \"name\").set(\"Bob\")\n\n# Now the field is dirty\nprint(proxy.is_dirty())  # True\n\n# Reset dirty state\nproxy.reset_dirty()\n\n# Now no fields are dirty again\nprint(proxy.is_dirty())  # False\n\n# Modify the field again\nproxy.observable(str, \"name\").set(\"Charlie\")\n\n# Now the field is dirty again\nprint(proxy.is_dirty())  # True\n</code></pre>"},{"location":"features/dirty/#interaction-with-undo","title":"Interaction with Undo","text":"<p>The dirty tracking system integrates with the undo system. When you undo or redo a change, the dirty state is updated accordingly:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user and proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, undo=True)\n\n# Initially, no fields are dirty\nprint(proxy.is_dirty())  # False\n\n# Modify a field\nproxy.observable(str, \"name\").set(\"Bob\")\n\n# Now the field is dirty\nprint(proxy.is_dirty())  # True\nprint(proxy.dirty_fields())  # [\"name\"]\n\n# Undo the change\nproxy.undo(\"name\")\n\n# The field is no longer dirty\nprint(proxy.is_dirty())  # False\nprint(proxy.dirty_fields())  # []\n\n# Redo the change\nproxy.redo(\"name\")\n\n# The field is dirty again\nprint(proxy.is_dirty())  # True\nprint(proxy.dirty_fields())  # [\"name\"]\n</code></pre>"},{"location":"features/dirty/#undo-to-original-value","title":"Undo to Original Value","text":"<p>If you make multiple changes to a field and then undo back to the original value, the field is no longer considered dirty:</p> <pre><code># Initially, no fields are dirty\nprint(proxy.is_dirty())  # False\n\n# Modify a field multiple times\nproxy.observable(str, \"name\").set(\"Bob\")\nproxy.observable(str, \"name\").set(\"Charlie\")\nproxy.observable(str, \"name\").set(\"Dave\")\n\n# Now the field is dirty\nprint(proxy.is_dirty())  # True\n\n# Undo all changes\nproxy.undo(\"name\")  # Reverts to \"Charlie\"\nproxy.undo(\"name\")  # Reverts to \"Bob\"\nproxy.undo(\"name\")  # Reverts to \"Alice\" (original value)\n\n# The field is no longer dirty\nprint(proxy.is_dirty())  # False\n</code></pre>"},{"location":"features/dirty/#computed-fields-and-dirty-state","title":"Computed Fields and Dirty State","text":"<p>Computed fields are not included in dirty tracking, since their values are derived from other fields. When a dependency of a computed field changes, the computed field itself is not marked as dirty.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\n# Create a user and proxy\nuser = User(first_name=\"Alice\", last_name=\"Smith\")\nproxy = ObservableProxy(user)\n\n# Register a computed property for full name\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\n\n# Initially, no fields are dirty\nprint(proxy.is_dirty())  # False\nprint(proxy.dirty_fields())  # []\n\n# Modify a dependency\nproxy.observable(str, \"first_name\").set(\"Bob\")\n\n# Only the dependency is marked as dirty, not the computed field\nprint(proxy.is_dirty())  # True\nprint(proxy.dirty_fields())  # [\"first_name\"]\n</code></pre>"},{"location":"features/dirty/#practical-use-cases","title":"Practical Use Cases","text":""},{"location":"features/dirty/#enablingdisabling-save-buttons","title":"Enabling/Disabling Save Buttons","text":"<p>You can use the dirty state to enable or disable save buttons in a UI:</p> <pre><code># In a UI framework\nsave_button.disabled = not proxy.is_dirty().get()\n\n# Listen for changes to the dirty state\nproxy.is_dirty().on_change(lambda dirty: save_button.disabled = not dirty)\n</code></pre>"},{"location":"features/dirty/#prompting-to-save-changes","title":"Prompting to Save Changes","text":"<p>You can use the dirty state to prompt users to save changes before navigating away:</p> <pre><code>def on_navigate_away():\n    if proxy.is_dirty().get():\n        # Show a confirmation dialog\n        if confirm(\"You have unsaved changes. Save before leaving?\"):\n            save_changes()\n    # Navigate away\n    navigate_to_next_page()\n</code></pre>"},{"location":"features/dirty/#optimizing-save-operations","title":"Optimizing Save Operations","text":"<p>You can use the dirty fields to optimize save operations by only saving modified fields:</p> <pre><code>def save_changes():\n    dirty = proxy.dirty_fields().get()\n    if not dirty:\n        return  # Nothing to save\n\n    # Create a dictionary with only the dirty fields\n    data = {}\n    for field in dirty:\n        if field == \"name\":\n            data[field] = proxy.observable(str, field).get()\n        elif field == \"age\":\n            data[field] = proxy.observable(int, field).get()\n\n    # Save only the dirty fields\n    api.update_user(user_id, data)\n\n    # Reset dirty state\n    proxy.reset_dirty()\n</code></pre>"},{"location":"features/dirty/#next-steps","title":"Next Steps","text":"<p>Now that you understand how dirty tracking works in Observant, you might want to explore:</p> <ul> <li>Sync vs Non-Sync: Understand immediate vs. deferred updates</li> <li>Saving and Loading: Save changes and load data</li> <li>API Reference: Detailed API documentation</li> </ul>"},{"location":"features/save_load/","title":"Saving and Loading","text":"<p>Observant provides methods for saving changes back to the model and loading data from external sources. This page explains how saving and loading work in Observant.</p>"},{"location":"features/save_load/#overview","title":"Overview","text":"<p>When working with <code>ObservableProxy</code>, you often need to:</p> <ul> <li>Save changes back to the original model</li> <li>Load data from external sources (e.g., API responses, user input)</li> <li>Update multiple fields at once</li> </ul> <p>Observant provides several methods for these operations:</p> <ul> <li><code>save_to()</code>: Save changes back to a model</li> <li><code>load_dict()</code>: Load data from a dictionary</li> <li><code>update()</code>: Update specific fields</li> </ul>"},{"location":"features/save_load/#save_to","title":"save_to()","text":"<p>The <code>save_to()</code> method saves the current state of the proxy back to a model:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user and proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=False)\n\n# Make changes\nproxy.observable(str, \"name\").set(\"Bob\")\nproxy.observable(int, \"age\").set(31)\n\n# Save changes back to the model\nproxy.save_to(user)\n\n# The model is updated\nprint(user.name)  # \"Bob\"\nprint(user.age)   # 31\n</code></pre>"},{"location":"features/save_load/#saving-to-a-different-model","title":"Saving to a Different Model","text":"<p>You can save changes to a different model instance, as long as it has the same structure:</p> <pre><code># Create two user instances\nuser1 = User(name=\"Alice\", age=30)\nuser2 = User(name=\"Charlie\", age=32)\n\n# Create a proxy for user1\nproxy = ObservableProxy(user1, sync=False)\n\n# Make changes\nproxy.observable(str, \"name\").set(\"Bob\")\nproxy.observable(int, \"age\").set(31)\n\n# Save changes to user2\nproxy.save_to(user2)\n\n# user2 is updated\nprint(user2.name)  # \"Bob\"\nprint(user2.age)   # 31\n\n# user1 is unchanged\nprint(user1.name)  # \"Alice\"\nprint(user1.age)   # 30\n</code></pre> <p>This can be useful when you want to:</p> <ul> <li>Create a copy of a model with modifications</li> <li>Apply changes to multiple models</li> <li>Implement a \"reset to original\" feature</li> </ul>"},{"location":"features/save_load/#saving-and-dirty-state","title":"Saving and Dirty State","text":"<p>When you call <code>save_to()</code>, the dirty state is not automatically reset. If you want to reset the dirty state, you need to call <code>reset_dirty()</code> explicitly:</p> <pre><code># Make changes\nproxy.observable(str, \"name\").set(\"Bob\")\n\n# The field is dirty\nprint(proxy.is_dirty())  # True\n\n# Save changes\nproxy.save_to(user)\n\n# The field is still dirty\nprint(proxy.is_dirty())  # True\n\n# Reset dirty state\nproxy.reset_dirty()\n\n# Now the field is not dirty\nprint(proxy.is_dirty())  # False\n</code></pre> <p>This behavior allows you to track whether changes have been saved to a specific model, even if you save to multiple models.</p>"},{"location":"features/save_load/#load_dict","title":"load_dict()","text":"<p>The <code>load_dict()</code> method loads data from a dictionary into the proxy:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user and proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=False)\n\n# Load data from a dictionary\nproxy.load_dict({\n    \"name\": \"Bob\",\n    \"age\": 31\n})\n\n# The proxy is updated\nprint(proxy.observable(str, \"name\").get())  # \"Bob\"\nprint(proxy.observable(int, \"age\").get())  # 31\n\n# The model is not updated yet\nprint(user.name)  # \"Alice\"\nprint(user.age)   # 30\n\n# Save changes to the model\nproxy.save_to(user)\n\n# Now the model is updated\nprint(user.name)  # \"Bob\"\nprint(user.age)   # 31\n</code></pre>"},{"location":"features/save_load/#reset_missing","title":"reset_missing","text":"<p>The <code>load_dict()</code> method has an optional <code>reset_missing</code> parameter. When set to <code>True</code>, fields that are not in the dictionary are reset to their default values:</p> <pre><code># Load data with reset_missing=True\nproxy.load_dict({\n    \"name\": \"Charlie\"\n}, reset_missing=True)\n\n# Fields not in the dictionary are reset\nprint(proxy.observable(str, \"name\").get())  # \"Charlie\"\nprint(proxy.observable(int, \"age\").get())  # 0 (default value for int)\n</code></pre> <p>When <code>reset_missing=False</code> (the default), fields not in the dictionary are left unchanged:</p> <pre><code># Load data with reset_missing=False\nproxy.load_dict({\n    \"name\": \"Dave\"\n}, reset_missing=False)\n\n# Fields not in the dictionary are unchanged\nprint(proxy.observable(str, \"name\").get())  # \"Dave\"\nprint(proxy.observable(int, \"age\").get())  # 31 (unchanged)\n</code></pre>"},{"location":"features/save_load/#validation-and-load_dict","title":"Validation and load_dict()","text":"<p>When you call <code>load_dict()</code>, validation is automatically triggered for the fields that are updated:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user and proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=False)\n\n# Add validators\nproxy.add_validator(\"name\", lambda v: \"Name required\" if not v else None)\nproxy.add_validator(\"age\", lambda v: \"Age must be positive\" if v &lt;= 0 else None)\n\n# Load valid data\nproxy.load_dict({\n    \"name\": \"Bob\",\n    \"age\": 31\n})\n\n# Validation passes\nprint(proxy.is_valid())  # True\n\n# Load invalid data\nproxy.load_dict({\n    \"name\": \"\",\n    \"age\": -1\n})\n\n# Validation fails\nprint(proxy.is_valid())  # False\nprint(proxy.validation_errors())  # {\"name\": [\"Name required\"], \"age\": [\"Age must be positive\"]}\n</code></pre>"},{"location":"features/save_load/#update","title":"update()","text":"<p>The <code>update()</code> method updates specific fields in the proxy:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n    email: str\n\n# Create a user and proxy\nuser = User(name=\"Alice\", age=30, email=\"alice@example.com\")\nproxy = ObservableProxy(user, sync=False)\n\n# Update specific fields\nproxy.update({\n    \"name\": \"Bob\",\n    \"age\": 31\n})\n\n# Only the specified fields are updated\nprint(proxy.observable(str, \"name\").get())  # \"Bob\"\nprint(proxy.observable(int, \"age\").get())  # 31\nprint(proxy.observable(str, \"email\").get())  # \"alice@example.com\" (unchanged)\n</code></pre>"},{"location":"features/save_load/#update-vs-load_dict","title":"update() vs load_dict()","text":"<p>The main differences between <code>update()</code> and <code>load_dict()</code> are:</p> <ol> <li><code>update()</code> only updates the fields that are provided in the dictionary</li> <li><code>load_dict()</code> can optionally reset fields that are not in the dictionary</li> <li><code>update()</code> does not have a <code>reset_missing</code> parameter</li> </ol> <pre><code># update() only updates the specified fields\nproxy.update({\n    \"name\": \"Charlie\"\n})\nprint(proxy.observable(str, \"name\").get())  # \"Charlie\"\nprint(proxy.observable(int, \"age\").get())  # 31 (unchanged)\n\n# load_dict() with reset_missing=True resets unspecified fields\nproxy.load_dict({\n    \"name\": \"Dave\"\n}, reset_missing=True)\nprint(proxy.observable(str, \"name\").get())  # \"Dave\"\nprint(proxy.observable(int, \"age\").get())  # 0 (reset to default)\n</code></pre>"},{"location":"features/save_load/#saving-to-different-models","title":"Saving to Different Models","text":"<p>One powerful feature of Observant is the ability to save changes to different models. This can be useful for:</p> <ul> <li>Creating copies of a model with modifications</li> <li>Applying changes to multiple models</li> <li>Implementing a \"reset to original\" feature</li> </ul> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create original user\noriginal_user = User(name=\"Alice\", age=30)\n\n# Create a proxy\nproxy = ObservableProxy(original_user, sync=False)\n\n# Make changes\nproxy.observable(str, \"name\").set(\"Bob\")\nproxy.observable(int, \"age\").set(31)\n\n# Create a modified copy\nmodified_user = User(name=\"\", age=0)\nproxy.save_to(modified_user)\n\n# original_user is unchanged\nprint(original_user.name)  # \"Alice\"\nprint(original_user.age)   # 30\n\n# modified_user has the changes\nprint(modified_user.name)  # \"Bob\"\nprint(modified_user.age)   # 31\n</code></pre>"},{"location":"features/save_load/#saving-to-models-with-different-fields","title":"Saving to Models with Different Fields","text":"<p>When saving to a model with a different structure, only the fields that exist in both the proxy and the target model are updated:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n    email: str\n\n@dataclass\nclass SimpleUser:\n    name: str\n    age: int\n\n# Create a user and proxy\nuser = User(name=\"Alice\", age=30, email=\"alice@example.com\")\nproxy = ObservableProxy(user, sync=False)\n\n# Make changes\nproxy.observable(str, \"name\").set(\"Bob\")\nproxy.observable(int, \"age\").set(31)\nproxy.observable(str, \"email\").set(\"bob@example.com\")\n\n# Create a simple user\nsimple_user = SimpleUser(name=\"\", age=0)\n\n# Save changes to the simple user\nproxy.save_to(simple_user)\n\n# Only the fields that exist in SimpleUser are updated\nprint(simple_user.name)  # \"Bob\"\nprint(simple_user.age)   # 31\n# simple_user doesn't have an email field\n</code></pre>"},{"location":"features/save_load/#reusing-proxies","title":"Reusing Proxies","text":"<p>You can reuse a proxy with different models by calling <code>save_to()</code> and then creating a new proxy:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create users\nuser1 = User(name=\"Alice\", age=30)\nuser2 = User(name=\"Bob\", age=31)\n\n# Create a proxy for user1\nproxy1 = ObservableProxy(user1, sync=False)\n\n# Make changes\nproxy1.observable(str, \"name\").set(\"Charlie\")\n\n# Save changes to user1\nproxy1.save_to(user1)\n\n# Create a new proxy for user2\nproxy2 = ObservableProxy(user2, sync=False)\n\n# Make changes\nproxy2.observable(int, \"age\").set(32)\n\n# Save changes to user2\nproxy2.save_to(user2)\n\n# Both users are updated\nprint(user1.name)  # \"Charlie\"\nprint(user1.age)   # 30\nprint(user2.name)  # \"Bob\"\nprint(user2.age)   # 32\n</code></pre> <p>This approach is useful when you want to work with multiple models sequentially.</p>"},{"location":"features/save_load/#next-steps","title":"Next Steps","text":"<p>Now that you understand how saving and loading work in Observant, you might want to explore:</p> <ul> <li>API Reference: Detailed API documentation</li> <li>Sync vs Non-Sync: Understand immediate vs. deferred updates</li> <li>Dirty Tracking: Track unsaved changes</li> </ul>"},{"location":"features/sync/","title":"Sync vs Non-Sync","text":"<p>Observant provides two modes of operation for <code>ObservableProxy</code>: sync mode and non-sync mode. This page explains the differences between these modes and when to use each.</p>"},{"location":"features/sync/#overview","title":"Overview","text":"<p>When you create an <code>ObservableProxy</code>, you can specify whether changes to the proxy should be immediately synchronized with the underlying model:</p> <ul> <li><code>sync=True</code>: Changes to the proxy are immediately applied to the underlying model</li> <li><code>sync=False</code>: Changes to the proxy are only applied to the underlying model when you call <code>save_to()</code></li> </ul> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\n# Create a user\nuser = User(name=\"Alice\", age=30)\n\n# Create a proxy with sync=True\nproxy_sync = ObservableProxy(user, sync=True)\n\n# Create a proxy with sync=False\nproxy_non_sync = ObservableProxy(user, sync=False)\n</code></pre>"},{"location":"features/sync/#synctrue-vs-syncfalse","title":"sync=True vs sync=False","text":""},{"location":"features/sync/#synctrue","title":"sync=True","text":"<p>When <code>sync=True</code>, any changes you make to the proxy are immediately applied to the underlying model:</p> <pre><code># Create a user and proxy with sync=True\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=True)\n\n# Change a field\nproxy.observable(str, \"name\").set(\"Bob\")\n\n# The change is immediately applied to the user object\nprint(user.name)  # \"Bob\"\n</code></pre> <p>This mode is useful when:</p> <ul> <li>You want to keep the model and proxy in sync at all times</li> <li>You're working with a model that needs to reflect changes immediately</li> <li>You don't need to validate or review changes before applying them</li> </ul>"},{"location":"features/sync/#syncfalse","title":"sync=False","text":"<p>When <code>sync=False</code>, changes to the proxy are not automatically applied to the underlying model. You need to explicitly call <code>save_to()</code> to apply the changes:</p> <pre><code># Create a user and proxy with sync=False\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=False)\n\n# Change a field\nproxy.observable(str, \"name\").set(\"Bob\")\n\n# The change is not applied to the user object yet\nprint(user.name)  # \"Alice\"\n\n# Apply the changes\nproxy.save_to(user)\n\n# Now the change is applied\nprint(user.name)  # \"Bob\"\n</code></pre> <p>This mode is useful when:</p> <ul> <li>You want to validate changes before applying them</li> <li>You need to support undo/redo functionality</li> <li>You want to track dirty state</li> <li>You need to review or confirm changes before saving</li> </ul>"},{"location":"features/sync/#when-to-use-each","title":"When to Use Each","text":""},{"location":"features/sync/#use-synctrue-when","title":"Use sync=True When","text":"<ul> <li>You need immediate synchronization between the proxy and the model</li> <li>You're working with a model that needs to reflect changes in real-time</li> <li>You don't need undo/redo functionality</li> <li>You don't need to track dirty state</li> </ul>"},{"location":"features/sync/#use-syncfalse-when","title":"Use sync=False When","text":"<ul> <li>You need to validate changes before applying them</li> <li>You want to support undo/redo functionality</li> <li>You want to track dirty state</li> <li>You need to review or confirm changes before saving</li> <li>You want to optimize performance by batching updates</li> </ul>"},{"location":"features/sync/#save_to-and-load_dict","title":"save_to() and load_dict()","text":"<p>When using <code>sync=False</code>, you need to explicitly apply changes to the model using <code>save_to()</code>:</p> <pre><code># Create a user and proxy with sync=False\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=False)\n\n# Make changes\nproxy.observable(str, \"name\").set(\"Bob\")\nproxy.observable(int, \"age\").set(31)\n\n# Validate changes\nif proxy.is_valid():\n    # Apply changes\n    proxy.save_to(user)\nelse:\n    # Show validation errors\n    print(\"Validation errors:\", proxy.validation_errors())\n</code></pre> <p>You can also load data into the proxy from a dictionary using <code>load_dict()</code>:</p> <pre><code># Load data from a dictionary\nproxy.load_dict({\n    \"name\": \"Charlie\",\n    \"age\": 32\n})\n\n# The changes are not applied to the user object yet\nprint(user.name)  # \"Bob\" (or \"Alice\" if save_to() wasn't called)\n\n# Apply the changes\nproxy.save_to(user)\n\n# Now the changes are applied\nprint(user.name)  # \"Charlie\"\n</code></pre>"},{"location":"features/sync/#update-vs-load_dict","title":"update() vs load_dict()","text":"<p>Observant provides two methods for updating multiple fields at once: <code>update()</code> and <code>load_dict()</code>. The main difference is that <code>update()</code> only updates the fields that are provided, while <code>load_dict()</code> updates all fields in the dictionary.</p>"},{"location":"features/sync/#update","title":"update()","text":"<p>The <code>update()</code> method updates only the fields that are provided in the dictionary:</p> <pre><code># Create a user and proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=False)\n\n# Update specific fields\nproxy.update({\n    \"name\": \"Bob\"\n})\n\n# Only the specified fields are updated\nprint(proxy.observable(str, \"name\").get())  # \"Bob\"\nprint(proxy.observable(int, \"age\").get())  # 30 (unchanged)\n</code></pre>"},{"location":"features/sync/#load_dict","title":"load_dict()","text":"<p>The <code>load_dict()</code> method updates all fields in the dictionary, and can optionally reset fields that are not in the dictionary:</p> <pre><code># Create a user and proxy\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=False)\n\n# Load a dictionary\nproxy.load_dict({\n    \"name\": \"Bob\"\n}, reset_missing=False)\n\n# Only the specified fields are updated\nprint(proxy.observable(str, \"name\").get())  # \"Bob\"\nprint(proxy.observable(int, \"age\").get())  # 30 (unchanged)\n\n# Load a dictionary with reset_missing=True\nproxy.load_dict({\n    \"name\": \"Charlie\"\n}, reset_missing=True)\n\n# Fields not in the dictionary are reset to their default values\nprint(proxy.observable(str, \"name\").get())  # \"Charlie\"\nprint(proxy.observable(int, \"age\").get())  # 0 (reset to default)\n</code></pre>"},{"location":"features/sync/#performance-considerations","title":"Performance Considerations","text":"<p>The choice between <code>sync=True</code> and <code>sync=False</code> can affect performance:</p> <ul> <li><code>sync=True</code> may be slower if you're making many changes, since each change triggers an update to the model</li> <li><code>sync=False</code> may be faster for bulk updates, since you can batch changes and apply them all at once</li> </ul> <pre><code># sync=True: Each change triggers an update\nproxy_sync = ObservableProxy(user, sync=True)\nfor i in range(1000):\n    proxy_sync.observable(int, \"age\").set(i)  # 1000 updates to the model\n\n# sync=False: Changes are batched\nproxy_non_sync = ObservableProxy(user, sync=False)\nfor i in range(1000):\n    proxy_non_sync.observable(int, \"age\").set(i)  # No updates to the model yet\nproxy_non_sync.save_to(user)  # 1 update to the model\n</code></pre>"},{"location":"features/sync/#sync-and-undo","title":"Sync and Undo","text":"<p>The <code>sync</code> and <code>undo</code> options can be used together, but this can lead to unexpected behavior. When <code>sync=True</code>, changes are immediately applied to the underlying model, which means that undo operations will not affect the model until you call <code>save_to</code>.</p> <pre><code>user = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=True, undo=True)\n\n# Make a change\nproxy.observable(str, \"name\").set(\"Bob\")\nprint(user.name)  # \"Bob\" (sync=True applies changes immediately)\n\n# Undo the change\nproxy.undo(\"name\")\nprint(proxy.observable(str, \"name\").get())  # \"Alice\"\nprint(user.name)  # Still \"Bob\" until save_to is called\n\n# Save changes back to the model\nproxy.save_to(user)\nprint(user.name)  # Now \"Alice\"\n</code></pre> <p>For this reason, it's generally recommended to use <code>sync=False</code> when using undo functionality.</p>"},{"location":"features/sync/#next-steps","title":"Next Steps","text":"<p>Now that you understand the difference between sync and non-sync modes in Observant, you might want to explore:</p> <ul> <li>Saving and Loading: Learn more about saving changes and loading data</li> <li>Dirty Tracking: Track unsaved changes</li> <li>Undo and Redo: Implement undo/redo functionality</li> </ul>"},{"location":"features/undo/","title":"Undo and Redo","text":"<p>Observant provides built-in undo and redo functionality, allowing you to track changes to your data and revert them if needed. This page explains how the undo/redo system works in Observant.</p>"},{"location":"features/undo/#overview","title":"Overview","text":"<p>The undo/redo system in Observant is field-based, meaning you can undo changes to individual fields independently. This gives you fine-grained control over which changes to revert.</p> <p>Key features of the undo/redo system:</p> <ul> <li>Per-field undo/redo</li> <li>Configurable undo stack size</li> <li>Debounce support for rapid changes</li> <li>Integration with validation and dirty tracking</li> </ul>"},{"location":"features/undo/#enabling-undo","title":"Enabling Undo","text":"<p>To enable undo functionality, you can either:</p> <ol> <li>Enable it globally when creating the proxy</li> <li>Enable it for specific fields after creating the proxy</li> </ol>"},{"location":"features/undo/#global-undo","title":"Global Undo","text":"<p>To enable undo globally, set <code>undo=True</code> when creating the proxy:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, undo=True)  # Enable undo for all fields\n</code></pre>"},{"location":"features/undo/#per-field-undo","title":"Per-Field Undo","text":"<p>To enable undo for specific fields, use the <code>set_undo_config</code> method:</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n    email: str\n\nuser = User(name=\"Alice\", age=30, email=\"alice@example.com\")\nproxy = ObservableProxy(user)  # Undo disabled by default\n\n# Enable undo for specific fields\nproxy.set_undo_config(\"name\", enabled=True)\nproxy.set_undo_config(\"age\", enabled=True)\n# email field will not have undo enabled\n</code></pre>"},{"location":"features/undo/#undo-configuration","title":"Undo Configuration","text":"<p>The undo system can be configured with several options:</p> <ul> <li><code>enabled</code>: Whether undo is enabled for a field</li> <li><code>undo_max</code>: Maximum number of undo steps to store</li> <li><code>undo_debounce_ms</code>: Time in milliseconds to wait before recording a new undo step</li> </ul>"},{"location":"features/undo/#undo_max","title":"undo_max","text":"<p>The <code>undo_max</code> option limits the number of undo steps that are stored for a field. This prevents the undo stack from growing too large and consuming too much memory.</p> <pre><code># Limit to 10 undo steps\nproxy.set_undo_config(\"name\", enabled=True, undo_max=10)\n</code></pre>"},{"location":"features/undo/#undo_debounce_ms","title":"undo_debounce_ms","text":"<p>The <code>undo_debounce_ms</code> option adds debounce behavior to the undo system. If multiple changes are made to a field within the debounce time, only the last change is recorded as an undo step.</p> <p>This is useful for fields that change rapidly, such as text fields during typing:</p> <pre><code># Debounce undo steps by 500ms\nproxy.set_undo_config(\"name\", enabled=True, undo_debounce_ms=500)\n\n# These rapid changes will be combined into a single undo step\nproxy.observable(str, \"name\").set(\"A\")\nproxy.observable(str, \"name\").set(\"Al\")\nproxy.observable(str, \"name\").set(\"Ali\")\nproxy.observable(str, \"name\").set(\"Alic\")\nproxy.observable(str, \"name\").set(\"Alice\")\n\n# Only one undo step is created\nproxy.undo(\"name\")  # Reverts directly to the original value\n</code></pre>"},{"location":"features/undo/#undoredo-api","title":"Undo/Redo API","text":"<p>Once undo is enabled, you can use the following methods to undo and redo changes:</p> <ul> <li><code>undo(field)</code>: Undo the last change to a field</li> <li><code>redo(field)</code>: Redo the last undone change to a field</li> <li><code>can_undo(field)</code>: Check if there are any undo steps available for a field</li> <li><code>can_redo(field)</code>: Check if there are any redo steps available for a field</li> </ul>"},{"location":"features/undo/#basic-undoredo","title":"Basic Undo/Redo","text":"<pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    name: str\n    age: int\n\nuser = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, undo=True)\n\n# Make some changes\nproxy.observable(str, \"name\").set(\"Bob\")\nproxy.observable(int, \"age\").set(25)\n\n# Undo changes\nproxy.undo(\"name\")  # Reverts name to \"Alice\"\nproxy.undo(\"age\")   # Reverts age to 30\n\n# Redo changes\nproxy.redo(\"name\")  # Sets name back to \"Bob\"\nproxy.redo(\"age\")   # Sets age back to 25\n</code></pre>"},{"location":"features/undo/#checking-undoredo-availability","title":"Checking Undo/Redo Availability","text":"<p>You can check if undo or redo is available for a field using the <code>can_undo</code> and <code>can_redo</code> methods:</p> <pre><code># Check if undo is available\nif proxy.can_undo(\"name\"):\n    proxy.undo(\"name\")\n\n# Check if redo is available\nif proxy.can_redo(\"name\"):\n    proxy.redo(\"name\")\n</code></pre> <p>These methods return observables, so you can also listen for changes:</p> <pre><code># Listen for changes to undo availability\nproxy.can_undo(\"name\").on_change(lambda can_undo: \n    print(f\"Undo available for name: {can_undo}\"))\n\n# Listen for changes to redo availability\nproxy.can_redo(\"name\").on_change(lambda can_redo: \n    print(f\"Redo available for name: {can_redo}\"))\n</code></pre>"},{"location":"features/undo/#per-field-vs-global-undo","title":"Per-Field vs Global Undo","text":"<p>Observant's undo system is field-based, meaning each field has its own undo stack. This allows you to undo changes to one field without affecting others.</p> <pre><code># Make changes to multiple fields\nproxy.observable(str, \"name\").set(\"Bob\")\nproxy.observable(int, \"age\").set(25)\n\n# Undo only the name change\nproxy.undo(\"name\")  # Reverts name to \"Alice\"\n\n# Age remains changed\nprint(proxy.observable(int, \"age\").get())  # 25\n</code></pre> <p>This field-based approach gives you more control over which changes to undo, but it also means you need to undo each field separately if you want to undo all changes.</p> <p>If you need to undo all changes at once, you can iterate over the fields:</p> <pre><code># Undo all fields\nfor field in [\"name\", \"age\", \"email\"]:\n    if proxy.can_undo(field).get():\n        proxy.undo(field)\n</code></pre>"},{"location":"features/undo/#limitations-and-gotchas","title":"Limitations and Gotchas","text":""},{"location":"features/undo/#sync-and-undo","title":"Sync and Undo","text":"<p>The <code>sync</code> and <code>undo</code> options can be used together, but this can lead to unexpected behavior. When <code>sync=True</code>, changes are immediately applied to the underlying model, which means that undo operations will not affect the model until you call <code>save_to</code>.</p> <pre><code>user = User(name=\"Alice\", age=30)\nproxy = ObservableProxy(user, sync=True, undo=True)\n\n# Make a change\nproxy.observable(str, \"name\").set(\"Bob\")\nprint(user.name)  # \"Bob\" (sync=True applies changes immediately)\n\n# Undo the change\nproxy.undo(\"name\")\nprint(proxy.observable(str, \"name\").get())  # \"Alice\"\nprint(user.name)  # Still \"Bob\" until save_to is called\n\n# Save changes back to the model\nproxy.save_to(user)\nprint(user.name)  # Now \"Alice\"\n</code></pre> <p>For this reason, it's generally recommended to use <code>sync=False</code> when using undo functionality.</p>"},{"location":"features/undo/#collection-fields","title":"Collection Fields","text":"<p>For list and dictionary fields, undo/redo works on the entire collection, not individual elements. This means that if you make multiple changes to a collection, undoing will revert all of those changes at once.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass TodoList:\n    tasks: list[str]\n\ntodo_list = TodoList(tasks=[\"Buy milk\"])\nproxy = ObservableProxy(todo_list, undo=True)\n\n# Get the observable list\ntasks = proxy.observable_list(str, \"tasks\")\n\n# Make multiple changes\ntasks.append(\"Write docs\")\ntasks.append(\"Fix bugs\")\ntasks.remove(\"Buy milk\")\n\n# Undo all changes at once\nproxy.undo(\"tasks\")  # Reverts to [\"Buy milk\"]\n</code></pre>"},{"location":"features/undo/#computed-fields","title":"Computed Fields","text":"<p>Computed fields are not directly undoable, since their values are derived from other fields. However, when you undo changes to a field that a computed field depends on, the computed field will update accordingly.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\nuser = User(first_name=\"Alice\", last_name=\"Smith\")\nproxy = ObservableProxy(user, undo=True)\n\n# Register a computed property\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\n\n# Make a change\nproxy.observable(str, \"first_name\").set(\"Bob\")\nprint(proxy.computed(str, \"full_name\").get())  # \"Bob Smith\"\n\n# Undo the change\nproxy.undo(\"first_name\")\nprint(proxy.computed(str, \"full_name\").get())  # \"Alice Smith\"\n</code></pre>"},{"location":"features/undo/#validation-and-undo","title":"Validation and Undo","text":"<p>When you undo a change, validation is automatically re-run for the affected field. This means that if you undo a change that makes a field invalid, the validation errors will be updated accordingly.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    username: str\n\nuser = User(username=\"\")\nproxy = ObservableProxy(user, undo=True)\n\n# Add a validator\nproxy.add_validator(\"username\", lambda v: \"Username required\" if not v else None)\n\n# Set a valid value\nproxy.observable(str, \"username\").set(\"alice\")\nprint(proxy.is_valid())  # True\n\n# Undo the change\nproxy.undo(\"username\")\nprint(proxy.is_valid())  # False\nprint(proxy.validation_for(\"username\").get())  # [\"Username required\"]\n</code></pre>"},{"location":"features/undo/#next-steps","title":"Next Steps","text":"<p>Now that you understand how undo and redo work in Observant, you might want to explore:</p> <ul> <li>Computed Properties: Create properties that depend on other fields</li> <li>Dirty Tracking: Track unsaved changes</li> <li>Sync vs Non-Sync: Understand immediate vs. deferred updates</li> </ul>"},{"location":"features/validation/","title":"Validation","text":"<p>Observant provides a powerful validation system that allows you to validate your data as it changes. This page explains how validation works in Observant.</p>"},{"location":"features/validation/#overview","title":"Overview","text":"<p>Validation in Observant is field-based, meaning you can add validators to individual fields of your model. Validators are functions that check if a field's value is valid and return an error message if it's not.</p> <p>The validation system provides:</p> <ul> <li>Field-level validation</li> <li>Multiple validators per field</li> <li>Observable validation state</li> <li>Validation for computed fields</li> <li>Exception handling in validators</li> </ul>"},{"location":"features/validation/#adding-validators","title":"Adding Validators","text":"<p>You can add validators to a field using the <code>add_validator</code> method of <code>ObservableProxy</code>. A validator is a function that takes the field's value as input and returns either:</p> <ul> <li><code>None</code> if the value is valid</li> <li>A string error message if the value is invalid</li> </ul> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    username: str\n    email: str\n    age: int\n\n# Create a user and proxy\nuser = User(username=\"\", email=\"\", age=0)\nproxy = ObservableProxy(user)\n\n# Add validators\nproxy.add_validator(\"username\", lambda v: \"Username required\" if not v else None)\nproxy.add_validator(\"email\", lambda v: \"Invalid email\" if \"@\" not in v else None)\nproxy.add_validator(\"age\", lambda v: \"Must be positive\" if v &lt;= 0 else None)\n</code></pre>"},{"location":"features/validation/#multiple-validators","title":"Multiple Validators","text":"<p>You can add multiple validators to the same field. All validators will run, and all error messages will be collected.</p> <pre><code># Add multiple validators to the same field\nproxy.add_validator(\"username\", lambda v: \"Username required\" if not v else None)\nproxy.add_validator(\"username\", lambda v: \"Too short\" if len(v) &lt; 3 else None)\nproxy.add_validator(\"username\", lambda v: \"No spaces allowed\" if \" \" in v else None)\n\n# Set an invalid value\nproxy.observable(str, \"username\").set(\"a\")\n\n# Check validation errors\nerrors = proxy.validation_for(\"username\").get()\nprint(errors)  # ['Too short']\n</code></pre>"},{"location":"features/validation/#complex-validators","title":"Complex Validators","text":"<p>Validators can be as simple or complex as needed. Here's an example of a more complex validator:</p> <pre><code>def validate_password(password: str) -&gt; str | None:\n    if len(password) &lt; 8:\n        return \"Password must be at least 8 characters\"\n    if not any(c.isupper() for c in password):\n        return \"Password must contain at least one uppercase letter\"\n    if not any(c.islower() for c in password):\n        return \"Password must contain at least one lowercase letter\"\n    if not any(c.isdigit() for c in password):\n        return \"Password must contain at least one digit\"\n    return None\n\nproxy.add_validator(\"password\", validate_password)\n</code></pre>"},{"location":"features/validation/#validation_errors-and-validation_for","title":"validation_errors() and validation_for()","text":"<p>Observant provides two main methods for checking validation state:</p> <ul> <li><code>validation_errors()</code>: Returns an observable dictionary of all validation errors</li> <li><code>validation_for(field)</code>: Returns an observable list of validation errors for a specific field</li> </ul>"},{"location":"features/validation/#validation_errors","title":"validation_errors()","text":"<p>The <code>validation_errors()</code> method returns an observable dictionary where:</p> <ul> <li>Keys are field names with validation errors</li> <li>Values are lists of error messages for each field</li> </ul> <pre><code># Check all validation errors\nerrors = proxy.validation_errors()\nprint(errors)  # {'username': ['Too short'], 'email': ['Invalid email'], 'age': ['Must be positive']}\n\n# The errors dictionary is observable\nerrors.on_change(lambda change: print(f\"Validation errors changed: {change}\"))\n\n# Fix the username\nproxy.observable(str, \"username\").set(\"alice\")\n# The errors dictionary will update automatically\n</code></pre>"},{"location":"features/validation/#validation_for","title":"validation_for()","text":"<p>The <code>validation_for(field)</code> method returns an observable list of validation errors for a specific field:</p> <pre><code># Check validation errors for a specific field\nusername_errors = proxy.validation_for(\"username\").get()\nprint(username_errors)  # ['Too short']\n\n# The errors list is observable\nproxy.validation_for(\"username\").on_change(lambda errors: print(f\"Username errors: {errors}\"))\n\n# Fix the username\nproxy.observable(str, \"username\").set(\"alice\")\n# Prints: \"Username errors: []\"\n</code></pre>"},{"location":"features/validation/#is_valid","title":"is_valid()","text":"<p>The <code>is_valid()</code> method returns an observable boolean indicating whether the entire model is valid:</p> <pre><code># Check if the model is valid\nis_valid = proxy.is_valid()\nprint(is_valid)  # False\n\n# The is_valid observable updates automatically\nproxy.is_valid().on_change(lambda valid: print(f\"Model is valid: {valid}\"))\n\n# Fix all validation errors\nproxy.observable(str, \"username\").set(\"alice\")\nproxy.observable(str, \"email\").set(\"alice@example.com\")\nproxy.observable(int, \"age\").set(30)\n# Prints: \"Model is valid: True\"\n</code></pre>"},{"location":"features/validation/#resetting-validation","title":"Resetting Validation","text":"<p>Sometimes you may want to reset the validation state, for example when a form is submitted or when you want to clear all validation errors.</p>"},{"location":"features/validation/#reset_validation","title":"reset_validation()","text":"<p>The <code>reset_validation()</code> method resets the validation state for all fields or for a specific field:</p> <pre><code># Reset validation for all fields\nproxy.reset_validation()\n\n# Reset validation for a specific field\nproxy.reset_validation(\"username\")\n</code></pre> <p>By default, <code>reset_validation()</code> also re-runs the validators. If you want to just clear the validation state without re-running the validators, you can set <code>revalidate=False</code>:</p> <pre><code># Reset validation without re-running validators\nproxy.reset_validation(revalidate=False)\n</code></pre>"},{"location":"features/validation/#computed-field-validation","title":"Computed Field Validation","text":"<p>Observant also supports validation for computed fields. When a computed field's dependencies change, the computed field's validators are automatically re-run.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n\n# Create a user and proxy\nuser = User(first_name=\"\", last_name=\"\")\nproxy = ObservableProxy(user)\n\n# Register a computed property for full name\nproxy.register_computed(\n    \"full_name\",\n    lambda: f\"{proxy.observable(str, 'first_name').get()} {proxy.observable(str, 'last_name').get()}\",\n    dependencies=[\"first_name\", \"last_name\"]\n)\n\n# Add a validator to the computed field\nproxy.add_validator(\"full_name\", lambda v: \"Full name too short\" if len(v.strip()) &lt; 5 else None)\n\n# Check validation\nprint(proxy.is_valid())  # False\nprint(proxy.validation_for(\"full_name\").get())  # ['Full name too short']\n\n# Update the dependencies\nproxy.observable(str, \"first_name\").set(\"Alice\")\nproxy.observable(str, \"last_name\").set(\"Smith\")\n\n# Validation is automatically updated\nprint(proxy.is_valid())  # True\nprint(proxy.validation_for(\"full_name\").get())  # []\n</code></pre>"},{"location":"features/validation/#exception-handling-in-validators","title":"Exception Handling in Validators","text":"<p>Validators can sometimes raise exceptions, especially if they perform complex operations. Observant catches these exceptions and converts them to validation error messages.</p> <pre><code>from dataclasses import dataclass\nfrom observant import ObservableProxy\n\n@dataclass\nclass User:\n    username: str\n\n# Create a user and proxy\nuser = User(username=\"\")\nproxy = ObservableProxy(user)\n\n# Add a validator that might raise an exception\ndef buggy_validator(value):\n    if not value:\n        raise ValueError(\"Username cannot be empty\")\n    return None\n\nproxy.add_validator(\"username\", buggy_validator)\n\n# Check validation\nprint(proxy.is_valid())  # False\nprint(proxy.validation_for(\"username\").get())  # ['Username cannot be empty']\n\n# Fix the value\nproxy.observable(str, \"username\").set(\"alice\")\nprint(proxy.is_valid())  # True\n</code></pre> <p>This feature is particularly useful when:</p> <ul> <li>You're integrating with external validation libraries that might raise exceptions</li> <li>You want to use assert-style validation that raises exceptions</li> <li>You're performing complex validation that might fail unexpectedly</li> </ul>"},{"location":"features/validation/#different-types-of-exceptions","title":"Different Types of Exceptions","text":"<p>Observant handles all types of exceptions in validators, not just <code>ValueError</code>:</p> <pre><code>def type_error_validator(value):\n    if not isinstance(value, str):\n        raise TypeError(\"Value must be a string\")\n    return None\n\ndef key_error_validator(value):\n    if value not in [\"admin\", \"user\", \"guest\"]:\n        raise KeyError(f\"Unknown role: {value}\")\n    return None\n\nproxy.add_validator(\"role\", type_error_validator)\nproxy.add_validator(\"role\", key_error_validator)\n</code></pre>"},{"location":"features/validation/#next-steps","title":"Next Steps","text":"<p>Now that you understand how validation works in Observant, you might want to explore:</p> <ul> <li>Computed Properties: Create properties that depend on other fields</li> <li>Undo and Redo: Implement undo/redo functionality</li> <li>Dirty Tracking: Track unsaved changes</li> </ul>"}]}